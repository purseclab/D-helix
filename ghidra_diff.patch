diff --git a/Ghidra/Features/Base/.launch/Ghidra Code Coverage.launch b/Ghidra/Features/Base/.launch/Ghidra Code Coverage.launch
index ae7716504..7373b0c81 100644
--- a/Ghidra/Features/Base/.launch/Ghidra Code Coverage.launch	
+++ b/Ghidra/Features/Base/.launch/Ghidra Code Coverage.launch	
@@ -20,6 +20,7 @@
     <listAttribute key="org.eclipse.jdt.launching.CLASSPATH">
         <listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry path=&quot;5&quot; projectName=&quot;Framework Utility&quot; type=&quot;1&quot;/&gt;&#10;"/>
     </listAttribute>
+    <stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.buildship.core.classpathprovider"/>
     <booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
     <stringAttribute key="org.eclipse.jdt.launching.JRE_CONTAINER" value="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-11"/>
     <stringAttribute key="org.eclipse.jdt.launching.MAIN_TYPE" value="ghidra.GhidraLauncher"/>
diff --git a/Ghidra/Features/Base/.launch/Ghidra.launch b/Ghidra/Features/Base/.launch/Ghidra.launch
index e9f428a5d..bc07f4280 100644
--- a/Ghidra/Features/Base/.launch/Ghidra.launch
+++ b/Ghidra/Features/Base/.launch/Ghidra.launch
@@ -23,6 +23,7 @@
     <listAttribute key="org.eclipse.jdt.launching.CLASSPATH">
         <listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry path=&quot;5&quot; projectName=&quot;Framework Utility&quot; type=&quot;1&quot;/&gt;&#10;"/>
     </listAttribute>
+    <stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.buildship.core.classpathprovider"/>
     <booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
     <stringAttribute key="org.eclipse.jdt.launching.JRE_CONTAINER" value="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-11"/>
     <stringAttribute key="org.eclipse.jdt.launching.MAIN_TYPE" value="ghidra.GhidraLauncher"/>
diff --git a/Ghidra/Features/Base/ghidra_scripts/PropagateX86ConstantReferences.java b/Ghidra/Features/Base/ghidra_scripts/PropagateX86ConstantReferences.java
index 6d4379c26..586c0691c 100644
--- a/Ghidra/Features/Base/ghidra_scripts/PropagateX86ConstantReferences.java
+++ b/Ghidra/Features/Base/ghidra_scripts/PropagateX86ConstantReferences.java
@@ -40,6 +40,7 @@ import ghidra.program.model.symbol.*;
 import ghidra.program.util.SymbolicPropogator;
 import ghidra.program.util.VarnodeContext;
 import ghidra.util.exception.*;
+import ghidra.util.Msg;
 
 public class PropagateX86ConstantReferences extends GhidraScript {
 
@@ -153,6 +154,9 @@ public class PropagateX86ConstantReferences extends GhidraScript {
 					String mnemonic = instr.getMnemonicString();
 					if ((mnemonic.compareToIgnoreCase("CMP") == 0)) {
 						int numOps = instr.getNumOperands();
+						Msg.debug(this,instr.getAddress());
+						Msg.debug(this,instr.getPcode(0).toString());
+						Msg.debug(this,instr.getPcode(1).toString());
 						if (numOps > 1) {
 							Register reg = instr.getRegister(numOps - 2);
 							if ((reg != null)) {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/disassemble/DisassembleCommand.java b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/disassemble/DisassembleCommand.java
index 9521ec3ec..a9aa8dbb0 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/disassemble/DisassembleCommand.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/disassemble/DisassembleCommand.java
@@ -28,6 +28,8 @@ import ghidra.program.model.mem.MemoryBlock;
 import ghidra.util.exception.CancelledException;
 import ghidra.util.task.TaskMonitor;
 
+import ghidra.util.Msg;
+
 /**
  * Command object for performing disassembly
  */
@@ -348,6 +350,7 @@ public class DisassembleCommand extends BackgroundCommand {
 	 */
 	private static void analyzeIfNeeded(AutoAnalysisManager mgr, AddressSetView startSet,
 			AddressSetView disassembledSet, TaskMonitor monitor) {
+
 		if (disassembledSet == null || disassembledSet.isEmpty()) {
 			return;
 		}
@@ -359,6 +362,7 @@ public class DisassembleCommand extends BackgroundCommand {
 		AddressRange firstRange = disassembledSet.getFirstRange();
 		Address rangeEnd = firstRange.getMaxAddress();
 		Address nextAddr = rangeEnd.next();
+		Msg.debug(DisassembleCommand.class,"In analyzeIfNeeded");
 		if (nextAddr != null && startSet.contains(rangeEnd) && startSet.contains(nextAddr)) {
 			mgr.startAnalysis(monitor, false);
 		}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AnalysisBackgroundCommand.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AnalysisBackgroundCommand.java
index 120e48a72..68191d250 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AnalysisBackgroundCommand.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AnalysisBackgroundCommand.java
@@ -27,6 +27,8 @@ import ghidra.program.util.GhidraProgramUtilities;
 import ghidra.util.SystemUtilities;
 import ghidra.util.task.TaskMonitor;
 
+import ghidra.util.Msg;
+
 /**
  * Background task to artificially kick off Auto analysis by
  * calling anything that analyzes bytes.
@@ -50,11 +52,13 @@ public class AnalysisBackgroundCommand extends MergeableBackgroundCommand {
 		this.markAsAnalyzed = markAsAnalyzed;
 	}
 
+	//muqi:to flowConstants step 3
 	@Override
 	public boolean applyTo(DomainObject obj, TaskMonitor monitor) {
 		if (markAsAnalyzed) {
 			GhidraProgramUtilities.setAnalyzedFlag((Program) obj, true);
 		}
+		Msg.debug(this, "In applyTo of AnalysisBackgroundCommand");
 		mgr.startAnalysis(monitor);
 		return true;
 	}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java
index 042882c9a..470cbd1ac 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/AutoAnalysisManager.java
@@ -629,6 +629,7 @@ public class AutoAnalysisManager implements DomainObjectListener, DomainObjectCl
 	 * @param monitor the monitor
 	 */
 	public void startAnalysis(TaskMonitor monitor) {
+		Msg.debug(this,"In startAnalysis");
 		startAnalysis(monitor, true);
 	}
 
@@ -647,6 +648,7 @@ public class AutoAnalysisManager implements DomainObjectListener, DomainObjectCl
 	 * will be printed to the log.
 	 */
 	public void startAnalysis(TaskMonitor monitor, boolean printTaskTimes) {
+
 		if (Thread.currentThread() == analysisThread) {
 			// TODO: should this yield for analysis?
 			//    Thinking was that if some analysis causes disassembly to occur,
@@ -686,6 +688,7 @@ public class AutoAnalysisManager implements DomainObjectListener, DomainObjectCl
 			startTime = System.currentTimeMillis();
 			try {
 				task.applyTo(p, monitor);
+				Msg.debug(this, "In run of AnalysisTaskWrapper Analysis Task: " + task.getName());
 			}
 			catch (RuntimeException th) {
 				if (debugOn) {
@@ -733,7 +736,8 @@ public class AutoAnalysisManager implements DomainObjectListener, DomainObjectCl
 	 */
 	private void startAnalysis(TaskMonitor monitor, boolean yield, Integer limitPriority,
 			boolean printTaskTimes) {
-
+				//muqi : here we start our analysis~!
+		Msg.debug(this,"second startAnalysis");
 		// the program may have been closed before while this thread was waiting
 		if (program == null || program.isClosed()) {
 			return;
@@ -772,7 +776,7 @@ public class AutoAnalysisManager implements DomainObjectListener, DomainObjectCl
 				backgroundAnalysisPending = false;
 			}
 		}
-
+        Msg.debug(this,"assign the first task to activetask");
 		try {
 			if (printTaskTimes) {
 				clearTimedTasks();
@@ -797,7 +801,7 @@ public class AutoAnalysisManager implements DomainObjectListener, DomainObjectCl
 					}
 				}
 			}
-
+			Msg.debug(this,"finished while loop of activeTask");
 			if (!yield) {
 				notifyAnalysisEnded();
 				if (printTaskTimes) {
@@ -885,10 +889,11 @@ public class AutoAnalysisManager implements DomainObjectListener, DomainObjectCl
 	}
 
 	synchronized boolean schedule(BackgroundCommand cmd, int priority) {
-
+		
 		if (cmd == null) {
 			throw new IllegalArgumentException("Can't schedule a null command");
 		}
+		Msg.debug(this,"In schedule, name is: "+cmd.getName()+" priority: "+ priority);
 		queue.add(cmd, priority);
 
 		return startBackgroundAnalysis();
@@ -901,7 +906,7 @@ public class AutoAnalysisManager implements DomainObjectListener, DomainObjectCl
 	 * scheduled/running.
 	 */
 	public synchronized boolean startBackgroundAnalysis() {
-
+		Msg.debug(this,"In startBackgroundAnalysis");
 		if (!isEnabled) {
 			return false;
 		}
@@ -910,8 +915,11 @@ public class AutoAnalysisManager implements DomainObjectListener, DomainObjectCl
 		}
 
 		analysisTool = getActiveTool(program);
+		
 		if (analysisTool != null) {
+			Msg.debug(this,"name of analysisTool is: "+analysisTool.getName());
 			AnalysisBackgroundCommand analysisCmd = new AnalysisBackgroundCommand(this, false);
+			Msg.debug(this,"name of analysisCmd is: "+analysisCmd.getName());
 			backgroundAnalysisPending = true;
 			analysisTool.scheduleFollowOnCommand(analysisCmd, program);
 			return true;
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/database/ProgramBuilder.java b/Ghidra/Features/Base/src/main/java/ghidra/program/database/ProgramBuilder.java
index c2814d7c1..d6f517ccb 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/program/database/ProgramBuilder.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/database/ProgramBuilder.java
@@ -55,6 +55,8 @@ import ghidra.util.exception.*;
 import ghidra.util.task.TaskMonitor;
 import utility.function.ExceptionalCallback;
 
+import ghidra.util.Msg;
+
 // TODO: Move this class into a different package (i.e., ghidra.test.program)
 public class ProgramBuilder {
 
@@ -150,7 +152,7 @@ public class ProgramBuilder {
 	 */
 	public void analyze() {
 		AutoAnalysisManager mgr = AutoAnalysisManager.getAnalysisManager(program);
-
+		Msg.debug(this,"In analyzeIfNeeded");
 		tx(() -> {
 			mgr.reAnalyzeAll(program.getMemory().getLoadedAndInitializedAddressSet());
 			mgr.startAnalysis(TaskMonitor.DUMMY, false);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java b/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java
index c2840f7f2..c77681c34 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/flatapi/FlatProgramAPI.java
@@ -51,6 +51,9 @@ import ghidra.util.exception.*;
 import ghidra.util.search.memory.*;
 import ghidra.util.task.TaskMonitor;
 
+
+import ghidra.util.Msg;
+
 /**
  * This class is a flattened version of the Program API.
  * <p>
@@ -226,7 +229,7 @@ public class FlatProgramAPI {
 
 		// analysis will start immediately in background if GUI analysis tool exists
 		// and script is not running as analysis worker in background
-
+		Msg.debug(this,"In analyzeChanges");
 		PluginTool analysisTool = mgr.getAnalysisTool();
 		if (analysisTool == null || analysisTool.threadIsBackgroundTaskThread()) {
 			mgr.startAnalysis(monitor, true); // yields to analysis
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java b/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java
index 0ec949884..614e38b18 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/program/util/SymbolicPropogator.java
@@ -772,10 +772,10 @@ public class SymbolicPropogator {
 		boolean mustClearAll = false;
 		// if inject pcode, don't want to do any store pcode ops for the injected code
 		boolean injected = false;
-
+		Msg.debug(this, "total length is "+ops.length);
 		int ptype = 0;
 		for (int pcodeIndex = 0; pcodeIndex < ops.length; pcodeIndex++) {
-
+			Msg.debug(this, "index is "+pcodeIndex);
 			mustClearAll = pcodeIndex < mustClearAllUntil_PcodeIndex;
 
 			ptype = ops[pcodeIndex].getOpcode();
@@ -1141,11 +1141,32 @@ public class SymbolicPropogator {
 							(BinaryOpBehavior) OpBehaviorFactory.getOpBehavior(ptype);
 						val1 = vContext.getValue(in[0], false, evaluator);
 						val2 = vContext.getValue(in[1], false, evaluator);
+						//muqi add debug
+						
+						Msg.debug(this, "val1 is: " + val1.getOffset());
+						Msg.debug(this, "address of val1 is: " +val1.getAddress().toString());
+						Msg.debug(this, "val2 is: " + val2.getOffset());
+						Msg.debug(this, "address of val2 is: " +val2.getAddress().toString());
+					
 						lresult = binaryBehavior.evaluateBinary(out.getSize(), in[0].getSize(),
 							vContext.getConstant(val1, evaluator),
 							vContext.getConstant(val2, evaluator));
 						result = vContext.createConstantVarnode(lresult, val1.getSize());
 						vContext.putValue(out, result, mustClearAll);
+						
+						/* used for tracing called function
+						int temp = 1;
+						if (temp == 1){
+							try
+							{
+								throw new NullPointerException("demo");
+							}
+							catch(NullPointerException e)
+							{
+								System.out.println("Caught inside fun().");
+								throw e; // rethrowing the exception
+							}}
+							*/
 						break;
 
 					case PcodeOp.INT_2COMP:
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/util/state/ResultsState.java b/Ghidra/Features/Base/src/main/java/ghidra/util/state/ResultsState.java
index ae3fc3064..f14713277 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/util/state/ResultsState.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/util/state/ResultsState.java
@@ -1094,6 +1094,8 @@ public class ResultsState {
 // TODO: Implement constant case
 
 			case PcodeOp.INT_SBORROW:  		// TRUE if borrow in signed subtraction of 2 ops 
+				Msg.debug(ResultsState.class, "val1 is" + values[0].getOffset());
+				Msg.debug(ResultsState.class, "val2 is" + values[1].getOffset());
 				if ((values[1].isConstant() && values[1].getOffset() == 0) ||
 					(values[0].isConstant() && values[0].getOffset() == 0)) {
 					result = new Varnode(addrFactory.getConstantAddress(0), 1);
diff --git a/Ghidra/Features/Decompiler/ghidra_scripts/GraphAST.java b/Ghidra/Features/Decompiler/ghidra_scripts/GraphAST.java
index aa610ac73..53e63afcf 100644
--- a/Ghidra/Features/Decompiler/ghidra_scripts/GraphAST.java
+++ b/Ghidra/Features/Decompiler/ghidra_scripts/GraphAST.java
@@ -97,6 +97,7 @@ public class GraphAST extends GhidraScript {
 				"Unable to initialize: " + ifc.getLastMessage());
 		}
 		ifc.setSimplificationStyle("normalize");
+		Msg.debug(this,"Inside private void buildAST()");
 		DecompileResults res = ifc.decompileFunction(func, 30, null);
 		high = res.getHighFunction();
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc
index 7b1b2062a..466ca9a4d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/action.cc
@@ -17,6 +17,10 @@
 #include "funcdata.hh"
 
 #include "coreaction.hh"
+#include <unistd.h>
+
+
+#define DEBUG_MUQI_type_recovery
 
 /// Specify the name, group, and properties of the Action
 /// \param f is the collection of property flags
@@ -809,6 +813,16 @@ Rule *ActionPool::getSubRule(const string &specify)
   return lastrule;
 }
 
+vector<string> blacklist;
+#define vContains(v, arg) (std::find(v.begin(), v.end(), arg) != v.end())
+void streamToVec(ifstream& infile, vector<string>& vec) {
+    std::string line;
+    while (std::getline(infile, line))
+    {
+            vec.push_back(line);
+    }
+}
+
 /// This method attempts to apply each Rule to the current PcodeOp
 /// Action breakpoints are checked if the Rule successfully applies.
 /// 0 is returned for no breakpoint, -1 if a breakpoint occurs.
@@ -820,67 +834,499 @@ Rule *ActionPool::getSubRule(const string &specify)
 int4 ActionPool::processOp(PcodeOp *op,Funcdata &data)
 
 {
+
+  ofstream myfile;
+  ofstream myfile2;
+  #ifdef DEBUG_MUQI_0x80 
+    int instruction_address_being_logged1 = 4198820; //004011a4->4198820 004011a9->4198825
+    int instruction_address_being_logged2 = 4198825; 
+    int instruction_address_being_logged3 = 4198840; //004011b8->4198840 004011bd->4198845
+    int instruction_address_being_logged4 = 4198845; 
+
+    int instruction_address_being_logged5 = 4198816; //004011a0->4198816 004011b4->4198836
+    int instruction_address_being_logged6 = 4198836; 
+  #endif 
+    #ifdef DEBUG_MUQI_type_recovery 
+    int instruction_address_being_logged = 4198786; //401182 -> 4198786  40118d->4198797 401191->4198801 401196->4198806 401199->4198809
+    int instruction_address_being_logged1 = 4198797; 
+    //int instruction_address_being_logged2 = 4198801; //401191->4198801
+    int instruction_address_being_logged2 = 4198768;  //401170->4198768
+    int instruction_address_being_logged3 = 4198806; 
+    int instruction_address_being_logged4 = 4198809; 
+    int instruction_address_being_logged5 = 4198768;  //401170->4198768
+    #endif
+
+        #ifdef DEBUG_MUQI_type_recovery 
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    if(op->getAddr().getOffset()==instruction_address_being_logged){
+          
+          if(op && op->code()){
+              myfile<<"Inside ActionPool::processOp \n";
+              myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+              myfile << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+
+              myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+              myfile << "data name is: " << data.getName() <<"\n";
+              for (int i = 0; i <op->numInput(); i ++){
+                if (op->getIn(i)){
+                  myfile << "var"<< i<<" of op is: "<< op->getIn(i)->getOffset() << "\n";
+                  myfile << "addr of var is: "<< op->getIn(i)->getAddr().getOffset() <<"\n";
+                  myfile << "name of addr space is: " <<op->getIn(i)->getSpace()->getName() <<"\n";
+                  string temp;
+                    if(op->getIn(i)->getType()){
+                        metatype2string(op->getIn(i)->getType()->getMetatype(),temp);
+                        myfile << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile << "var's type is: NOT known\n";
+                    }
+                    myfile << "raw info ------------- :\n";
+                    op->getIn(i)->printRaw(myfile);
+                    myfile <<" \n-----------end raw \n";
+                    
+                }
+              }
+          
+          }
+          else{
+            myfile << "op is null \n";
+          }
+    }
+
+    if(op->getAddr().getOffset()==instruction_address_being_logged2){
+          
+          if(op && op->code()){
+              myfile2<<"Inside ActionPool::processOp \n";
+              myfile2 <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+              myfile2 << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+
+              myfile2 << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+              myfile2 << "data name is: " << data.getName() <<"\n";
+              for (int i = 0; i <op->numInput(); i ++){
+                if (op->getIn(i)){
+                  myfile2 << "var"<< i<<" of op is: "<< op->getIn(i)->getOffset() << "\n";
+                  myfile2 << "addr of var is: "<< op->getIn(i)->getAddr().getOffset() <<"\n";
+                  myfile2 << "name of addr space is: " <<op->getIn(i)->getSpace()->getName() <<"\n";
+                  string temp;
+                    if(op->getIn(i)->getType()){
+                        metatype2string(op->getIn(i)->getType()->getMetatype(),temp);
+                        myfile2 << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile2 << "var's type is: NOT known\n";
+                    }
+                    myfile2 << "raw info ------------- :\n";
+                    op->getIn(i)->printRaw(myfile2);
+                    myfile2 <<" \n-----------end raw \n";
+                    
+                }
+              }
+          
+          }
+          else{
+            myfile2 << "op is null \n";
+          }
+    }
+     myfile.close();
+      myfile2.close();
+  #endif
+
   Rule *rl;
   int4 res;
   uint4 opc;
 
+
+
   if (op->isDead()) {
+    #ifdef DEBUG_MUQI_type_recovery 
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    if(op->getAddr().getOffset()==instruction_address_being_logged
+    ){
+          myfile << "OP is dead! \n";
+    }
+    if(op->getAddr().getOffset()==instruction_address_being_logged2
+    ){
+          myfile2 << "OP is dead! \n";
+    }
+    myfile.close();
+    myfile2.close();
+    #endif
     op_state++;
     data.opDeadAndGone(op);
     rule_index = 0;
     return 0;
   }
+
+  #ifdef DEBUG_MUQI_type_recovery 
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    if(op->getAddr().getOffset()==instruction_address_being_logged
+    ){
+          myfile << "OP DOes not dead! \n";
+    }
+    if(op->getAddr().getOffset()==instruction_address_being_logged2
+    ){
+          myfile2 << "OP DOes not dead! \n";
+    }
+    myfile.close();
+    myfile2.close();
+    #endif
+
   opc = op->code();
   while(rule_index < perop[opc].size()) {
+
+    
     rl = perop[opc][rule_index++];
-    if (rl->isDisabled()) continue;
+  
+
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+
+  #ifdef DEBUG_MUQI_0x80  
+    if(op->getAddr().getOffset()==instruction_address_being_logged1||op->getAddr().getOffset()==instruction_address_being_logged2||op->getAddr().getOffset()==instruction_address_being_logged5
+    ){
+ 
+      myfile << "inside ActionPool::processOp: \n";
+      myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+      myfile << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+      myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+      myfile << "data name is: " << data.getName() <<"\n";
+      if (op->getIn(0)){
+        myfile << "var1 of op is: "<< op->getIn(0)->getOffset() << "\n";
+      }else {
+        myfile << "var1 of op is null \n ";
+      }
+      if (op->getIn(1)){
+        myfile << "var2 of op is: "<< op->getIn(1)->getOffset() << "\n";
+      }else {
+        myfile << "var2 of op is null \n ";
+      }
+      
+      //usleep(10);
+      //myfile << "op num1 is:" 
+ 
+    } 
+    #endif 
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+  #ifdef DEBUG_MUQI_0x80 
+    if(
+      op->getAddr().getOffset()==instruction_address_being_logged3||op->getAddr().getOffset()==instruction_address_being_logged4||op->getAddr().getOffset()==instruction_address_being_logged6
+    ){
+
+      myfile2 << "inside ActionPool::processOp: \n";
+     myfile2 <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+      myfile2 << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+      myfile2 << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+      myfile2 << "data name is: " << data.getName() <<"\n";
+      if (op->getIn(0)){
+        myfile2 << "var1 of op is: "<< op->getIn(0)->getOffset() << "\n";
+      }else {
+        myfile2 << "var1 of op is null \n ";
+      }
+      if (op->getIn(1)){
+        myfile2 << "var2 of op is: "<< op->getIn(1)->getOffset() << "\n";
+      }else {
+        myfile2 << "var2 of op is null \n ";
+      }
+     
+      //usleep(10);
+      //myfile << "op num1 is:" 
+
+    } 
+#endif
+    myfile.close();
+      myfile2.close();
+
+
+    try {
+    	string start_program_name_function = data.getprogram_name_function();
+    	string final_program_name_function;
+    	char buff[1000];
+    	strcpy(buff, start_program_name_function.c_str());
+    	if (!start_program_name_function.empty()){
+		char *token = strtok(buff, "/");
+    		vector<string> list_of_path;
+    		while (token != NULL)
+    		{
+        		list_of_path.push_back(token);
+        		token = strtok(NULL, "/");
+    		}
+    		final_program_name_function = list_of_path [list_of_path.size() - 3];
+    		ifstream myfile_gate;
+    
+        	myfile_gate.open ("/tmp/ghidra_gate_"+final_program_name_function);
+        	streamToVec(myfile_gate, blacklist);
+		}
+        } catch (std::system_error& e) {
+
+        }
+    if (vContains(blacklist, rl->getName())){
+    }else{
+				      
+
+	    if (rl->isDisabled()) continue;
 #ifdef OPACTION_DEBUG
-    data.debugActivate();
+	    data.debugActivate();
 #endif
-    rl->count_tests += 1;
-    res = rl->applyOp(op,data);
+	    rl->count_tests += 1;
+	    res = rl->applyOp(op,data);
 #ifdef OPACTION_DEBUG
-    data.debugModPrint(rl->getName());
+	    data.debugModPrint(rl->getName());
 #endif
-    if (res>0) {
-      rl->count_apply += 1;
-      count += res;
-      rl->issueWarning(data.getArch()); // Check if we need to issue a warning
-      if (rl->checkActionBreak())
-        return -1;
+	    if (res>0) {
+
+
+	    #ifdef DEBUG_MUQI_type_recovery
+	   
+	      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+	      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+	      #endif
+	/*
+	      if(op && op->code()){
+		      myfile<<"Inside ActionPool::processOp \n";
+		      myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+		      myfile << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+
+		      myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+		      myfile << "data name is: " << data.getName() <<"\n";
+		      for (int i = 0; i <op->numInput(); i ++){
+			if (op->getIn(i)){
+			  myfile << "var"<< i<<" of op is: "<< op->getIn(i)->getOffset() << "\n";
+			  myfile << "addr of var is: "<< op->getIn(i)->getAddr().getOffset() <<"\n";
+			  myfile << "name of addr space is: " <<op->getIn(i)->getSpace()->getName() <<"\n";
+			}
+		      }
+		  
+		  }
+		  else{
+		    myfile << "op is null \n";
+		  }
+		  myfile <<" name of rl applied is: " <<rl->getName() <<"\n";
+		*/
+	   #ifdef DEBUG_MUQI_0x80 
+		if(op->getAddr().getOffset()==instruction_address_being_logged1||op->getAddr().getOffset()==instruction_address_being_logged2||op->getAddr().getOffset()==instruction_address_being_logged5
+	    ){
+
+	      myfile <<" name of rl applied is: " <<rl->getName() <<"\n";
+
+	      }
+	      #endif
+
+	  #ifdef DEBUG_MUQI_type_recovery 
+	    if(op->getAddr().getOffset()==instruction_address_being_logged 
+	    ){
+		  if(rl){
+			myfile <<" name of rl applied is: " <<rl->getName() <<"\n";
+
+		  }
+	    }
+	    if(op->getAddr().getOffset()==instruction_address_being_logged2 
+	    ){
+		  if(rl){
+			myfile2 <<" name of rl applied is: " <<rl->getName() <<"\n";
+		  }
+	    }
+	     myfile.close();
+	      myfile2.close();
+	  #endif
+
+	    #ifdef DEBUG_MUQI_0x80  
+	      if(
+	      op->getAddr().getOffset()==instruction_address_being_logged3||op->getAddr().getOffset()==instruction_address_being_logged4||op->getAddr().getOffset()==instruction_address_being_logged6
+	    ){
+
+	      myfile2 <<" name of rl applied is: " <<rl->getName() <<"\n";
+
+	      }
+	      #endif
+	      
+
+	      rl->count_apply += 1;
+	      count += res;
+	      rl->issueWarning(data.getArch()); // Check if we need to issue a warning
+	      if (rl->checkActionBreak())
+		return -1;
 #ifdef OPACTION_DEBUG
-      if (data.debugBreak()) {
-	data.debugHandleBreak();
-	return -1;
-      }
+	      if (data.debugBreak()) {
+		data.debugHandleBreak();
+		return -1;
+	      }
 #endif
-      if (op->isDead()) break;
-      if (opc != op->code()) {	// Set of rules to apply to this op has changed
-        opc = op->code();
-        rule_index = 0;		
-      }
-    }
-    else if (opc != op->code()) {
-      data.getArch()->printMessage("ERROR: Rule " + rl->getName() + " changed op without returning result of 1!");
-      opc = op->code();
-      rule_index = 0;	
-    }
-  }
+	      if (op->isDead()) break;
+	      if (opc != op->code()) {	// Set of rules to apply to this op has changed
+		opc = op->code();
+		rule_index = 0;		
+	      }
+	    }
+	    else if (opc != op->code()) {
+	      data.getArch()->printMessage("ERROR: Rule " + rl->getName() + " changed op without returning result of 1!");
+	      opc = op->code();
+	      rule_index = 0;	
+	    }
+	  }
+	}
   op_state++;
   rule_index = 0;
 
+          #ifdef DEBUG_MUQI_type_recovery 
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    if(op->getAddr().getOffset()==instruction_address_being_logged){
+          
+          if(op && op->code()){
+              myfile<<"After rule!!! \n";
+              myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+              myfile << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+
+              myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+              myfile << "data name is: " << data.getName() <<"\n";
+              for (int i = 0; i <op->numInput(); i ++){
+                if (op->getIn(i)){
+                  myfile << "var"<< i<<" of op is: "<< op->getIn(i)->getOffset() << "\n";
+                  myfile << "addr of var is: "<< op->getIn(i)->getAddr().getOffset() <<"\n";
+                  myfile << "name of addr space is: " <<op->getIn(i)->getSpace()->getName() <<"\n";
+                  string temp;
+                    if(op->getIn(i)->getType()){
+                        metatype2string(op->getIn(i)->getType()->getMetatype(),temp);
+                        myfile << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile << "var's type is: NOT known\n";
+                    }
+                    myfile << "raw info ------------- :\n";
+                    op->getIn(i)->printRaw(myfile);
+                    myfile <<" \n-----------end raw \n";
+                    
+                }
+              }
+          
+          }
+          else{
+            myfile << "op is null \n";
+          }
+    }
+
+    if(op->getAddr().getOffset()==instruction_address_being_logged2){
+          
+          if(op && op->code()){
+              myfile2<<"After rule!!! \n";
+              myfile2 <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+              myfile2 << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+
+              myfile2 << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+              myfile2 << "data name is: " << data.getName() <<"\n";
+              for (int i = 0; i <op->numInput(); i ++){
+                if (op->getIn(i)){
+                  myfile2 << "var"<< i<<" of op is: "<< op->getIn(i)->getOffset() << "\n";
+                  myfile2 << "addr of var is: "<< op->getIn(i)->getAddr().getOffset() <<"\n";
+                  myfile2 << "name of addr space is: " <<op->getIn(i)->getSpace()->getName() <<"\n";
+                  string temp;
+                    if(op->getIn(i)->getType()){
+                        metatype2string(op->getIn(i)->getType()->getMetatype(),temp);
+                        myfile2 << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile2 << "var's type is: NOT known\n";
+                    }
+                    myfile2 << "raw info ------------- :\n";
+                    op->getIn(i)->printRaw(myfile2);
+                    myfile2 <<" \n-----------end raw \n";
+                    
+                }
+              }
+          
+          }
+          else{
+            myfile2 << "op is null \n";
+          }
+    }
+     myfile.close();
+      myfile2.close();
+  #endif
+  #ifdef DEBUG_MUQI_type_recovery 
+        myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    if(op->getAddr().getOffset()==instruction_address_being_logged
+    ){
+         
+        myfile <<" end of ActionPool::processOp \n";
+          
+    }
+    if(op->getAddr().getOffset()==instruction_address_being_logged2
+    ){
+         
+        myfile2 <<" end of ActionPool::processOp \n";
+          
+    }
+     myfile.close();
+      myfile2.close();
+  #endif
   return 0;
 }
 
 int4 ActionPool::apply(Funcdata &data)
 
 {
+    ofstream myfile;
+  ofstream myfile2;
+
+
+
+  #ifdef DEBUG_MUQI_type_recovery 
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+   
+          myfile << "HERE we are ActionPool::apply start \n";
+    
+    myfile.close();
+    myfile2.close();
+    #endif
+
   if (status != status_mid) {
+    
     op_state = data.beginOpAll();	// Initialize the derived action
     rule_index = 0;
+    #ifdef DEBUG_MUQI_type_recovery 
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+   
+          myfile << "HERE we are status != status_mid \n";
+          myfile << "op_state start address is: "<< hex << (*op_state).second <<"\n";
+    
+    myfile.close();
+    myfile2.close();
+    #endif
+
   }
-  for(;op_state!=data.endOpAll();)
+
+
+
+int i = 0;
+  for(;op_state!=data.endOpAll();){
+     #ifdef DEBUG_MUQI_type_recovery 
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+   
+          //myfile << "Inside loop of ActionPool::apply , i: "<< i<< "\n";
+    
+    myfile.close();
+    myfile2.close();
+    i++;
+    #endif
 	  if (0!=processOp((*op_state).second,data)) return -1;
+  }
+
+
+  #ifdef DEBUG_MUQI_type_recovery 
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+   
+          myfile << "HERE we are ActionPool::apply end \n";
+    
+    myfile.close();
+    myfile2.close();
+    #endif
 
   return 0;			// Indicate successful completion
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/address.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/address.cc
index b78862935..49dfd944f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/address.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/address.cc
@@ -595,6 +595,7 @@ uintb uintb_negate(uintb in,int4 size)
   return ((~in)&calc_mask(size));
 }
 
+//#define DEBUG_MUQI_0x80
 /// Take the first \b sizein bytes of the given \b in and sign-extend
 /// this to \b sizeout bytes, keeping any more significant bytes zero
 /// \param in is the given value
@@ -602,19 +603,69 @@ uintb uintb_negate(uintb in,int4 size)
 /// \param sizeout is the size to sign-extend the value to
 /// \return the sign-extended value
 uintb sign_extend(uintb in,int4 sizein,int4 sizeout)
-
-{
+//in =7f, sizein=1 sizeout =4
+{
+  #ifdef DEBUG_MUQI_0x80
+  ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  #endif
   int4 signbit;
   uintb mask;
 
   signbit = sizein*8 - 1;
+
+  #ifdef DEBUG_MUQI_0x80
+  myfile<<"signbit: " << hex<<signbit <<"\n";
+  myfile2<<"signbit: " << hex<<signbit <<"\n";
+    
+  myfile<<"sizein1: "<<hex<<sizein<<"\n";
+  myfile<<"sizeout1: "<<hex<<sizeout<<"\n";
+
+  myfile2<<"sizein1: "<<hex<<sizein<<"\n";
+  myfile2<<"sizeout1: "<<hex<<sizeout<<"\n";
+  #endif
+
   in &= calc_mask(sizein);
+
+#ifdef DEBUG_MUQI_0x80
+  myfile<<"in: " << hex<<in <<"\n";
+  myfile2<<"in: " << hex<<in <<"\n";
+
+  myfile<<"sizein2: "<<hex<<sizein<<"\n";
+  myfile<<"sizeout2: "<<hex<<sizeout<<"\n";
+
+  myfile2<<"sizein2: "<<hex<<sizein<<"\n";
+  myfile2<<"sizeout2: "<<hex<<sizeout<<"\n";
+#endif
   if (sizein >= sizeout) return in;
+#ifdef DEBUG_MUQI_0x80
+  myfile<<"in>>signbit" << (in>>signbit)<<"\n";
+  myfile2<<"in>>signbit" << (in>>signbit )<<"\n";
+#endif
   if ((in>>signbit) != 0) {
     mask = calc_mask(sizeout);
+
+#ifdef DEBUG_MUQI_0x80
+    myfile<<"mask: " << hex<<mask <<"\n";
+    myfile2<<"mask: " << hex<<mask <<"\n";
+#endif
     uintb tmp = mask << signbit; // Split shift into two pieces
+#ifdef DEBUG_MUQI_0x80
+    myfile<<"tmp1: " << hex<<tmp <<"\n";
+    myfile2<<"tmp1: " << hex<<tmp <<"\n";
+#endif
     tmp = (tmp<<1) & mask;	// In case, everything is shifted out
+#ifdef DEBUG_MUQI_0x80    
+    myfile<<"tmp2: " << hex<<tmp <<"\n";
+    myfile2<<"tmp2: " << hex<<tmp <<"\n";
+#endif
     in |= tmp;
+#ifdef DEBUG_MUQI_0x80    
+    myfile<<"in: " << hex<<in <<"\n";
+    myfile2<<"in: " << hex<<in <<"\n";
+    #endif
   }
   return in;
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc
index 86bbf61bc..560d261bd 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/block.cc
@@ -105,7 +105,7 @@ void FlowBlock::halfDeleteOutEdge(int4 slot)
 {
   while(slot < outofthis.size()-1) {
     BlockEdge &edge( outofthis[slot] );
-    edge = outofthis[slot+1];	// Slide the edge
+    edge = outofthis[slot+1];	// Slide the edge  ==> outofthis[slot] = outofthis[slot+1]
     // Correct the index coming the other way
     BlockEdge &edger( edge.point->intothis[edge.reverse_index] );
     edger.reverse_index -= 1;
@@ -568,7 +568,7 @@ int4 FlowBlock::getOutIndex(const FlowBlock *bl) const
     if (outofthis[blocknum].point==bl) return blocknum;
   return -1;
 }
-
+#define DEBUG_MUQI_check_Block
 /// Only print a header for \b this single block
 /// \param s is the output stream
 void FlowBlock::printHeader(ostream &s) const
@@ -576,6 +576,20 @@ void FlowBlock::printHeader(ostream &s) const
 {
   s << dec << index;
   if (!getStart().isInvalid() && !getStop().isInvalid()) {
+  ofstream myfile;
+  ofstream myfile2;
+
+
+
+  #ifdef DEBUG_MUQI_check_Block
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+   
+          myfile << "HERE we are FlowBlock::printHeader \n";
+    
+    myfile.close();
+    myfile2.close();
+    #endif
     s << ' ' << getStart() << '-' << getStop();
   }
 }
@@ -2396,6 +2410,27 @@ void FlowBlock::saveXml(ostream &s) const
   saveXmlBody(s);
   saveXmlEdges(s);
   s << "</block>\n";
+  
+  
+  
+  //added by myself
+  if (!getStart().isInvalid() && !getStop().isInvalid()) {
+  ofstream myfile;
+  ofstream myfile2;
+
+
+
+  #ifdef DEBUG_MUQI_check_Block
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+   
+          myfile << "HERE we are FlowBlock::saveXml \n";
+    
+    myfile.close();
+    myfile2.close();
+    #endif
+    //s << ' ' << getStart() << '-' << getStop();
+  }
 }
 
 /// Recover \b this and all it sub-components from an XML \<block> tag.
@@ -2869,9 +2904,26 @@ void BlockIf::printHeader(ostream &s) const
   FlowBlock::printHeader(s);
 }
 
+
+#define DEBUG_MUQI_0x80
 bool BlockIf::preferComplement(Funcdata &data)
 
 {
+
+#ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In BlockIf::preferComplement \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In BlockIf::preferComplement \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
   if (getSize()!=3)		// If we are an if/else
     return false;
 
@@ -2913,9 +2965,25 @@ FlowBlock *BlockIf::nextFlowAfter(const FlowBlock *bl) const
   return getParent()->nextFlowAfter(this);
 }
 
+#define DEBUG_MUQI_0x80
 void BlockIf::saveXmlBody(ostream &s) const
 
 {
+
+  #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In BlockIf::saveXmlBody \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In BlockIf::saveXmlBody \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
   BlockGraph::saveXmlBody(s);
   if (getSize() == 1) {		// If this is a if GOTO block
     const FlowBlock *leaf = gototarget->getFrontLeaf();
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc
index 80265a458..9d0f6b598 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/blockaction.cc
@@ -16,6 +16,8 @@
 #include "blockaction.hh"
 #include "funcdata.hh"
 
+
+//#define DEBUG_MUQI_float
 /// Retrieve the current edge (as a \e top FlowBlock and the index of the outgoing edge).
 /// If the end-points have been collapsed together, this returns NULL.
 /// The top and bottom nodes of the edge are updated to FlowBlocks in the current collapsed graph.
@@ -2003,6 +2005,18 @@ void ConditionalJoin::cutDownMultiequals(BlockBasic *exit,int4 in1,int4 in2)
 void ConditionalJoin::setupMultiequals(void)
 
 {
+#ifdef DEBUG_MUQI_0x80
+    ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "1111ConditionalJoin::setupMultiequals \n ";
+    myfile.close();
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "1111ConditionalJoin::setupMultiequals \n ";
+    myfile2.close();
+#endif
   map<MergePair,Varnode *>::iterator iter;
 
   for(iter=mergeneed.begin();iter!=mergeneed.end();++iter) {
@@ -2102,9 +2116,24 @@ int4 ActionStructureTransform::apply(Funcdata &data)
   return 0;
 }
 
+#define DEBUG_MUQI_0x80
 int4 ActionNormalizeBranches::apply(Funcdata &data)
 
 {
+#ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In ActionNormalizeBranches \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In ActionNormalizeBranches \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
   const BlockGraph &graph(data.getBasicBlocks());
   vector<PcodeOp *> fliplist;
 
@@ -2125,9 +2154,26 @@ int4 ActionNormalizeBranches::apply(Funcdata &data)
   return 0;
 }
 
+#define DEBUG_MUQI_0x80
 int4 ActionPreferComplement::apply(Funcdata &data)
 
 {
+
+#ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In ActionPreferComplement::apply \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In ActionPreferComplement::apply \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   BlockGraph &graph(data.getStructure());
   
   if (graph.getSize() == 0) return 0;
@@ -2252,6 +2298,20 @@ bool ActionReturnSplit::isSplittable(BlockBasic *b)
 int4 ActionReturnSplit::apply(Funcdata &data)
 
 {
+
+#ifdef DEBUG_MUQI_float
+    ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile << "Inside ActionReturnSplit::apply \n ";
+    myfile2 << "Inside ActionReturnSplit::apply \n ";
+
+    myfile.close();
+    myfile2.close();  
+#endif
   PcodeOp *op;
   BlockBasic *parent;
   FlowBlock *bl;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.cc
index 0c7647c6e..85f76af70 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/condexe.cc
@@ -501,6 +501,19 @@ bool ConditionalExecution::testOpRead(Varnode *vn,PcodeOp *op)
 void ConditionalExecution::predefineDirectMulti(PcodeOp *op)
 
 {
+#ifdef DEBUG_MUQI_0x80
+  ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "1111ConditionalExecution::predefineDirectMulti \n ";
+    myfile.close();
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "1111ConditionalExecution::predefineDirectMulti\n ";
+    myfile2.close();
+#endif
+
   PcodeOp *newop = fd->newOp(posta_block->sizeIn()+1,posta_block->getStart());
   Varnode *outvn = op->getOut();
   Varnode *newoutvn;
@@ -557,6 +570,20 @@ void ConditionalExecution::adjustDirectMulti(void)
 Varnode *ConditionalExecution::getNewMulti(PcodeOp *op,BlockBasic *bl)
 
 {
+#ifdef DEBUG_MUQI_0x80
+  ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "1111ConditionalExecution::getNewMulti \n ";
+    myfile.close();
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "1111ConditionalExecution::getNewMulti \n ";
+    myfile2.close();
+#endif
+
+
   PcodeOp *newop = fd->newOp(bl->sizeIn(),bl->getStart());
   Varnode *outvn = op->getOut();
   Varnode *newoutvn;
@@ -1078,6 +1105,21 @@ int4 RuleOrPredicate::applyOp(PcodeOp *op,Funcdata &data)
     slot0SetsBranch0 = branch0.zeroSlot == 1;
   }
   PcodeOp *newMulti = data.newOp(2,finalBlock->getStart());
+
+#ifdef DEBUG_MUQI_0x80
+  ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "1111RuleOrPredicate::applyOp \n ";
+    myfile.close();
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "1111RuleOrPredicate::applyOp \n ";
+    myfile2.close();
+#endif
+
+
   data.opSetOpcode(newMulti,CPUI_MULTIEQUAL);
   if (slot0SetsBranch0) {
     data.opSetInput(newMulti,branch0.otherVn,0);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc
index 4d7277572..89514b360 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc
@@ -18,6 +18,8 @@
 #include "double.hh"
 #include "subflow.hh"
 
+//#define DEBUG_MUQI_float
+
 /// \brief A stack equation
 struct StackEqn {
   int4 var1;			///< Variable with 1 coefficient
@@ -1092,6 +1094,12 @@ SymbolEntry *ActionConstantPtr::isPointer(AddrSpace *spc,Varnode *vn,PcodeOp *op
   if (entry != (SymbolEntry *)0) {
     Datatype *ptrType = entry->getSymbol()->getType();
     if (ptrType->getMetatype() == TYPE_ARRAY) {
+
+      ofstream myfile2;
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+//  myfile2 << "test TypeArray1\n";
+  myfile2.close();
+
       Datatype *ct = ((TypeArray *)ptrType)->getBase();
       // In the special case of strings (character arrays) we allow the constant pointer to
       // refer to the middle of the string
@@ -1697,6 +1705,20 @@ int4 ActionActiveParam::apply(Funcdata &data)
 int4 ActionActiveReturn::apply(Funcdata &data)
 
 {
+
+#ifdef DEBUG_MUQI_float
+    ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile << "Inside ActionActiveReturn::apply \n ";
+    myfile2 << "Inside ActionActiveReturn::apply \n ";
+
+    myfile.close();
+    myfile2.close();  
+#endif
   int4 i;
   FuncCallSpecs *fc;
 
@@ -1832,8 +1854,28 @@ void ActionReturnRecovery::buildReturnOutput(ParamActive *active,PcodeOp *retop,
 int4 ActionReturnRecovery::apply(Funcdata &data)
 
 {
+
+#ifdef DEBUG_MUQI_float
+    ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile << "Inside ActionReturnRecovery::apply \n ";
+    myfile2 << "Inside ActionReturnRecovery::apply \n ";
+
+    myfile.close();
+    myfile2.close();  
+#endif
+
   ParamActive *active = data.getActiveOutput();
   if (active != (ParamActive *)0) {
+  #ifdef DEBUG_MUQI_float
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile <<"if first condition \n";      
+    myfile.close();
+  #endif
     PcodeOp *op;
     Varnode *vn;
     list<PcodeOp *>::const_iterator iter,iterend;
@@ -1844,6 +1886,26 @@ int4 ActionReturnRecovery::apply(Funcdata &data)
     AncestorRealistic ancestorReal;
     for(iter=data.beginOp(CPUI_RETURN);iter!=iterend;++iter) {
       op = *iter;
+      #ifdef DEBUG_MUQI_float
+          myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+
+            myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+            myfile << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+            myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+            myfile << "data name is: " << data.getName() <<"\n";
+            if (op->getIn(0)){
+              myfile << "var1 of op is: "<< op->getIn(0)->getOffset() << "\n";
+            }else {
+              myfile << "var1 of op is null \n ";
+            }
+            if (op->getIn(1)){
+              myfile << "var2 of op is: "<< op->getIn(1)->getOffset() << "\n";
+            }else {
+              myfile << "var2 of op is null \n ";
+            }
+
+          myfile.close(); 
+      #endif
       if (op->isDead()) continue;
       if (op->getHaltType() != 0) continue; // Don't evaluate special halts
       for(i=0;i<active->getNumTrials();++i) {
@@ -1875,6 +1937,12 @@ int4 ActionReturnRecovery::apply(Funcdata &data)
       count += 1;
     }
   }
+
+  #ifdef DEBUG_MUQI_float
+  myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+  myfile <<"at end of ActionReturnRecovery \n";      
+  myfile.close();
+  #endif
   return 0;
 }
 
@@ -4880,11 +4948,55 @@ void ActionDatabase::buildDefaultGroups(void)
   isDefaultGroups = true;
 }
 
+//muqi check here!!!!
+bool remove_RuleIntLessEqual;
+
+//rule will be removed based on last times symbolic execution
+void RemoveRule(){
+    string line;
+    ifstream resultfile ("/home/muqi/decompile_tool/test/test_ghidra/test_muqi/diff/result.txt"); 
+    if (resultfile.is_open()){
+      getline(resultfile,line);
+
+      //if log file exist, and it shows unsat, rule will be removed
+      if (line.find("unsat") != std::string::npos) {
+          remove_RuleIntLessEqual = true;
+
+          //just log the remove
+          ofstream myfile;
+          myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+          myfile <<"remove_RuleIntLessEqual is set true \n";      
+          myfile.close();
+
+      }
+      //if log file exist, and it shows sat, no rule need to be removed
+      
+
+    }
+    else {
+      //if log file does not exist, no rule need to be removed
+    }
+    resultfile.close();
+
+
+  
+
+}
+
+void InitRule(){
+  remove_RuleIntLessEqual = false;
+}
+
 /// Construct the \b universal Action that contains all possible components
 /// \param conf is the Architecture that will use the Action
 void ActionDatabase::universalAction(Architecture *conf)
 
 {
+//muqi check here!!!!
+  InitRule();
+  RemoveRule();
+
+
   vector<Rule *>::iterator iter;
   ActionGroup *act;
   ActionGroup *actmainloop;
@@ -4931,16 +5043,20 @@ void ActionDatabase::universalAction(Architecture *conf)
       actstackstall = new ActionGroup(Action::rule_repeatapply,"stackstall");
       {
 	actprop = new ActionPool(Action::rule_repeatapply,"oppool1");
+  
 	actprop->addRule( new RuleEarlyRemoval("deadcode"));
-	actprop->addRule( new RuleTermOrder("analysis"));
+	
+  actprop->addRule( new RuleTermOrder("analysis"));
 	actprop->addRule( new RuleSelectCse("analysis"));
 	actprop->addRule( new RuleCollectTerms("analysis"));
 	actprop->addRule( new RulePullsubMulti("analysis"));
 	actprop->addRule( new RulePullsubIndirect("analysis"));
 	actprop->addRule( new RulePushMulti("nodejoin"));
 	actprop->addRule( new RuleSborrow("analysis") );
+if (!remove_RuleIntLessEqual)
 	actprop->addRule( new RuleIntLessEqual("analysis") );
-	actprop->addRule( new RuleTrivialArith("analysis") );
+	
+  actprop->addRule( new RuleTrivialArith("analysis") );
 	actprop->addRule( new RuleTrivialBool("analysis") );
 	actprop->addRule( new RuleTrivialShift("analysis") );
 	actprop->addRule( new RuleSignShift("analysis") );
@@ -5029,6 +5145,7 @@ void ActionDatabase::universalAction(Architecture *conf)
 	actprop->addRule( new RulePiece2Sext("analysis") );
 	actprop->addRule( new RulePopcountBoolXor("analysis") );
 	actprop->addRule( new RuleXorSwap("analysis") );
+  
 	actprop->addRule( new RuleSubvarAnd("subvar") );
 	actprop->addRule( new RuleSubvarSubpiece("subvar") );
 	actprop->addRule( new RuleSplitFlow("subvar") );
@@ -5053,6 +5170,7 @@ void ActionDatabase::universalAction(Architecture *conf)
 	actprop->addRule( new RuleDoubleIn("doubleprecis") );
 	for(iter=conf->extra_pool_rules.begin();iter!=conf->extra_pool_rules.end();++iter)
 	  actprop->addRule( *iter ); // Add CPU specific rules
+  
 	conf->extra_pool_rules.clear(); // Rules are now absorbed into universal
       }
       actstackstall->addAction( actprop );
@@ -5074,6 +5192,7 @@ void ActionDatabase::universalAction(Architecture *conf)
 	//	actprop2->addRule( new RuleIndirectConcat("analysis") );
 	actprop2->addRule( new RuleLoadVarnode("stackvars") );
 	actprop2->addRule( new RuleStoreVarnode("stackvars") );
+  
       }
       actmainloop->addAction( actprop2 );
       actmainloop->addAction( new ActionDeterminedBranch("unreachable") );
@@ -5104,6 +5223,7 @@ void ActionDatabase::universalAction(Architecture *conf)
     actcleanup->addRule( new Rule2Comp2Sub("cleanup") );
     actcleanup->addRule( new RuleSubRight("cleanup") );
     actcleanup->addRule( new RulePtrsubCharConstant("cleanup") );
+    
   }
   act->addAction( actcleanup );
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/double.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/double.cc
index 3034d95b9..1ba2755f5 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/double.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/double.cc
@@ -1089,6 +1089,21 @@ void SplitVarnode::createPhiOp(Funcdata &data,SplitVarnode &out,vector<SplitVarn
     inlist[i].findCreateWhole(data);
 
   PcodeOp *newop = data.newOp(numin,existop->getAddr());
+
+#ifdef DEBUG_MUQI_0x80
+  ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "1111SplitVarnode::createPhiOp \n ";
+    myfile.close();
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "1111SplitVarnode::createPhiOp \n ";
+    myfile2.close();
+#endif
+
+
   data.opSetOpcode(newop,CPUI_MULTIEQUAL);
   data.opSetOutput(newop,out.getWhole());
   for(int4 i=0;i<numin;++i)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/flow.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/flow.cc
index 9421da8c9..0315a399d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/flow.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/flow.cc
@@ -949,6 +949,7 @@ void FlowInfo::collectEdges(void)
   }
 }
 
+#define DEBUG_MUQI_Block
 /// PcodeOp objects are moved out of the PcodeOpBank \e dead list into their
 /// assigned PcodeBlockBasic.  Initial address ranges of instructions are recorded in the block.
 /// PcodeBlockBasic objects are created based on p-code ops that have been
@@ -986,6 +987,20 @@ void FlowInfo::splitBasic(void)
     }
     data.opInsert(op,cur,cur->endOp());
   }
+  #ifdef DEBUG_MUQI_Block
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In FlowInfo::splitBasic \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In FlowInfo::splitBasic \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
   data.setBasicBlockRange(cur, start, stop);
 }
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.cc
index 670d94c9f..6129e4aaf 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.cc
@@ -162,11 +162,32 @@ void Funcdata::stopProcessing(void)
   glb->stats->process(*this);
 #endif
 }
-
+#define DEBUG_MUQI_type_recovery
 bool Funcdata::startTypeRecovery(void)
 
 {
+
+  ofstream myfile;
+  ofstream myfile2;
+    #ifdef DEBUG_MUQI_type_recovery 
+          myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+          myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+          
+          myfile << "Funcdata::startTypeRecovery \n";
+          
+          myfile.close();
+          myfile2.close();
+    #endif
   if ((flags & typerecovery_on)!=0) return false; // Already started
+  #ifdef DEBUG_MUQI_type_recovery 
+          myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+          myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+          
+          myfile << "first start \n";
+          
+          myfile.close();
+          myfile2.close();
+    #endif
   flags |= typerecovery_on;
   return true;
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh
index 39d22630c..30a0f4f5e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata.hh
@@ -24,7 +24,7 @@
 #include "heritage.hh"
 #include "merge.hh"
 #include "dynamic.hh"
-
+#define DEBUG_MUQI_type_recovery_dead
 class FlowInfo;
 
 /// \brief Container for data structures associated with a single function
@@ -72,6 +72,7 @@ class Funcdata {
   Architecture *glb;		///< Global configuration data
   FunctionSymbol *functionSymbol;	///< The symbol representing \b this function
   string name;			///< Name of function
+  string program_name_function;
   Address baseaddr;		///< Starting code address of binary data
   FuncProto funcp;		///< Prototype of this function
   ScopeLocal *localmap;		///< Local variables (symbols in the function scope)
@@ -131,6 +132,9 @@ public:
   Funcdata(const string &nm,Scope *conf,const Address &addr,FunctionSymbol *sym,int4 sz=0);	///< Constructor
   ~Funcdata(void);							///< Destructor
   const string &getName(void) const { return name; }			///< Get the function's local symbol name
+  const string &getprogram_name_function(void) const {return program_name_function;}
+  void setprogram_name_function(string name) {program_name_function = name;}
+
   const Address &getAddress(void) const { return baseaddr; }		///< Get the entry point address
   int4 getSize(void) const { return size; }				///< Get the function body size in bytes
   Architecture *getArch(void) const { return glb; }			///< Get the program/architecture owning \b this function
@@ -393,7 +397,22 @@ public:
   void setHighLevel(void);					///< Turn on HighVariable objects for all Varnodes
   void clearDeadVarnodes(void);					///< Delete any dead Varnodes
   void calcNZMask(void);					///< Calculate \e non-zero masks for all Varnodes
-  void clearDeadOps(void) { obank.destroyDead(); }		///< Delete any dead PcodeOps
+  void clearDeadOps(void) { 
+    ofstream myfile;
+  ofstream myfile2;
+
+
+
+  #ifdef DEBUG_MUQI_type_recovery_dead
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+   
+          myfile << "HERE we are clearDeadOps \n";
+    
+    myfile.close();
+    myfile2.close();
+    #endif
+    obank.destroyDead(); }		///< Delete any dead PcodeOps
   void clearSymbolLinks(HighVariable *high);			///< Clear Symbols attached to Varnodes in the given HighVariable
   void remapVarnode(Varnode *vn,Symbol *sym,const Address &usepoint);
   void remapDynamicVarnode(Varnode *vn,Symbol *sym,const Address &usepoint,uint8 hash);
@@ -437,7 +456,26 @@ public:
   void opUnlink(PcodeOp *op);					///< Unset inputs/output and remove given PcodeOP from its basic block
   void opDestroy(PcodeOp *op);					///< Remove given PcodeOp and destroy its Varnode operands
   void opDestroyRaw(PcodeOp *op);				///< Remove the given \e raw PcodeOp
-  void opDeadAndGone(PcodeOp *op) { obank.destroy(op); }	///< Free resources for the given \e dead PcodeOp
+  void opDeadAndGone(PcodeOp *op) {   
+    ofstream myfile;
+  ofstream myfile2;
+
+
+
+  #ifdef DEBUG_MUQI_type_recovery_dead
+   
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      int instruction_address_being_logged = 4198786;
+      if(op->getAddr().getOffset()==instruction_address_being_logged){
+        myfile << "HERE we are opDeadAndGone \n";
+      }
+
+    
+    myfile.close();
+    myfile2.close();
+    #endif
+    obank.destroy(op); }	///< Free resources for the given \e dead PcodeOp
   void opSetAllInput(PcodeOp *op,const vector<Varnode *> &vvec);	///< Set all input Varnodes for the given PcodeOp simultaneously
   void opRemoveInput(PcodeOp *op,int4 slot);			///< Remove a specific input slot for the given PcodeOp
   void opInsertInput(PcodeOp *op,Varnode *vn,int4 slot);	///< Insert a new Varnode into the operand list for the given PcodeOp
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_block.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_block.cc
index 61c406b48..7fc3e13a1 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_block.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_block.cc
@@ -145,6 +145,23 @@ void Funcdata::pushMultiequals(BlockBasic *bb)
       // all inputs be origvn
     }
     replaceop = newOp(branches.size(),outblock->getStart());
+
+
+#ifdef DEBUG_MUQI_0x80
+    ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "1111Funcdata::pushMultiequals \n ";
+    myfile.close();
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "1111Funcdata::pushMultiequals \n ";
+    myfile2.close();
+#endif
+
+
+
     opSetOpcode(replaceop,CPUI_MULTIEQUAL);
     opSetOutput(replaceop,replacevn);
     opSetAllInput(replaceop,branches);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_op.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_op.cc
index e4a4c8514..24cba21b6 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_op.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/funcdata_op.cc
@@ -201,6 +201,24 @@ void Funcdata::opUnlink(PcodeOp *op)
 void Funcdata::opDestroy(PcodeOp *op)
 
 {
+
+  ofstream myfile;
+  ofstream myfile2;
+
+
+
+  #ifdef DEBUG_MUQI_type_recovery 
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+   
+    int instruction_address_being_logged = 4198786;
+      if(op->getAddr().getOffset()==instruction_address_being_logged){
+          myfile << "HERE we are Funcdata::opDestroy \n";
+      }
+    myfile.close();
+    myfile2.close();
+    #endif
+
   #ifdef OPACTION_DEBUG
   if (opactdbg_active)
     debugModCheck(op);
@@ -226,6 +244,23 @@ void Funcdata::opDestroy(PcodeOp *op)
 void Funcdata::opDestroyRaw(PcodeOp *op)
 
 {
+
+ ofstream myfile;
+  ofstream myfile2;
+
+
+
+  #ifdef DEBUG_MUQI_type_recovery 
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      int instruction_address_being_logged = 4198786;
+      if(op->getAddr().getOffset()==instruction_address_being_logged){
+          myfile << "HERE we are Funcdata::opDestroyRaw \n";
+      }
+    myfile.close();
+    myfile2.close();
+    #endif
+
   for(int4 i=0;i<op->numInput();++i)
     destroyVarnode(op->getIn(i));
   if (op->getOut() != (Varnode *)0)
@@ -967,7 +1002,7 @@ void Funcdata::overrideFlow(const Address &addr,uint4 type)
       opSetOpcode(op,CPUI_RETURN);
   }
 }
-
+//#define DEBUG_MUQI_0x80
 /// Do in-place replacement of
 ///   - `c <= x`   with  `c-1 < x`   OR
 ///   - `x <= c`   with  `x < c+1`
@@ -992,14 +1027,54 @@ bool Funcdata::replaceLessequal(PcodeOp *op)
   else
     return false;
 
+#ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "Funcdata::replaceLessequal \n ";
+    myfile << "val before is: "<<hex<<vn->getOffset() <<"\n";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "Funcdata::replaceLessequal \n ";
+    myfile2 << "val before is: "<<hex<<vn->getOffset() <<"\n";
+
+    myfile.close();
+    myfile2.close();
+#endif
   val = vn->getOffset();	// Treat this as signed value
   sign_extend(val,8*vn->getSize()-1);
   if (op->code() == CPUI_INT_SLESSEQUAL) {
+#ifdef DEBUG_MUQI_0x80
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "op->code() == CPUI_INT_SLESSEQUAL \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "op->code() == CPUI_INT_SLESSEQUAL \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
     if ((val<0)&&(val+diff>0)) return false; // Check for sign overflow
     if ((val>0)&&(val+diff<0)) return false;
     opSetOpcode(op,CPUI_INT_SLESS);
   }
   else {			// Check for unsigned overflow
+#ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "op->code() != CPUI_INT_SLESSEQUAL \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "op->code() != CPUI_INT_SLESSEQUAL \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
     if ((diff==-1)&&(val==0)) return false;
     if ((diff==1)&&(val==-1)) return false;
     opSetOpcode(op,CPUI_INT_LESS);
@@ -1008,6 +1083,23 @@ bool Funcdata::replaceLessequal(PcodeOp *op)
   Varnode *newvn = newConstant(vn->getSize(),res);
   newvn->copySymbol(vn);	// Preserve data-type (and any Symbol info)
   opSetInput(op,newvn,i);
+
+ 
+    
+
+
+#ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "val later is: " <<hex<<res<<"\n";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "val later is: " <<hex<<res<<"\n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   return true;
 }
 
@@ -1161,6 +1253,7 @@ int4 opFlipInPlaceTest(PcodeOp *op,vector<PcodeOp *> &fliplist)
   return 2;
 }
 
+//#define DEBUG_MUQI_0x80
 /// \brief Perform op-code flips (in-place) to change a boolean value
 ///
 /// The precomputed list of PcodeOps have their op-codes modified to
@@ -1170,6 +1263,22 @@ int4 opFlipInPlaceTest(PcodeOp *op,vector<PcodeOp *> &fliplist)
 void opFlipInPlaceExecute(Funcdata &data,vector<PcodeOp *> &fliplist)
 
 {
+  #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In opFlipInPlaceExecute \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In opFlipInPlaceExecute \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+
   Varnode *vn;
   for(int4 i=0;i<fliplist.size();++i) {
     PcodeOp *op = fliplist[i];
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc
index b72a8093d..30f1ab368 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc
@@ -838,7 +838,7 @@ void ArchitectureGhidra::printMessage(const string &message) const
 /// \param i is the input stream from the Ghidra client
 /// \param o is the output stream to the Ghidra client
 ArchitectureGhidra::ArchitectureGhidra(const string &pspec,const string &cspec,const string &tspec,
-				       const string &corespec,istream &i,ostream &o)
+				       const string &corespec,const string &program_name_function,istream &i,ostream &o)
   : Architecture(), sin(i), sout(o)
 
 {
@@ -848,6 +848,8 @@ ArchitectureGhidra::ArchitectureGhidra(const string &pspec,const string &cspec,c
   cspecxml = cspec;
   tspecxml = tspec;
   corespecxml = corespec;
+  program_name_functionxml = program_name_function;
+
   sendsyntaxtree = true;	// Default to sending everything
   sendCcode = true;
   sendParamMeasures = false;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.hh
index 095328866..ce890ce3a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.hh
@@ -65,6 +65,8 @@ class ArchitectureGhidra : public Architecture {
   string cspecxml;		///< XML cspec passed from Ghidra
   string tspecxml;              ///< Stripped down .sla file passed from Ghidra
   string corespecxml;		///< A specification of the core data-types
+  string program_name_functionxml; //added by muqi
+
   bool sendsyntaxtree;		///< True if the syntax tree should be sent with function output
   bool sendCcode;		///< True if C code should be sent with function output
   bool sendParamMeasures;       ///< True if measurements for argument and return parameters should be sent
@@ -82,7 +84,9 @@ class ArchitectureGhidra : public Architecture {
   virtual void postSpecFile(void);
   virtual void resolveArchitecture(void);
 public:
-  ArchitectureGhidra(const string &pspec,const string &cspec,const string &tspec,const string &corespec,
+  const string &getprogram_name_functionxml(void) const {return program_name_functionxml;}
+
+  ArchitectureGhidra(const string &pspec,const string &cspec,const string &tspec,const string &corespec,const string &program_name_function,
 		     istream &i,ostream &o);
   const string &getWarnings(void) const { return warnings; }	///< Get warnings produced by the last decompilation
   void clearWarnings(void) { warnings.clear(); }		///< Clear warnings
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
index 46efe6eb0..05bfb6a12 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
@@ -17,6 +17,7 @@
 #include "flow.hh"
 #include "blockaction.hh"
 
+//#define DEBUG_MUQI_0x80
 #ifdef __REMOTE_SOCKET__
 
 #include "ifacedecomp.hh"
@@ -114,6 +115,21 @@ void GhidraCommand::sendResult(void)
 int4 GhidraCommand::doit(void)
 
 {
+  #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In GhidraCommand::doit \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In GhidraCommand::doit \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   status = 0;
   sout.write("\000\000\001\006",4); // Command response header
   try {
@@ -155,10 +171,12 @@ void RegisterProgram::loadParameters(void)
   cspec.clear();
   tspec.clear();
   corespec.clear();
+  program_name_function.clear();
   ArchitectureGhidra::readStringStream(sin,pspec);
   ArchitectureGhidra::readStringStream(sin,cspec);
   ArchitectureGhidra::readStringStream(sin,tspec);
   ArchitectureGhidra::readStringStream(sin,corespec);
+  ArchitectureGhidra::readStringStream(sin,program_name_function);
 }
 
 
@@ -173,11 +191,12 @@ void RegisterProgram::rawAction(void)
       open = i;			// Found open slot
     }
   }
-  ghidra = new ArchitectureGhidra(pspec,cspec,tspec,corespec,sin,sout);
+  ghidra = new ArchitectureGhidra(pspec,cspec,tspec,corespec,program_name_function,sin,sout);
   pspec.clear();
   cspec.clear();
   tspec.clear();
   corespec.clear();
+  program_name_function.clear();
 
   DocumentStorage store;	// temp storage of initialization xml docs
   ghidra->init(store);
@@ -285,7 +304,23 @@ void DecompileAt::loadParameters(void)
 void DecompileAt::rawAction(void) 
 
 {
+  #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In DecompileAt::rawAction \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In DecompileAt::rawAction \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+  
   Funcdata *fd = ghidra->symboltab->getGlobalScope()->queryFunction(addr);
+  fd->setprogram_name_function(ghidra->getprogram_name_functionxml());
   if (fd == (Funcdata *)0) {
     ostringstream s;
     s << "Bad decompile address: " << addr.getShortcut();
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh
index 9cb928c91..f0a677965 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.hh
@@ -104,6 +104,7 @@ class RegisterProgram : public GhidraCommand {
   string cspec;				///< Compiler specification to configure with
   string tspec;				///< Configuration (address-spaces) for the Translate object
   string corespec;			///< A description of core data-types for the TypeFactory object
+  string program_name_function; //added by muqi
   virtual void loadParameters(void);
   virtual void sendResult(void);
 public:
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc
index 7f8bb2b1e..9c3057b65 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/heritage.cc
@@ -2315,6 +2315,13 @@ void Heritage::placeMultiequals(void)
       multiop = fd->newOp(bl->sizeIn(),bl->getStart());
       Varnode *vnout = fd->newVarnodeOut(size,addr,multiop);
       vnout->setActiveHeritage();
+
+
+      
+
+
+
+
       fd->opSetOpcode(multiop,CPUI_MULTIEQUAL); // Create each MULTIEQUAL
       for(int4 j=0;j<bl->sizeIn();++j) {
 	vnin = fd->newVarnode(size,addr);
@@ -2323,6 +2330,40 @@ void Heritage::placeMultiequals(void)
       fd->opInsertBegin(multiop,bl);	// Insert at beginning of block
     }
   }
+  
+#ifdef DEBUG_MUQI_0x80
+     int instruction_address_being_logged1 = 4198820; //004011a4->4198820 004011a9->4198825
+    int instruction_address_being_logged2 = 4198825; 
+    int instruction_address_being_logged3 = 4198840; //004011b8->4198840 004011bd->4198845
+    int instruction_address_being_logged4 = 4198845; 
+
+    int instruction_address_being_logged5 = 4198816; //004011a0->4198816 004011b4->4198836
+    int instruction_address_being_logged6 = 4198836; 
+
+  ofstream myfile;
+    ofstream myfile2;
+  
+   if(multiop->getAddr().getOffset()==instruction_address_being_logged1||multiop->getAddr().getOffset()==instruction_address_being_logged2||multiop->getAddr().getOffset()==instruction_address_being_logged5
+    ){
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "1111Heritage::placeMultiequals \n ";
+    myfile <<"p name is : " << multiop->getOpName() << "\n op name is : "<< get_opname(multiop->code())<<" \n address is "<< std::hex << multiop->getAddr().getOffset() <<"\n";
+    myfile << "seqnum is : "<< multiop->getSeqNum().getTime() <<"\n";
+    myfile.close();
+    }
+
+    if(
+      multiop->getAddr().getOffset()==instruction_address_being_logged3||multiop->getAddr().getOffset()==instruction_address_being_logged4||multiop->getAddr().getOffset()==instruction_address_being_logged6
+    ){
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "1111Heritage::placeMultiequals \n ";
+    myfile2 <<"p name is : " << multiop->getOpName() << "\n op name is : "<< get_opname(multiop->code())<<" \n address is "<< std::hex << multiop->getAddr().getOffset() <<"\n";
+    myfile2 << "seqnum is : "<< multiop->getSeqNum().getTime() <<"\n";
+    myfile2.close();
+    }
+ #endif
+
+
   merge.clear();
 }
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc
index 883e07ba3..b7d6e1f99 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ifacedecomp.cc
@@ -20,6 +20,8 @@ extern "C" {
 #include "pcodeparse.hh"
 #include "blockaction.hh"
 
+#define DEBUG_MUQI_0x80
+
 // Constructing this registers the capability
 IfaceDecompCapability IfaceDecompCapability::ifaceDecompCapability;
 
@@ -790,6 +792,20 @@ void IfcDecompile::execute(istream &s)
 void IfcPrintCFlat::execute(istream &s)
 
 {
+    #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In IfcPrintCFlat::execute \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In IfcPrintCFlat::execute \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
   if (dcp->fd == (Funcdata *)0)
     throw IfaceExecutionError("No function selected");
 
@@ -830,6 +846,20 @@ void IfcPrintCTypes::execute(istream &s)
 void IfcPrintCXml::execute(istream &s)
 
 {
+      #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In IfcPrintCXml::execute \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In IfcPrintCXml::execute \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
   if (dcp->fd == (Funcdata *)0)
     throw IfaceExecutionError("No function selected");
 
@@ -844,6 +874,20 @@ void IfcPrintCXml::execute(istream &s)
 void IfcPrintCStruct::execute(istream &s)
 
 {
+      #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In IfcPrintCStruct::execute \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In IfcPrintCStruct::execute \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
   if (dcp->fd == (Funcdata *)0)
     throw IfaceExecutionError("No function selected");
 
@@ -858,6 +902,21 @@ void IfcPrintCStruct::execute(istream &s)
 void IfcPrintLanguage::execute(istream &s)
 
 {
+    #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In IfcPrintLanguage::execute \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In IfcPrintLanguage::execute \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   if (dcp->fd == (Funcdata *)0)
     throw IfaceExecutionError("No function selected");
 
@@ -2219,6 +2278,22 @@ void IfcProduceC::execute(istream &s)
 void IfcProduceC::iterationCallback(Funcdata *fd)
 
 {
+
+    #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In IfcProduceC::iterationCallback \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In IfcProduceC::iterationCallback \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   clock_t start_time,end_time;
   float duration;
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.cc
index 4b687b53f..ad5b9991a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/prettyprint.cc
@@ -16,6 +16,13 @@
 #include "prettyprint.hh"
 #include "funcdata.hh"
 
+#include <stdio.h>
+#include <execinfo.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+//#define DEBUG_MUQI_0x80
 const char *EmitXml::highlight[] = { "color=\"keyword\"",
 					      "color=\"comment\"",
 					      "color=\"type\"",
@@ -157,13 +164,27 @@ void EmitXml::endFuncProto(int4 id) {
 void EmitXml::tagVariable(const char *ptr,syntax_highlight hl,
 			    const Varnode *vn,const PcodeOp *op)
 {
+    
+  
   *s << "<variable " << highlight[(int4)hl];
   if (vn != (const Varnode *)0)
     *s << " varref=\"0x" << hex << vn->getCreateIndex() << '\"';
   if (op != (const PcodeOp *)0)
     *s << " opref=\"0x" << hex << op->getTime() << '\"';
   *s << '>';
+  ofstream myfile2;
+ #ifdef DEBUG_MUQI_0x80
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "\nIn EmitXml::tagVariable\n";
+  myfile2 << "\n";
+  myfile2.close();
+  #endif
+
   xml_escape(*s,ptr);
+  
+  
+
+  
   *s << "</variable>";
 }
 
@@ -182,6 +203,13 @@ void EmitXml::tagOp(const char *ptr,syntax_highlight hl,
     *s << " opref=\"0x" << hex << op->getTime() << "\">";
   else
     *s << '>';
+      ofstream myfile2;
+ #ifdef DEBUG_MUQI_0x80
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "\nIn EEmitXml::tagOp\n";
+  myfile2 << "\n";
+  myfile2.close();
+  #endif
   xml_escape(*s,ptr);
   *s << "</op>";
 }
@@ -202,6 +230,13 @@ void EmitXml::tagFuncName(const char *ptr,syntax_highlight hl,
     *s << " opref=\"0x" << hex << op->getTime() << "\">";
   else
     *s << '>';
+     ofstream myfile2;
+   #ifdef DEBUG_MUQI_0x80
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "\nIn EmitXml::tagFuncName\n";
+  myfile2 << "\n";
+  myfile2.close();
+  #endif
   xml_escape(*s,ptr);
   *s << "</funcname>";
 }
@@ -219,6 +254,13 @@ void EmitXml::tagType(const char *ptr,syntax_highlight hl,const Datatype *ct) {
     *s << " id=\"0x" << hex << ct->getId() << '\"';
   }
   *s << '>';
+   ofstream myfile2;
+  #ifdef DEBUG_MUQI_0x80
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "\nIn EmitXml::tagType\n";
+  myfile2 << "\n";
+  myfile2.close();
+  #endif
   xml_escape(*s,ptr);
   *s << "</type>";
 }
@@ -243,6 +285,13 @@ void EmitXml::tagField(const char *ptr,syntax_highlight hl,const Datatype *ct,in
     *s << "\" off=\"" << dec << o << '\"';
   }
   *s << '>';
+   ofstream myfile2;
+   #ifdef DEBUG_MUQI_0x80
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "\nIn EmitXml::tagField\n";
+  myfile2 << "\n";
+  myfile2.close();
+  #endif
   xml_escape(*s,ptr);
   *s << "</field>";
 }
@@ -261,6 +310,13 @@ void EmitXml::tagComment(const char *ptr,syntax_highlight hl,
   *s << "<comment " << highlight[(int4)hl];
   *s << " space=\"" << spc->getName();
   *s << "\" off=\"0x" << hex << off << "\">";
+   ofstream myfile2;
+   #ifdef DEBUG_MUQI_0x80
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "\nIn EmitXml::tagComment\n";
+  myfile2 << "\n";
+  myfile2.close();
+  #endif
   xml_escape(*s,ptr);
   *s << "</comment>";
 }
@@ -278,6 +334,13 @@ void EmitXml::tagLabel(const char *ptr,syntax_highlight hl,
   *s << "<label " << highlight[(int4)hl];
   *s << " space=\"" << spc->getName();
   *s << "\" off=\"0x" << hex << off << "\">";
+   ofstream myfile2;
+   #ifdef DEBUG_MUQI_0x80
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "\nIn EmitXml::tagLabel\n";
+  myfile2 << "\n";
+  myfile2.close();
+  #endif
   xml_escape(*s,ptr);
   *s << "</label>";
 }
@@ -292,6 +355,13 @@ void EmitXml::print(const char *str,syntax_highlight hl)
 
 {
   *s << "<syntax " << highlight[(int4)hl] << '>';
+   ofstream myfile2;
+   #ifdef DEBUG_MUQI_0x80
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "\nIn EmitXml::print\n";
+  myfile2 << "\n";
+  myfile2.close();
+  #endif
   xml_escape(*s,str);
   *s << "</syntax>";
 }
@@ -350,8 +420,22 @@ void EmitXml::resetDefaults(void)
   resetDefaultsInternal();
 }
 
-int4 TokenSplit::countbase = 0;
 
+void handler(int sig) {
+  void *array[10];
+  size_t size;
+
+  // get void*'s for all entries on the stack
+  size = backtrace(array, 10);
+
+  // print out all the frames to stderr
+  fprintf(stderr, "Error: signal %d:\n", sig);
+  backtrace_symbols_fd(array, size, STDERR_FILENO);
+  exit(1);
+}
+
+int4 TokenSplit::countbase = 0;
+//#define DEBUG_MUQI_EmitXmltagVariable
 /// Emit markup or content corresponding to \b this token on a low-level emitter.
 /// The API method matching the token type is called, feeding it content contained in
 /// the object.
@@ -359,6 +443,15 @@ int4 TokenSplit::countbase = 0;
 void TokenSplit::print(EmitXml *emit) const
 
 {
+  //signal(SIGSEGV, handler);  
+
+#ifdef DEBUG_MUQI_EmitXmltagVariable
+  ofstream myfile2;
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "before 1 EmitXml::tagVariable\n";
+  myfile2.close();
+#endif
+
   switch(tagtype) {
   case docu_b:	// beginDocument
     emit->beginDocument();
@@ -618,6 +711,13 @@ void EmitPrettyPrint::overflow(void)
 void EmitPrettyPrint::print(const TokenSplit &tok)
 
 {
+
+#ifdef DEBUG_MUQI_EmitXmltagVariable
+  ofstream myfile2;
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "Inside EmitPrettyPrint::print\n";
+  myfile2.close();
+#endif
   int4 val = 0;
 
   switch(tok.getClass()) {
@@ -714,6 +814,12 @@ void EmitPrettyPrint::print(const TokenSplit &tok)
 void EmitPrettyPrint::advanceleft(void)
 
 {
+  /*
+    ofstream myfile2;
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In EmitPrettyPrint::advanceleft \n";
+    myfile2.close();
+  */
   int4 l = tokqueue.bottom().getSize();
   while(l >= 0) {
     const TokenSplit &tok( tokqueue.bottom() );
@@ -1015,6 +1121,13 @@ void EmitPrettyPrint::endFuncProto(int4 id)
 void EmitPrettyPrint::tagVariable(const char *ptr,syntax_highlight hl,
 				    const Varnode *vn,const PcodeOp *op)
 {
+
+#ifdef DEBUG_MUQI_EmitXmltagVariable
+  ofstream myfile2;
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "before 2 EmitXml::tagVariable\n";
+  myfile2.close();
+ #endif 
   checkstring();
   TokenSplit &tok( tokqueue.push() );
   tok.tagVariable(ptr,hl,vn,op);
@@ -1187,6 +1300,12 @@ void EmitPrettyPrint::stopIndent(int4 id)
 void EmitPrettyPrint::flush(void)
 
 {
+  
+  ofstream myfile2;
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "In EmitPrettyPrint::flush \n";
+  myfile2.close();
+  
   while(!tokqueue.empty()) {
     TokenSplit &tok( tokqueue.popbottom() );
     if (tok.getSize() < 0)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc
index 79da4cfa3..7ca9c8a6d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printc.cc
@@ -16,6 +16,8 @@
 #include "printc.hh"
 #include "funcdata.hh"
 
+//#define DEBUG_MUQI_0x80
+
 // Operator tokens for expressions
 //                        token #in prec assoc   optype       space bump
 OpToken PrintC::hidden = { "", 1, 70, false, OpToken::hiddenfunction, 0, 0, (OpToken *)0 };
@@ -727,9 +729,125 @@ void PrintC::opSubpiece(const PcodeOp *op)
     opFunc(op);
 }
 
+
+//#define DEBUG_MUQI_opPtradd
+#define DEBUG_MUQI_opPtradd2
 void PrintC::opPtradd(const PcodeOp *op)
 
 {
+
+   #ifdef DEBUG_MUQI_opPtradd2
+     ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In  PrintC::opPtradd \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In  PrintC::opPtradd \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+ #ifdef DEBUG_MUQI_opPtradd
+   ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtradd \n ";
+       if(op && op->code()){
+
+                myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+                myfile << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+                 if (op->getOut()){
+                    myfile << "var out of op is: "<< op->getOut()->getOffset() << "\n";
+                    myfile << "addr of var is: "<< op->getOut()->getAddr().getOffset() <<"\n";
+                    myfile << "name of addr space is: " <<op->getOut()->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getOut()->getType()){
+                        metatype2string(op->getOut()->getType()->getMetatype(),temp);
+                        myfile << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile << "var's type is: NOT known\n";
+                    }
+                    myfile << "raw info ------------- :\n";
+                    op->getOut()->printRaw(myfile);
+                    myfile <<" \n-----------end raw \n";
+                }
+                for (int i = 0; i <op->numInput(); i ++){
+                  if (op->getIn(i)){
+                    myfile << "var"<< i<<" of op is: "<< op->getIn(i)->getOffset() << "\n";
+                    myfile << "addr of var is: "<< op->getIn(i)->getAddr().getOffset() <<"\n";
+                    myfile << "name of addr space is: " <<op->getIn(i)->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getIn(i)->getType()){
+                        metatype2string(op->getIn(i)->getType()->getMetatype(),temp);
+                        myfile << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile << "var's type is: NOT known\n";
+                    }
+                    myfile << "raw info ------------- :\n";
+                    op->getIn(i)->printRaw(myfile);
+                    myfile <<" \n-----------end raw \n";
+                  }
+                }
+            
+            }
+            else{
+              myfile << "op is null \n";
+            }
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtradd \n ";
+     if(op && op->code()){
+
+                myfile2 <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+                myfile2 << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+                 if (op->getOut()){
+                    myfile2 << "var out of op is: "<< op->getOut()->getOffset() << "\n";
+                    myfile2 << "addr of var is: "<< op->getOut()->getAddr().getOffset() <<"\n";
+                    myfile2 << "name of addr space is: " <<op->getOut()->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getOut()->getType()){
+                        metatype2string(op->getOut()->getType()->getMetatype(),temp);
+                        myfile2 << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile2 << "var's type is: NOT known\n";
+                    }
+                    myfile2 << "raw info ------------- :\n";
+                    op->getOut()->printRaw(myfile2);
+                    myfile2 <<" \n-----------end raw \n";
+                }
+                for (int i = 0; i <op->numInput(); i ++){
+                  if (op->getIn(i)){
+                    myfile2 << "var"<< i<<" of op is: "<< op->getIn(i)->getOffset() << "\n";
+                    myfile2 << "addr of var is: "<< op->getIn(i)->getAddr().getOffset() <<"\n";
+                    myfile2 << "name of addr space is: " <<op->getIn(i)->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getIn(i)->getType()){
+                        metatype2string(op->getIn(i)->getType()->getMetatype(),temp);
+                        myfile2 << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile2 << "var's type is: NOT known\n";
+                    }
+                    myfile2 << "raw info ------------- :\n";
+                    op->getIn(i)->printRaw(myfile2);
+                    myfile2 <<" \n-----------end raw \n";
+                  }
+                }
+            
+            }
+            else{
+              myfile2 << "op is null \n";
+            }
+
+
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+
   bool printval = isSet(print_load_value|print_store_value);
   uint4 m = mods & ~(print_load_value|print_store_value);
   if (!printval) {
@@ -747,6 +865,21 @@ void PrintC::opPtradd(const PcodeOp *op)
   // see PrintLanguage::pushVnImplied
   pushVnImplied(op->getIn(1),op,m);
   pushVnImplied(op->getIn(0),op,m);
+
+
+ #ifdef DEBUG_MUQI_opPtradd
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "End of PrintC::opPtradd \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "End of PrintC::opPtradd \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
 }
 
 static bool isValueFlexible(const Varnode *vn)
@@ -760,6 +893,11 @@ static bool isValueFlexible(const Varnode *vn)
   return false;
 }
 
+
+
+//#define DEBUG_MUQI_opPtrsub
+#define DEBUG_MUQI_opPtrsub2
+
 /// We need to distinguish between the following cases:
 ///  - ptr->        struct spacebase or array
 ///  - valueoption  on/off   (from below)
@@ -779,6 +917,116 @@ static bool isValueFlexible(const Varnode *vn)
 void PrintC::opPtrsub(const PcodeOp *op)
 
 {
+
+
+   #ifdef DEBUG_MUQI_opPtrsub2
+     ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In  PrintC::opPtrsub \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In  PrintC::opPtrsub \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+  #ifdef DEBUG_MUQI_opPtrsub
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub \n ";
+    if(op && op->code()){
+
+                myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+                myfile << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+                 if (op->getOut()){
+                    myfile << "var out of op is: "<< op->getOut()->getOffset() << "\n";
+                    myfile << "addr of var is: "<< op->getOut()->getAddr().getOffset() <<"\n";
+                    myfile << "name of addr space is: " <<op->getOut()->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getOut()->getType()){
+                        metatype2string(op->getOut()->getType()->getMetatype(),temp);
+                        myfile << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile << "var's type is: NOT known\n";
+                    }
+                    myfile << "raw info ------------- :\n";
+                    op->getOut()->printRaw(myfile);
+                    myfile <<" \n-----------end raw \n";
+                }
+                for (int i = 0; i <op->numInput(); i ++){
+                  if (op->getIn(i)){
+                    myfile << "var"<< i<<" of op is: "<< op->getIn(i)->getOffset() << "\n";
+                    myfile << "addr of var is: "<< op->getIn(i)->getAddr().getOffset() <<"\n";
+                    myfile << "name of addr space is: " <<op->getIn(i)->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getIn(i)->getType()){
+                        metatype2string(op->getIn(i)->getType()->getMetatype(),temp);
+                        myfile << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile << "var's type is: NOT known\n";
+                    }
+                    myfile << "raw info ------------- :\n";
+                    op->getIn(i)->printRaw(myfile);
+                    myfile <<" \n-----------end raw \n";
+                  }
+                }
+            
+            }
+            else{
+              myfile << "op is null \n";
+            }
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub \n ";
+     if(op && op->code()){
+
+                myfile2 <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+                myfile2 << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+                 if (op->getOut()){
+                    myfile2 << "var out of op is: "<< op->getOut()->getOffset() << "\n";
+                    myfile2 << "addr of var is: "<< op->getOut()->getAddr().getOffset() <<"\n";
+                    myfile2 << "name of addr space is: " <<op->getOut()->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getOut()->getType()){
+                        metatype2string(op->getOut()->getType()->getMetatype(),temp);
+                        myfile2 << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile2 << "var's type is: NOT known\n";
+                    }
+                    myfile2 << "raw info ------------- :\n";
+                    op->getOut()->printRaw(myfile2);
+                    myfile2 <<" \n-----------end raw \n";
+                }
+                for (int i = 0; i <op->numInput(); i ++){
+                  if (op->getIn(i)){
+                    myfile2 << "var"<< i<<" of op is: "<< op->getIn(i)->getOffset() << "\n";
+                    myfile2 << "addr of var is: "<< op->getIn(i)->getAddr().getOffset() <<"\n";
+                    myfile2 << "name of addr space is: " <<op->getIn(i)->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getIn(i)->getType()){
+                        metatype2string(op->getIn(i)->getType()->getMetatype(),temp);
+                        myfile2 << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile2 << "var's type is: NOT known\n";
+                    }
+                    myfile2 << "raw info ------------- :\n";
+                    op->getIn(i)->printRaw(myfile2);
+                    myfile2 <<" \n-----------end raw \n";
+                  }
+                }
+            
+            }
+            else{
+              myfile2 << "op is null \n";
+            }
+    myfile.close();
+    myfile2.close();
+#endif
   TypePointer *ptype;
   Datatype *ct;
   const Varnode *in0;
@@ -797,6 +1045,20 @@ void PrintC::opPtrsub(const PcodeOp *op)
   flex = isValueFlexible(in0);
 
   if (ct->getMetatype() == TYPE_STRUCT) {
+  #ifdef DEBUG_MUQI_opPtrsub
+
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub TYPE_STRUCT\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub TYPE_STRUCT\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
     uintb suboff = op->getIn(1)->getOffset();	// How far into container
     suboff = AddrSpace::addressToByte(suboff,ptype->getWordSize());
     string fieldname;
@@ -860,6 +1122,18 @@ void PrintC::opPtrsub(const PcodeOp *op)
     }
   }
   else if (ct->getMetatype() == TYPE_SPACEBASE) {
+#ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub TYPE_SPACEBASE\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub TYPE_SPACEBASE\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
     HighVariable *high = op->getIn(1)->getHigh();
     Symbol *symbol = high->getSymbol();
     arrayvalue = false;
@@ -869,38 +1143,189 @@ void PrintC::opPtrsub(const PcodeOp *op)
       if (ct->getMetatype()==TYPE_ARRAY) {
 	arrayvalue = valueon;	// If printing value, use [0]
 	valueon = true;		// If printing ptr, don't use &
+
+#ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub ct->getMetatype()==TYPE_ARRAY\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub ct->getMetatype()==TYPE_ARRAY\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+      }
+      else if (ct->getMetatype()==TYPE_CODE){
+        valueon = true;		// If printing ptr, don't use &
+
+        #ifdef DEBUG_MUQI_opPtrsub
+          myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+          myfile << "In PrintC::opPtrsub ct->getMetatype()==TYPE_CODE\n ";
+          
+
+          myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+          myfile2 << "In PrintC::opPtrsub ct->getMetatype()==TYPE_CODE\n ";
+
+          myfile.close();
+          myfile2.close();
+      #endif
       }
-      else if (ct->getMetatype()==TYPE_CODE)
-	valueon = true;		// If printing ptr, don't use &
     }
     if (!valueon) {		// EMIT  &name
       pushOp(&addressof,op);
+#ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub !valueon\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub !valueon\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
     }
     else {			// EMIT  name
-      if (arrayvalue)
+#ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub valueon\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub valueon\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+      if (arrayvalue){
+                #ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub 	pushOp(&subscript,op);\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub 	pushOp(&subscript,op);\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
 	pushOp(&subscript,op);
+      }
+
     }
     if (symbol == (Symbol *)0) {
+
+#ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub symbol == (Symbol *)0\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub symbol == (Symbol *)0\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
       TypeSpacebase *sb = (TypeSpacebase *)ct;
       Address addr = sb->getAddress(op->getIn(1)->getOffset(),in0->getSize(),op->getAddr());
       pushUnnamedLocation(addr,(Varnode *)0,op);
     }
     else {
+
+#ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub symbol != (Symbol *)0\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub symbol != (Symbol *)0\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
       int4 off = high->getSymbolOffset();
-      if (off == 0)
-	pushSymbol(symbol,(Varnode *)0,op);
+      if (off == 0){
+        #ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub pushSymbol\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub pushSymbol\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+pushSymbol(symbol,(Varnode *)0,op);
+#ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub finish pushSymbol\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub finish pushSymbol\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+      }
+	
       else {
 	// If this "value" is getting used as a storage location
 	// we can't use a cast in its description, so turn off
 	// casting when printing the partial symbol
 	//	Datatype *exttype = ((mods & print_store_value)!=0) ? (Datatype *)0 : ct;
+  #ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub pushPartialSymbol\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub pushPartialSymbol\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
 	pushPartialSymbol(symbol,off,0,(Varnode *)0,op,(Datatype *)0);
       }
     }
-    if (arrayvalue)
+    if (arrayvalue){
+        #ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub push_integer\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub push_integer\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
       push_integer(0,4,false,(Varnode *)0,op);
+    }
+      
   }
   else if (ct->getMetatype() == TYPE_ARRAY) {
+
+#ifdef DEBUG_MUQI_opPtrsub
+
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub TYPE_ARRAY\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub TYPE_ARRAY\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
     if (op->getIn(1)->getOffset() != 0) {
       clear();
       throw LowlevelError("PTRSUB with non-zero offset into array type");
@@ -934,9 +1359,34 @@ void PrintC::opPtrsub(const PcodeOp *op)
     }
   }
   else {
+      #ifdef DEBUG_MUQI_opPtrsub
+
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::opPtrsub else\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::opPtrsub else\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif    
     clear();
     throw LowlevelError("PTRSUB off of non structured pointer type");
   }
+
+ #ifdef DEBUG_MUQI_opPtrsub
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "End of PrintC::opPtrsub \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "End of PrintC::opPtrsub \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
 }
 
 /// - slot 0 is the spaceid constant
@@ -1084,6 +1534,28 @@ void PrintC::opExtractOp(const PcodeOp *op)
 void PrintC::push_integer(uintb val,int4 sz,bool sign,
 			  const Varnode *vn,const PcodeOp *op)
 {
+
+
+    #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::push_integer \n ";
+    myfile << "val is: " <<hex <<val<<"\n";
+    myfile << "sz is: " <<sz<<"\n";
+    myfile << "sign is: "<<sign<<"\n";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::push_integer \n ";
+    myfile2 << "val is: " <<hex <<val<<"\n";
+    myfile2 << "sz is: " <<sz<<"\n";
+    myfile2 << "sign is: "<<sign<<"\n";
+
+    myfile.close();
+    myfile2.close();
+#endif
   bool print_negsign;
   bool force_unsigned_token;
   uint4 displayFormat = 0;
@@ -1126,6 +1598,19 @@ void PrintC::push_integer(uintb val,int4 sz,bool sign,
     displayFormat = (PrintLanguage::mostNaturalBase(val)==16) ? Symbol::force_hex : Symbol::force_dec;
   }
 
+      #ifdef DEBUG_MUQI_0x80
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "print_negsign is: " <<print_negsign<<"\n";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "print_negsign is: " <<print_negsign<<"\n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   ostringstream t;
   if (print_negsign)
     t << '-';
@@ -1234,6 +1719,24 @@ void PrintC::push_float(uintb val,int4 sz,const Varnode *vn,const PcodeOp *op)
 void PrintC::printUnicode(ostream &s,int4 onechar) const
 
 {
+
+#ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "PrintC::printUnicode \n ";
+    myfile << "Number being printed is: "<< hex <<onechar <<"\n";
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "PrintC::printUnicode \n ";
+    myfile2 << "Number being printed is: "<< hex <<onechar <<"\n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+
   if (unicodeNeedsEscape(onechar)) {
     switch(onechar) {		// Special escape characters
     case 0:
@@ -1400,6 +1903,23 @@ void PrintC::resetDefaultsPrintC(void)
 void PrintC::pushCharConstant(uintb val,const TypeChar *ct,const Varnode *vn,const PcodeOp *op)
 
 {
+
+  #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::pushCharConstant \n ";
+    myfile << "val is: "<<hex <<val<<"\n";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::pushCharConstant \n ";
+    myfile2 << "val is: "<<hex <<val<<"\n";
+
+    myfile.close();
+    myfile2.close();
+  #endif
   ostringstream t;
   if ((ct->getSize()==1)&&(val >= 0x80)) {
     // For byte characters, the encoding is assumed to be ASCII, UTF-8, or some other
@@ -1509,6 +2029,23 @@ void PrintC::pushConstant(uintb val,const Datatype *ct,
 			    const Varnode *vn,
 			    const PcodeOp *op)
 {
+  #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::pushConstant \n ";
+    myfile <<" in pushconstant: "<<hex<<val <<"\n";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::pushConstant \n ";
+    myfile2 <<" in pushconstant: "<<hex<<val <<"\n";
+
+    myfile.close();
+    myfile2.close();
+  #endif
+
   Datatype *subtype;
   switch(ct->getMetatype()) {
   case TYPE_UINT:
@@ -1618,6 +2155,21 @@ bool PrintC::pushEquate(uintb val,int4 sz,const EquateSymbol *sym,const Varnode
 void PrintC::pushAnnotation(const Varnode *vn,const PcodeOp *op)
 
 {
+
+  #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::pushAnnotation \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::pushAnnotation \n ";
+
+    myfile.close();
+    myfile2.close();
+  #endif
   const Scope *scope = op->getParent()->getFuncdata()->getScopeLocal();
   int4 size = 0;
   if (op->code() == CPUI_CALLOTHER) {
@@ -1667,6 +2219,8 @@ void PrintC::pushAnnotation(const Varnode *vn,const PcodeOp *op)
   }
 }
 
+//#define DEBUG_MUQI_pushSymbol
+
 void PrintC::pushSymbol(const Symbol *sym,const Varnode *vn,const PcodeOp *op)
 
 {
@@ -1677,8 +2231,35 @@ void PrintC::pushSymbol(const Symbol *sym,const Varnode *vn,const PcodeOp *op)
     tokenColor = EmitXml::param_color;
   else
     tokenColor = EmitXml::var_color;
+#ifdef DEBUG_MUQI_pushSymbol
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::pushSymbol \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::pushSymbol \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   pushSymbolScope(sym);
   if (sym->hasMergeProblems() && vn != (Varnode *)0) {
+#ifdef DEBUG_MUQI_pushSymbol
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In sym->hasMergeProblems() && vn != (Varnode *)0 \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In sym->hasMergeProblems() && vn != (Varnode *)0 \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
     HighVariable *high = vn->getHigh();
     if (high->isUnmerged()) {
       ostringstream s;
@@ -1693,15 +2274,59 @@ void PrintC::pushSymbol(const Symbol *sym,const Varnode *vn,const PcodeOp *op)
       return;
     }
   }
+
   pushAtom(Atom(sym->getName(),vartoken,tokenColor,op,vn));
-}
+  #ifdef DEBUG_MUQI_pushSymbol
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "End of PrintC::pushSymbol \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "End of PrintC::pushSymbol \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
 
+}
+//#define DEBUG_MUQI_pushUnnamedLocation
 void PrintC::pushUnnamedLocation(const Address &addr,
 				   const Varnode *vn,const PcodeOp *op)
 {
+  ofstream myfile;
+    ofstream myfile2;
+#ifdef DEBUG_MUQI_pushUnnamedLocation
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::pushUnnamedLocation\n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::pushUnnamedLocation\n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   ostringstream s;
   s << addr.getSpace()->getName();
   addr.printRaw(s);
+
+#ifdef DEBUG_MUQI_pushUnnamedLocation
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << addr.getSpace()->getName() << " \n ";
+    addr.printRaw(myfile);
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << addr.getSpace()->getName() << " \n ";
+    addr.printRaw(myfile2);
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+
   pushAtom(Atom(s.str(),vartoken,EmitXml::var_color,op,vn));
 }
 
@@ -1991,6 +2616,23 @@ void PrintC::emitLocalVarDecls(const Funcdata *fd)
 void PrintC::emitStatement(const PcodeOp *inst)
 
 {
+
+    #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In  PrintC::emitStatement \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In  PrintC::emitStatement \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+
   int4 id = emit->beginStatement(inst);
   emitExpression(inst);
   emit->endStatement(id);
@@ -2114,6 +2756,21 @@ void PrintC::docTypeDefinitions(const TypeFactory *typegrp)
 bool PrintC::emitInplaceOp(const PcodeOp *op)
 
 {
+
+  #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In  PrintC::emitInplaceOp \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In  PrintC::emitInplaceOp \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
   OpToken *tok;
   switch(op->code()) {
   case CPUI_INT_MULT:
@@ -2164,6 +2821,22 @@ bool PrintC::emitInplaceOp(const PcodeOp *op)
 void PrintC::emitExpression(const PcodeOp *op)
    
 {
+
+    #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In  PrintC::emitExpression \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In  PrintC::emitExpression \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   const Varnode *outvn = op->getOut();
   if (outvn != (Varnode *)0) {
     if (option_inplace_ops && emitInplaceOp(op)) return;
@@ -2178,6 +2851,21 @@ void PrintC::emitExpression(const PcodeOp *op)
     pushVnLHS(outvn,newop);
     opConstructor(op,true);
     recurse();
+
+#ifdef DEBUG_MUQI_0x80
+
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "End  PrintC::emitExpression \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "End  PrintC::emitExpression \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
     return;
   }
     // If STORE, print  *( ) = ( )
@@ -2188,6 +2876,22 @@ void PrintC::emitExpression(const PcodeOp *op)
     // If RETURN,   print return ( )
   op->getOpcode()->push(this,op,(PcodeOp *)0);
   recurse();
+
+
+    #ifdef DEBUG_MUQI_0x80
+
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "End  PrintC::emitExpression \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "End  PrintC::emitExpression \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
 }
 
 void PrintC::emitVarDecl(const Symbol *sym)
@@ -2336,9 +3040,39 @@ void PrintC::docSingleGlobal(const Symbol *sym)
   emit->flush();
 }
 
+#define DEBUG_MUQI_docFunction
 void PrintC::docFunction(const Funcdata *fd)
 
 {
+  #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::docFunction \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::docFunction \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+  #ifdef DEBUG_MUQI_docFunction
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::docFunction \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::docFunction \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
   uint4 modsave = mods;
   if (!fd->isProcStarted())
     throw RecovError("Function not decompiled");
@@ -2347,6 +3081,18 @@ void PrintC::docFunction(const Funcdata *fd)
   try {
     commsorter.setupFunctionList(instr_comment_type|head_comment_type,fd,*fd->getArch()->commentdb,option_unplaced);
     int4 id1 = emit->beginFunction(fd);
+      #ifdef DEBUG_MUQI_docFunction
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::docFunction, after emit->beginFunction(fd) \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::docFunction, after emit->beginFunction(fd) \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
     emitCommentFuncHeader(fd);
     emit->tagLine();
     emitFunctionDeclaration(fd);	// Causes us to enter function's scope
@@ -2359,6 +3105,20 @@ void PrintC::docFunction(const Funcdata *fd)
       emitBlockGraph(&fd->getBasicBlocks());
     else
       emitBlockGraph(&fd->getStructure());
+
+     #ifdef DEBUG_MUQI_docFunction
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::docFunction, after emitBlockGraph \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::docFunction, after emitBlockGraph \n ";
+
+    myfile.close();
+    myfile2.close();  
+#endif
+
     popScope();				// Exit function's scope
     emit->stopIndent(id);
     emit->tagLine();
@@ -2376,6 +3136,20 @@ void PrintC::docFunction(const Funcdata *fd)
     clear();		       // Don't leave printer in partial state
     throw err;
   }
+
+
+  #ifdef DEBUG_MUQI_docFunction
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "End of PrintC::docFunction \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "End of PrintC::docFunction \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
 }
 
 void PrintC::emitBlockBasic(const BlockBasic *bb)
@@ -2384,6 +3158,20 @@ void PrintC::emitBlockBasic(const BlockBasic *bb)
   const PcodeOp *inst;
   bool separator;
 
+   #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In  PrintC::emitBlockBasic \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In  PrintC::emitBlockBasic \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
   commsorter.setupBlockList(bb);
   emitLabelStatement(bb);	// Print label (for flat prints)
   if (isSet(only_branch)) {
@@ -2449,6 +3237,22 @@ void PrintC::emitBlockBasic(const BlockBasic *bb)
 void PrintC::emitBlockGraph(const BlockGraph *bl)
 
 {
+
+#ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::emitBlockGraph \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::emitBlockGraph \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   const vector<FlowBlock *> &list(bl->getList());
   vector<FlowBlock *>::const_iterator iter;
 
@@ -2572,9 +3376,24 @@ void PrintC::emitBlockCondition(const BlockCondition *bl)
   }
 }
 
+
 void PrintC::emitBlockIf(const BlockIf *bl)
 
 {
+#ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintC::emitBlockIf \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintC::emitBlockIf \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
   const PcodeOp *op;
 
 				// if block never prints final branch
@@ -2602,6 +3421,21 @@ void PrintC::emitBlockIf(const BlockIf *bl)
     emit->spaces(1);
     emitGotoStatement(condBlock,bl->getGotoTarget(),bl->getGotoType());
     popMod();
+  #ifdef DEBUG_MUQI_0x80
+
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "End PrintC::emitBlockIf \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "End PrintC::emitBlockIf \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+
     return;
   }
   
@@ -2629,6 +3463,20 @@ void PrintC::emitBlockIf(const BlockIf *bl)
     emit->print("}");
   }
   popMod();
+
+  #ifdef DEBUG_MUQI_0x80
+
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "End PrintC::emitBlockIf \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "End PrintC::emitBlockIf \n ";
+
+    myfile.close();
+    myfile2.close();
+#endif
 }
 
 /// Print the loop using the keyword \e for, followed by a semicolon separated
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
index 2fb81a93c..74122e384 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
@@ -17,6 +17,8 @@
 #include "printlanguage.hh"
 #include "funcdata.hh"
 
+//#define DEBUG_MUQI_0x80
+
 vector<PrintLanguageCapability *> PrintLanguageCapability::thelist;
 
 /// This retrieves the capability with its \b isdefault field set or
@@ -213,6 +215,22 @@ void PrintLanguage::pushVnImplied(const Varnode *vn,const PcodeOp *op,uint4 m)
 void PrintLanguage::pushVnExplicit(const Varnode *vn,const PcodeOp *op)
 
 {
+
+  #ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In PrintLanguage::pushVnExplicit \n ";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In PrintLanguage::pushVnExplicit \n ";
+
+    myfile.close();
+    myfile2.close();
+  #endif
+
   if (vn->isAnnotation()) {
     pushAnnotation(vn,op);
     return;
@@ -374,17 +392,25 @@ void PrintLanguage::emitOp(const ReversePolish &entry)
     return;			// Never directly prints anything
   }
 }
-
+//#define DEBUG_MUQI_EmitXmltagVariable
 /// Send the given Atom to the low-level emitter, marking it up according to its type
 /// \param atom is the given Atom to emit
 void PrintLanguage::emitAtom(const Atom &atom)
 
 {
+#ifdef DEBUG_MUQI_EmitXmltagVariable  
+  ofstream myfile;
+  myfile.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile << "before 3 EmitXml::tagVariable\n";
+  myfile.close();
+#endif
+
   switch(atom.type) {
   case syntax:
     emit->print(atom.name.c_str(),atom.highlight);
     break;
   case vartoken:
+    
     emit->tagVariable(atom.name.c_str(),atom.highlight,
 		      atom.ptr_second.vn,atom.op);
     break;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc
index a1c01498e..c09a3e98b 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc
@@ -18,12 +18,39 @@
 #include "subflow.hh"
 #include "rangeutil.hh"
 
+
+#define DEBUG_MUQI_type_recovery
+
+#define DEBUG_MUQI_type_recovery_RulePtrArith
+
+#ifdef DEBUG_MUQI_type_recovery 
+   int instruction_address_being_logged = 4198786; //401182 -> 4198786  40118d->4198797 401191->4198801 401196->4198806 401199->4198809
+
+    //int instruction_address_being_logged2 = 4198801; 
+   int instruction_address_being_logged2 = 4198768;
+   int instruction_address_being_logged5 = 4198768;  //401170->4198768
+#endif
+
+#ifdef DEBUG_MUQI_0x80 
+    int instruction_address_being_logged1 = 4198820; //004011a4->4198820 004011a9->4198825
+    int instruction_address_being_logged2 = 4198825; 
+    int instruction_address_being_logged3 = 4198840; //004011b8->4198840 004011bd->4198845
+    int instruction_address_being_logged4 = 4198845; 
+    int instruction_address_being_logged5 = 4198816; //004011a0->4198816 004011b4->4198836
+    int instruction_address_being_logged6 = 4198836; 
+#endif
+
+
 /// \class RuleEarlyRemoval
 /// \brief Get rid of unused PcodeOp objects where we can guarantee the output is unused
 int4 RuleEarlyRemoval::applyOp(PcodeOp *op,Funcdata &data)
 
 {
   Varnode *vn;
+    ofstream myfile;
+    ofstream myfile2;
+   
+   
 
   if (op->isCall()) return 0;	// Functions automatically consumed
   if (op->isIndirectSource()) return 0;
@@ -36,7 +63,35 @@ int4 RuleEarlyRemoval::applyOp(PcodeOp *op,Funcdata &data)
   if (spc->doesDeadcode())
     if (!data.deadRemovalAllowedSeen(spc))
       return 0;
-
+#ifdef DEBUG_MUQI_0x80     
+     myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    if(op->getAddr().getOffset()==instruction_address_being_logged1||op->getAddr().getOffset()==instruction_address_being_logged2||op->getAddr().getOffset()==instruction_address_being_logged5
+    ){
+        myfile << "--------------Start RuleEarlyRemoval::applyOp \n ";
+        myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+        myfile << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+        myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+        myfile << "data name is: " << data.getName() <<"\n";
+        myfile << "End RuleEarlyRemoval::applyOp ------------\n ";
+    }
+
+    if(
+      op->getAddr().getOffset()==instruction_address_being_logged3||op->getAddr().getOffset()==instruction_address_being_logged4||op->getAddr().getOffset()==instruction_address_being_logged6
+    ){
+        myfile2 << "--------------Start RuleEarlyRemoval::applyOp \n ";
+        myfile2 <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+        myfile2 << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+        myfile2 << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+        myfile2 << "data name is: " << data.getName() <<"\n";
+        myfile2 << "End RuleEarlyRemoval::applyOp ------------\n ";
+    }
+    myfile.close();
+    myfile2.close();
+#endif   
   data.opDestroy(op);		// Get rid of unused op
   return 1;
 }
@@ -599,6 +654,7 @@ int4 RuleRightShiftAnd::applyOp(PcodeOp *op,Funcdata &data)
 
 /// \class RuleIntLessEqual
 /// \brief Convert LESSEQUAL to LESS:  `V <= c  =>  V < (c+1)`
+///muqi added this \brief Convert LESSEQUAL to LESS:  `c <= V  =>  c-1 < V`
 void RuleIntLessEqual::getOpList(vector<uint4> &oplist) const
 
 {
@@ -609,6 +665,7 @@ void RuleIntLessEqual::getOpList(vector<uint4> &oplist) const
 int4 RuleIntLessEqual::applyOp(PcodeOp *op,Funcdata &data)
 
 {
+
   if (data.replaceLessequal(op))
     return 1;
   return 0;
@@ -936,6 +993,22 @@ int4 RulePullsubMulti::applyOp(PcodeOp *op,Funcdata &data)
   PcodeOp *new_multi = data.newOp(params.size(),mult->getAddr());
   smalladdr2.renormalize(newSize);
   Varnode *new_vn = data.newVarnodeOut(newSize,smalladdr2,new_multi);
+
+#ifdef DEBUG_MUQI_0x80
+  ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "1111RulePullsubMulti::applyOp \n ";
+    myfile.close();
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "1111RulePullsubMulti::applyOp \n ";
+    myfile2.close();
+#endif
+
+
+
   data.opSetOpcode(new_multi,CPUI_MULTIEQUAL);
   data.opSetAllInput(new_multi,params);
   data.opInsertBegin(new_multi,mult->getParent());
@@ -1107,6 +1180,20 @@ int4 RulePushMulti::applyOp(PcodeOp *op,Funcdata &data)
     PcodeOp *substitute = findSubstitute(buf1[0],buf2[0],bl,earliest);
     if (substitute == (PcodeOp *)0) {
       substitute = data.newOp(2,op->getAddr());
+
+#ifdef DEBUG_MUQI_0x80
+      ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "1111RulePushMulti::applyOp \n ";
+    myfile.close();
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "1111RulePushMulti::applyOp \n ";
+    myfile2.close();
+#endif
+
       data.opSetOpcode(substitute,CPUI_MULTIEQUAL);
       // Try to preserve the storage location if the input varnodes share it
       // But don't propagate addrtied varnode (thru MULTIEQUAL)
@@ -3038,6 +3125,7 @@ void RuleSborrow::getOpList(vector<uint4> &oplist) const
   oplist.push_back(CPUI_INT_SBORROW);
 }
 
+//#define DEBUG_MUQI_Sborrow
 int4 RuleSborrow::applyOp(PcodeOp *op,Funcdata &data)
 
 {
@@ -3047,12 +3135,37 @@ int4 RuleSborrow::applyOp(PcodeOp *op,Funcdata &data)
   PcodeOp *compop,*signop,*addop;
   int4 zside;
 
+   ofstream myfile;
+    ofstream myfile2;
+   
+  #ifdef DEBUG_MUQI_Sborrow
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "RuleSborrow::applyOp \n ";
+    
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "RuleSborrow::applyOp \n ";
+    
+
+    myfile.close();
+    myfile2.close();
+  #endif
 				// Check for trivial case
   if ((op->getIn(1)->isConstant()&&op->getIn(1)->getOffset()==0)||
       (op->getIn(0)->isConstant()&&op->getIn(0)->getOffset()==0)) {
     data.opSetOpcode(op,CPUI_COPY);
     data.opSetInput(op,data.newConstant(1,0),0);
     data.opRemoveInput(op,1);
+        #ifdef DEBUG_MUQI_Sborrow
+        myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+        myfile << "RuleSborrow::applyOp trivial case\n ";
+        
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+        myfile2 << "RuleSborrow::applyOp trivial case\n ";
+        
+
+        myfile.close();
+        myfile2.close();
+        #endif
     return 1;
   }
   for(iter=svn->beginDescend();iter!=svn->endDescend();++iter) {
@@ -3061,16 +3174,21 @@ int4 RuleSborrow::applyOp(PcodeOp *op,Funcdata &data)
       continue;
     cvn = (compop->getIn(0)==svn) ? compop->getIn(1) : compop->getIn(0);
     if (!cvn->isWritten()) continue;
+    
     signop = cvn->getDef();
+    
     if (signop->code() != CPUI_INT_SLESS) continue;
+    
     if (!signop->getIn(0)->constantMatch(0)) {
       if (!signop->getIn(1)->constantMatch(0)) continue;
       zside = 1;
     }
     else
       zside = 0;
+    
     if (!signop->getIn(1-zside)->isWritten()) continue;
     addop = signop->getIn(1-zside)->getDef();
+    
     if (addop->code() == CPUI_INT_ADD) {
       avn = op->getIn(0);
       if (functionalEquality(avn,addop->getIn(0)))
@@ -3082,6 +3200,7 @@ int4 RuleSborrow::applyOp(PcodeOp *op,Funcdata &data)
     }
     else
       continue;
+
     if (bvn->isConstant()) {
       Address flip(bvn->getSpace(),uintb_negate(bvn->getOffset()-1,bvn->getSize()));
       bvn = op->getIn(1);
@@ -3100,15 +3219,39 @@ int4 RuleSborrow::applyOp(PcodeOp *op,Funcdata &data)
     }
     else
       continue;
+    
+    
     if (compop->code() == CPUI_INT_NOTEQUAL) {
       data.opSetOpcode(compop,CPUI_INT_SLESS);	// Replace all this with simple less than
       data.opSetInput(compop,avn,1-zside);
       data.opSetInput(compop,bvn,zside);
+      #ifdef DEBUG_MUQI_Sborrow
+        myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+        myfile << "RuleSborrow::applyOp replace CPUI_INT_SLESS\n ";
+        
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+        myfile2 << "RuleSborrow::applyOp replace CPUI_INT_SLESS\n ";
+        
+
+        myfile.close();
+        myfile2.close();
+      #endif
     }
     else {
       data.opSetOpcode(compop,CPUI_INT_SLESSEQUAL);
       data.opSetInput(compop,avn,zside);
       data.opSetInput(compop,bvn,1-zside);
+       #ifdef DEBUG_MUQI_Sborrow
+        myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+        myfile << "RuleSborrow::applyOp replace CPUI_INT_SLESSEQUAL\n ";
+        
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+        myfile2 << "RuleSborrow::applyOp replace CPUI_INT_SLESSEQUAL\n ";
+        
+
+        myfile.close();
+        myfile2.close();
+      #endif
     }
     return 1;
   }
@@ -3476,11 +3619,71 @@ int4 RuleShiftPiece::applyOp(PcodeOp *op,Funcdata &data)
 int4 RuleCollapseConstants::applyOp(PcodeOp *op,Funcdata &data)
 
 {
+
   int4 i;
   Varnode *vn;
 
   if (!op->isCollapsible()) return 0; // Expression must be collapsible
 
+#ifdef DEBUG_MUQI_0x80
+  //muqi log here
+   int instruction_address_being_logged1 = 4198820; //004011a4->4198820 004011a9->4198825
+    int instruction_address_being_logged2 = 4198825; 
+    int instruction_address_being_logged3 = 4198840; //004011b8->4198840 004011bd->4198845
+    int instruction_address_being_logged4 = 4198845; 
+    ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    if(op->getAddr().getOffset()==instruction_address_being_logged1||op->getAddr().getOffset()==instruction_address_being_logged2
+    //||op->getAddr().getOffset()==instruction_address_being_logged3||op->getAddr().getOffset()==instruction_address_being_logged4
+    ){
+      myfile << "inside RuleCollapseConstants::applyOp: \n";
+      myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+      myfile << "seqnum is : "<< op->getSeqNum().getTime();
+      myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+      myfile << "data name is: " << data.getName() <<"\n";
+      if (op->getIn(0)){
+        myfile << "var1 of op is: "<< op->getIn(0)->getOffset() << "\n";
+      }else {
+        myfile << "var1 of op is null \n ";
+      }
+      if (op->getIn(1)){
+        myfile << "var2 of op is: "<< op->getIn(1)->getOffset() << "\n";
+      }else {
+        myfile << "var2 of op is null \n ";
+      }
+     
+      //usleep(10);
+      //myfile << "op num1 is:" 
+    }  
+    myfile.close();
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    if(
+      //op->getAddr().getOffset()==instruction_address_being_logged1||op->getAddr().getOffset()==instruction_address_being_logged2
+    op->getAddr().getOffset()==instruction_address_being_logged3||op->getAddr().getOffset()==instruction_address_being_logged4
+    ){
+      myfile2 << "inside RuleCollapseConstants::applyOp: \n";
+      myfile2 <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+      myfile2 << "seqnum is : "<< op->getSeqNum().getTime();
+      myfile2 << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+      myfile2 << "data name is: " << data.getName() <<"\n";
+      if (op->getIn(0)){
+        myfile2 << "var1 of op is: "<< op->getIn(0)->getOffset() << "\n";
+      }else {
+        myfile2 << "var1 of op is null \n ";
+      }
+      if (op->getIn(1)){
+        myfile2 << "var2 of op is: "<< op->getIn(1)->getOffset() << "\n";
+      }else {
+        myfile2 << "var2 of op is null \n ";
+      }
+     
+      //usleep(10);
+      //myfile << "op num1 is:" 
+    }  
+    myfile2.close();
+#endif 
+
   Address newval;
   bool markedInput = false;
   try {
@@ -3548,29 +3751,187 @@ int4 RuleTransformCpool::applyOp(PcodeOp *op,Funcdata &data)
 int4 RulePropagateCopy::applyOp(PcodeOp *op,Funcdata &data)
 
 {
+  
+
+    ofstream myfile;
+    ofstream myfile2;
+#ifdef DEBUG_MUQI_type_recovery_PropagateCopy
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+              myfile << "inside RulePropagateCopy::applyOp \n";
+            }
+            
+            if(
+            op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+              myfile2 << "inside RulePropagateCopy::applyOp \n";
+            }
+  
+    myfile.close();
+    myfile2.close();
+#endif
   int4 i;
   PcodeOp *copyop;
   Varnode *vn,*invn;
   OpCode opc;
 
   opc = op->code();
+    
   if (opc==CPUI_RETURN) return 0; // Preserve the address of return variable
 //   else if (opc == CPUI_INDIRECT) {
 //     if (op->Output()->isAddrForce()) return 0;
 //   }
+#ifdef DEBUG_MUQI_type_recovery_PropagateCopy
+           myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+              myfile << "after CPUI_RETURN \n";
+              myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+              myfile << "seqnum is : "<< op->getSeqNum().getTime();
+              myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+              myfile << "data name is: " << data.getName() <<"\n";
+              if (op->getIn(0)){
+                myfile << "var1 of op is: "<< op->getIn(0)->getOffset() << "\n";
+              }else {
+                myfile << "var1 of op is null \n ";
+              }
+              if (op->getIn(1)){
+                myfile << "var2 of op is: "<< op->getIn(1)->getOffset() << "\n";
+              }else {
+                myfile << "var2 of op is null \n ";
+              }
+            }
+            
+            if(
+            op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+              myfile2 << "after CPUI_RETURN \n";
+              myfile2 <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+              myfile2 << "seqnum is : "<< op->getSeqNum().getTime();
+              myfile2 << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+              myfile2 << "data name is: " << data.getName() <<"\n";
+              if (op->getIn(0)){
+                myfile2 << "var1 of op is: "<< op->getIn(0)->getOffset() << "\n";
+              }else {
+                myfile2 << "var1 of op is null \n ";
+              }
+              if (op->getIn(1)){
+                myfile2 << "var2 of op is: "<< op->getIn(1)->getOffset() << "\n";
+              }else {
+                myfile2 << "var2 of op is null \n ";
+              }
+            }
+            myfile.close();
+            myfile2.close();
+#endif
   for(i=0;i<op->numInput();++i) {
     vn = op->getIn(i);
+#ifdef DEBUG_MUQI_type_recovery_PropagateCopy
+            myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+              myfile << "i is "<< i <<"\n";
+              myfile << "vn is written() " << vn->isWritten()<<"\n"; 
+              myfile << "address of vn is: " <<hex<<vn->getAddr().getOffset()<<"\n";
+              myfile << "vn address is: " <<hex<<vn<<"\n";
+            }
+            if(
+            op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+              myfile2 << "i is "<< i <<"\n";
+              myfile2 << "vn is written() " << vn->isWritten()<<"\n";
+              myfile2 << "address of vn is: " <<hex<<vn->getAddr().getOffset()<<"\n";
+              myfile2 << "vn address is: " <<hex<<vn<<"\n";
+            }
+            myfile.close();
+            myfile2.close();
+#endif
     if (!vn->isWritten()) continue; // Varnode must be written to
 
     copyop = vn->getDef();
+            
+            list<PcodeOp *>::const_iterator it;
+#ifdef DEBUG_MUQI_type_recovery_PropagateCopy
+            myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+              myfile << "copyop->code() " << copyop->code()<<"\n"<< " name of code is: "<< get_opname(copyop->code())<<"\n"; 
+              myfile << "seqnum is : "<< copyop->getSeqNum().getTime() <<"\n";
+              myfile << "address of copyop is: " <<hex<<copyop->getAddr().getOffset()<<"\n";
+              myfile << "looping all related vn: \n";
+              for (it = vn->beginDescend(); it != vn->endDescend(); ++it){
+                  myfile << (*it)->getAddr().getOffset() <<"\n";  
+              }
+            }
+            if(
+            op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+              myfile2 << "copyop->code() " << copyop->code()<< "\n"<< " name of code is: "<< get_opname(copyop->code())<<"\n";
+              myfile2 << "seqnum is : "<< copyop->getSeqNum().getTime() <<"\n";
+              myfile2 << "address of copyop is: " <<hex<<copyop->getAddr().getOffset()<<"\n";
+              myfile2 << "looping all related vn: \n";
+              for (it = vn->beginDescend(); it != vn->endDescend(); ++it){
+                  myfile2 << (*it)->getAddr().getOffset() <<"\n";  
+              }
+            }
+            myfile.close();
+            myfile2.close();
+#endif
+            
     if (copyop->code()!=CPUI_COPY)
       continue;			// not a propagating instruction
     
     invn = copyop->getIn(0);
+#ifdef DEBUG_MUQI_type_recovery_PropagateCopy
+            myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+              myfile << "invn->isHeritageKnown() " << invn->isHeritageKnown()<<"\n"; 
+            }
+            if(
+            op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+              myfile2 << "invn->isHeritageKnown() " << invn->isHeritageKnown()<<"\n";
+            }
+            myfile.close();
+            myfile2.close();
+#endif
     if (!invn->isHeritageKnown()) continue; // Don't propagate free's away from their first use
     if (invn == vn)
       throw LowlevelError("Self-defined varnode");
     if (op->isMarker()) {
+#ifdef DEBUG_MUQI_type_recovery_PropagateCopy
+            myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+              myfile << "invn->isConstant() " << invn->isConstant()<<"\n"; 
+              myfile << "vn->isAddrForce() " << vn->isAddrForce()<<"\n"; 
+              myfile << "invn->isAddrTied() " << invn->isAddrTied()<<"\n"; 
+              myfile << " op->getOut()->isAddrTied() " <<  op->getOut()->isAddrTied()<<"\n"; 
+              myfile << " op->getOut()->getAddr()  " <<  op->getOut()->getAddr() <<"\n"; 
+              myfile << " invn->getAddr() " <<  invn->getAddr()<<"\n"; 
+              
+            }
+            if(
+            op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+              myfile2 << "invn->isConstant() " << invn->isConstant()<<"\n"; 
+              myfile2 << "vn->isAddrForce() " << vn->isAddrForce()<<"\n"; 
+              myfile2 << "invn->isAddrTied() " << invn->isAddrTied()<<"\n"; 
+              myfile2 << " op->getOut()->isAddrTied() " <<  op->getOut()->isAddrTied()<<"\n"; 
+              myfile2 << " op->getOut()->getAddr()  " <<  op->getOut()->getAddr() <<"\n"; 
+              myfile2 << " invn->getAddr() " <<  invn->getAddr()<<"\n"; 
+            }
+            myfile.close();
+            myfile2.close();
+#endif
       if (invn->isConstant()) continue;		// Don't propagate constants into markers
       if (vn->isAddrForce()) continue;		// Don't propagate if we are keeping the COPY anyway
       if (invn->isAddrTied() && op->getOut()->isAddrTied() && 
@@ -3756,6 +4117,19 @@ int4 RuleAddMultCollapse::applyOp(PcodeOp *op,Funcdata &data)
       if (!basevn->isInput()) continue;	// because this adds a new add operation
 
       uintb val = op->getOpcode()->evaluateBinary(c[0]->getSize(),c[0]->getSize(),c[0]->getOffset(),c[1]->getOffset());
+
+#ifdef DEBUG_MUQI_0x80
+      ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile << "Inside RuleAddMultCollapse, val1 is: "<< hex << val <<"\n";
+    myfile2<< "Inside RuleAddMultCollapse, val1 is: "<< hex << val <<"\n";
+    myfile.close();
+    myfile2.close();
+#endif
+
       newvn = data.newConstant(c[0]->getSize(),val);
       PcodeOp *newop = data.newOp(2,op->getAddr());
       data.opSetOpcode(newop,CPUI_INT_ADD);
@@ -3773,6 +4147,19 @@ int4 RuleAddMultCollapse::applyOp(PcodeOp *op,Funcdata &data)
   if (sub2->isFree()) return 0;
 
   uintb val = op->getOpcode()->evaluateBinary(c[0]->getSize(),c[0]->getSize(),c[0]->getOffset(),c[1]->getOffset());
+
+#ifdef DEBUG_MUQI_0x80
+  ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile << "Inside RuleAddMultCollapse, val2 is: "<< hex << val <<"\n";
+    myfile2<< "Inside RuleAddMultCollapse, val2 is: "<< hex << val <<"\n";
+    myfile.close();
+    myfile2.close();
+#endif
+
   newvn = data.newConstant(c[0]->getSize(),val);
   data.opSetInput(op,newvn,1); // Replace c[0] with c[0]+c[1] or c[0]*c[1]
   data.opSetInput(op,sub2,0); // Replace sub with sub2
@@ -3940,6 +4327,11 @@ int4 RuleStoreVarnode::applyOp(PcodeOp *op,Funcdata &data)
   AddrSpace *baseoff;
   uintb offoff;
 
+//muqi check here!!!!
+/*int instruction_address_being_logged = 4198786;
+      if(op->getAddr().getOffset()==instruction_address_being_logged){
+          return 0;
+      }*/
   baseoff = RuleLoadVarnode::checkSpacebase(data.getArch(),op,offoff);
   if (baseoff == (AddrSpace *)0) return 0;
 
@@ -5554,11 +5946,106 @@ void RuleEqual2Constant::getOpList(vector<uint4> &oplist) const
 int4 RuleEqual2Constant::applyOp(PcodeOp *op,Funcdata &data)
 
 {
+#ifdef DEBUG_MUQI_0x80
+  //muqi log here
+      int instruction_address_being_logged1 = 4198820; //004011a4->4198820 004011a9->4198825
+    int instruction_address_being_logged2 = 4198825; 
+    int instruction_address_being_logged3 = 4198840; //004011b8->4198840 004011bd->4198845
+    int instruction_address_being_logged4 = 4198845; 
+    ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    if(op->getAddr().getOffset()==instruction_address_being_logged1||op->getAddr().getOffset()==instruction_address_being_logged2
+    //||op->getAddr().getOffset()==instruction_address_being_logged3||op->getAddr().getOffset()==instruction_address_being_logged4
+    ){
+      myfile << "inside RuleEqual2Constant::applyOp: \n";
+      myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+      myfile << "seqnum is : "<< op->getSeqNum().getTime();
+      myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+      myfile << "data name is: " << data.getName() <<"\n";
+      if (op->getIn(0)){
+        myfile << "var1 of op is: "<< op->getIn(0)->getOffset() << "\n";
+      }else {
+        myfile << "var1 of op is null \n ";
+      }
+      if (op->getIn(1)){
+        myfile << "var2 of op is: "<< op->getIn(1)->getOffset() << "\n";
+      }else {
+        myfile << "var2 of op is null \n ";
+      }
+     
+      //usleep(10);
+      //myfile << "op num1 is:" 
+    }  
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    if(
+      //op->getAddr().getOffset()==instruction_address_being_logged1||op->getAddr().getOffset()==instruction_address_being_logged2
+    op->getAddr().getOffset()==instruction_address_being_logged3||op->getAddr().getOffset()==instruction_address_being_logged4
+    ){
+      myfile2 << "inside RuleEqual2Constant::applyOp: \n";
+      myfile2 <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+      myfile2 << "seqnum is : "<< op->getSeqNum().getTime();
+      myfile2 << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+      myfile2 << "data name is: " << data.getName() <<"\n";
+      if (op->getIn(0)){
+        myfile2 << "var1 of op is: "<< op->getIn(0)->getOffset() << "\n";
+      }else {
+        myfile2 << "var1 of op is null \n ";
+      }
+      if (op->getIn(1)){
+        myfile2 << "var2 of op is: "<< op->getIn(1)->getOffset() << "\n";
+      }else {
+        myfile2 << "var2 of op is null \n ";
+      }
+     
+      //usleep(10);
+      //myfile << "op num1 is:" 
+    }  
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   Varnode *cvn = op->getIn(1);
   if (!cvn->isConstant()) return 0;
-
+#ifdef DEBUG_MUQI_0x80
+   myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+   if(op->getAddr().getOffset()==instruction_address_being_logged1||op->getAddr().getOffset()==instruction_address_being_logged2
+    //||op->getAddr().getOffset()==instruction_address_being_logged3||op->getAddr().getOffset()==instruction_address_being_logged4
+    ){
+      myfile << "cvn is constant\n";
+    }
+    if(
+      //op->getAddr().getOffset()==instruction_address_being_logged1||op->getAddr().getOffset()==instruction_address_being_logged2
+    op->getAddr().getOffset()==instruction_address_being_logged3||op->getAddr().getOffset()==instruction_address_being_logged4
+    ){
+      myfile2 << "cvn is constant\n";
+    }
+    myfile.close();
+    myfile2.close();
+#endif
   Varnode *lhs = op->getIn(0);
   if (!lhs->isWritten()) return 0;
+#ifdef DEBUG_MUQI_0x80
+  myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  if(op->getAddr().getOffset()==instruction_address_being_logged1||op->getAddr().getOffset()==instruction_address_being_logged2
+    //||op->getAddr().getOffset()==instruction_address_being_logged3||op->getAddr().getOffset()==instruction_address_being_logged4
+    ){
+      myfile << "lhs is not writtable\n";
+    }
+    if(
+      //op->getAddr().getOffset()==instruction_address_being_logged1||op->getAddr().getOffset()==instruction_address_being_logged2
+    op->getAddr().getOffset()==instruction_address_being_logged3||op->getAddr().getOffset()==instruction_address_being_logged4
+    ){
+      myfile2 << "lhs is not writtable\n";
+    }
+
+  myfile.close();
+  myfile2.close();
+#endif
   PcodeOp *leftop = lhs->getDef();
   Varnode *a;
   uintb newconst;
@@ -5779,7 +6266,7 @@ bool AddTreeState::checkMultTerm(Varnode *vn,PcodeOp *op,uintb treeCoeff)
   }
   return true;
 }
-
+#define DEBUG_MUQI_type_recovery_checkTerm
 /// If the given Varnode is a constant or multiplicative term, update
 /// totals. If the Varnode is additive, traverse its sub-terms.
 /// \param vn is the given Varnode term
@@ -5788,10 +6275,36 @@ bool AddTreeState::checkMultTerm(Varnode *vn,PcodeOp *op,uintb treeCoeff)
 bool AddTreeState::checkTerm(Varnode *vn,uintb treeCoeff)
 
 {
+
+  #ifdef DEBUG_MUQI_type_recovery_checkTerm
+    ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" Inside checkTerm: \n";
+    myfile2 <<" Inside checkTerm: \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
   uintb val;
   PcodeOp *def;
 
-  if (vn == ptr) return false;
+  if (vn == ptr) {
+     #ifdef DEBUG_MUQI_type_recovery_checkTerm
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" return false, since vn == ptr \n";
+    myfile2 <<" return false, since vn == ptr \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+    return false;}
   if (vn->isConstant()) {
     val = vn->getOffset() * treeCoeff;
     intb sval = (intb)val;
@@ -5809,6 +6322,17 @@ bool AddTreeState::checkTerm(Varnode *vn,uintb treeCoeff)
     if (treeCoeff != 1)
       isDistributeUsed = true;
     multsum += val;		// Add multiples of size into multsum
+    #ifdef DEBUG_MUQI_type_recovery_checkTerm
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" return false, inside vn->isConstant() \n";
+    myfile2 <<" return false, inside vn->isConstant() \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
     return false;
   }
   if (vn->isWritten()) {
@@ -5816,6 +6340,17 @@ bool AddTreeState::checkTerm(Varnode *vn,uintb treeCoeff)
     if (def->code() == CPUI_INT_ADD) // Recurse
       return spanAddTree(def, treeCoeff);
     if (def->code() == CPUI_COPY) { // Not finished reducing yet
+       #ifdef DEBUG_MUQI_type_recovery_checkTerm
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" return false, def->code() == CPUI_COPY \n";
+    myfile2 <<" return false, def->code() == CPUI_COPY \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
       valid = false;
       return false;
     }
@@ -5823,12 +6358,25 @@ bool AddTreeState::checkTerm(Varnode *vn,uintb treeCoeff)
       return checkMultTerm(vn, def, treeCoeff);
   }
   else if (vn->isFree()) {
+     #ifdef DEBUG_MUQI_type_recovery_checkTerm
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" return false, vn->isFree() \n";
+    myfile2 <<" return false, vn->isFree() \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
     valid = false;
     return false;
   }
   return true;
 }
 
+#define DEBUG_MUQI_type_recovery_spanAddTree
+
 /// Recursively walk the sub-tree from the given root.
 /// Terms that are a \e multiple of the base data-type size are accumulated either in
 /// the the sum of constant multiples or the container of non-constant multiples.
@@ -5845,26 +6393,151 @@ bool AddTreeState::spanAddTree(PcodeOp *op,uintb treeCoeff)
 {
   bool one_is_non,two_is_non;
 
+#ifdef DEBUG_MUQI_type_recovery_spanAddTree
+    ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" Inside spanAddTree: \n";
+    myfile2 <<" Inside spanAddTree: \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
   one_is_non = checkTerm(op->getIn(0),treeCoeff);
   if (!valid) return false;
   two_is_non = checkTerm(op->getIn(1),treeCoeff);
   if (!valid) return false;
 
+#ifdef DEBUG_MUQI_type_recovery_spanAddTree
+
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" one_is_non is: "<<one_is_non<< "\n";
+    myfile <<" two_is_non is: "<<two_is_non<< "\n";
+
+     myfile << "raw info ------------- :\n";
+     op->getIn(0)->printRaw(myfile);
+     myfile <<" \n-----------end raw \n";
+     myfile << "raw info ------------- :\n";
+     op->getIn(1)->printRaw(myfile);
+     myfile <<" \n-----------end raw \n";
+
+    myfile2 <<" one_is_non is: "<<one_is_non<< "\n";
+    myfile2 <<" two_is_non is: "<<two_is_non<< "\n";
+
+      myfile2 << "raw info ------------- :\n";
+     op->getIn(0)->printRaw(myfile2);
+     myfile2 <<" \n-----------end raw \n";
+     myfile2 << "raw info ------------- :\n";
+     op->getIn(1)->printRaw(myfile2);
+     myfile2 <<" \n-----------end raw \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+
   if (one_is_non&&two_is_non) return true;
-  if (one_is_non)
+  if (one_is_non){
     nonmult.push_back(op->getIn(0));
-  if (two_is_non)
+      #ifdef DEBUG_MUQI_type_recovery_spanAddTree
+
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile << "nonmult pushed (op->getIn(0)); \n";
+    myfile2 << "nonmult pushed (op->getIn(0)); \n";
+
+
+    myfile.close();
+    myfile2.close();
+#endif
+  }
+  if (two_is_non){
     nonmult.push_back(op->getIn(1));
+          #ifdef DEBUG_MUQI_type_recovery_spanAddTree
+
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile << "nonmult pushed (op->getIn(1)); \n";
+    myfile2 << "nonmult pushed (op->getIn(1)); \n";
+
+
+    myfile.close();
+    myfile2.close();
+#endif
+  }
+
+  #ifdef DEBUG_MUQI_type_recovery_spanAddTree
+
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile << "At least one of the sides contains multiples \n";
+    myfile2 << "At least one of the sides contains multiples \n";
+
+
+    myfile.close();
+    myfile2.close();
+#endif
   return false;		// At least one of the sides contains multiples
 }
 
+#define DEBUG_MUQI_type_recovery_calcSubtype
+
 /// Make final calcultions to determine if a pointer to a sub data-type of the base
 /// data-type is being calculated, which will result in a CPUI_PTRSUB being generated.
 void AddTreeState::calcSubtype(void)
 
 {
+
+#ifdef DEBUG_MUQI_type_recovery_calcSubtype
+    ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" Inside AddTreeState::calcSubtype: \n";
+    myfile <<" nonmultsum is: " << hex<< nonmultsum <<" \n";
+
+    myfile2 <<" Inside AddTreeState::calcSubtype: \n";
+    myfile2 <<" nonmultsum is: " << hex<<nonmultsum <<" \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   nonmultsum &= ptrmask;	// Make sure we are modulo ptr's space
   multsum &= ptrmask;
+
+#ifdef DEBUG_MUQI_type_recovery_calcSubtype
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" nonmultsum is: " << hex<< nonmultsum <<" \n";
+    myfile <<" multsum is: " <<hex<< multsum <<" \n";
+    myfile <<" ptrmask is: " << hex<<ptrmask <<" \n";
+    myfile <<" size is: " << size <<" \n";
+
+    myfile2 <<" nonmultsum is: " << hex<<nonmultsum <<" \n";
+    myfile2 <<" multsum is: " << hex<<multsum <<" \n";
+    myfile2 <<" ptrmask is: " << hex<<ptrmask <<" \n";
+    myfile2 <<" size is: " << size <<" \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   if (size == 0 || nonmultsum < size)
     offset = nonmultsum;
   else {
@@ -5887,9 +6560,36 @@ void AddTreeState::calcSubtype(void)
 	offset = (uintb)(snonmult + size);
     }
   }
+
+
   correct = nonmultsum - offset;
   nonmultsum = offset;
   multsum = (multsum + correct) & ptrmask;	// Some extra multiples of size
+
+
+
+#ifdef DEBUG_MUQI_type_recovery_calcSubtype
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" correct is: " << hex <<correct <<" \n";
+    myfile <<" nonmultsum is: " << hex<< nonmultsum <<" \n";
+    myfile <<" multsum is: " << hex<< multsum <<" \n";
+    myfile <<" offset is: " <<hex << offset <<" \n";
+    string temp;
+    metatype2string(baseType->getMetatype(),temp);
+    myfile << "baseType type is: "<< temp <<"\n";
+
+    myfile2 <<" correct is: " << hex <<correct <<" \n";
+    myfile2 <<" nonmultsum is: " << hex <<nonmultsum <<" \n";
+    myfile2 <<" multsum is: " << hex <<multsum <<" \n";
+    myfile2 <<" offset is: " << hex <<offset <<" \n";
+    myfile2 << "baseType type is: "<< temp <<"\n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   if (nonmult.empty()) {
     if ((multsum == 0) && multiple.empty()) {	// Is there anything at all
       valid = false;
@@ -5901,14 +6601,54 @@ void AddTreeState::calcSubtype(void)
     uintb nonmultbytes = AddrSpace::addressToByte(nonmultsum,ct->getWordSize()); // Convert to bytes
     uintb extra;
     uint4 arrayHint = findArrayHint();
+
+    #ifdef DEBUG_MUQI_type_recovery_calcSubtype
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" arrayHint is: " <<hex <<arrayHint <<" \n";
+    myfile <<" nonmultbytes is: "<<hex<<nonmultbytes<<"\n";
+    myfile << "ct->getWordSize() is: "<< ct->getWordSize() <<"\n";
+
+    myfile2 <<" arrayHint is: " <<hex <<arrayHint <<" \n";
+    myfile2 <<" nonmultbytes is: "<<hex<<nonmultbytes<<"\n";
+    myfile2 << "ct->getWordSize() is: "<< ct->getWordSize() <<"\n";
+    
+    myfile.close();
+    myfile2.close();
+    #endif
     // Get offset into mapped variable
     if (!hasMatchingSubType(nonmultbytes, arrayHint, &extra)) {
+        #ifdef DEBUG_MUQI_type_recovery_calcSubtype
+        myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+        myfile <<" No matchingsubtype \n";
+        myfile2 << " No matchingsubtype \n";
+
+        myfile.close();
+        myfile2.close();
+        #endif
+
       valid = false;		// Cannot find mapped variable but nonmult is non-empty
       return;
     }
     extra = AddrSpace::byteToAddress(extra, ct->getWordSize()); // Convert back to address units
     offset = (nonmultsum - extra) & ptrmask;
     isSubtype = true;
+        #ifdef DEBUG_MUQI_type_recovery_calcSubtype
+        myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+        myfile <<" offset is : " <<hex <<offset<<" \n";
+        myfile <<" extra is : " <<hex <<extra<<" \n";
+
+        myfile2 <<" offset is : " <<hex <<offset<<" \n";
+        myfile2 <<" extra is : " <<hex <<extra<<" \n";
+
+        myfile.close();
+        myfile2.close();
+        #endif
   }
   else if (baseType->getMetatype() == TYPE_STRUCT) {
     uintb nonmultbytes = AddrSpace::addressToByte(nonmultsum,ct->getWordSize()); // Convert to bytes
@@ -5934,6 +6674,11 @@ void AddTreeState::calcSubtype(void)
     // No struct or array, but nonmult is non-empty
     valid = false;			// There is substructure we don't know about
   }
+
+
+
+
+
 }
 
 /// Construct part of the tree that sums to a multiple of the base data-type size.
@@ -6007,19 +6752,87 @@ Varnode *AddTreeState::buildExtra(void)
   return resNode;
 }
 
+#define DEBUG_MUQI_type_recovery_AddTreeStateapply
 /// \return \b true if a transform was applied
 bool AddTreeState::apply(void)
 
 {
+
+#ifdef DEBUG_MUQI_type_recovery_AddTreeStateapply
+    ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" Inside AddTreeState::apply: \n";
+    myfile2 <<" Inside AddTreeState::apply: \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   spanAddTree(baseOp,1);
+
+#ifdef DEBUG_MUQI_type_recovery_AddTreeStateapply
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" After spanAddtree \n";
+    myfile2 <<" After spanAddtree  \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+
   if (!valid) return false;		// Were there any show stoppers
   if (distributeOp != (PcodeOp *)0 && !isDistributeUsed) {
     clear();
     preventDistribution = true;
     spanAddTree(baseOp,1);
+
+    #ifdef DEBUG_MUQI_type_recovery_AddTreeStateapply
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" After second spanAddtree \n";
+    myfile2 <<" After second spanAddtree  \n";
+
+    myfile.close();
+    myfile2.close();
+    #endif
+
   }
+
+     #ifdef DEBUG_MUQI_type_recovery_AddTreeStateapply
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" Before calcSubtype \n";
+    myfile2 <<" Before calcSubtype  \n";
+
+    myfile.close();
+    myfile2.close();
+    #endif
+
+
   calcSubtype();
   if (!valid) return false;
+       #ifdef DEBUG_MUQI_type_recovery_AddTreeStateapply
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" after first calcSubtype \n";
+    myfile2 <<" after first calcSubtype  \n";
+
+    myfile.close();
+    myfile2.close();
+    #endif
   while(valid && distributeOp != (PcodeOp *)0) {
     if (!data.distributeIntMultAdd(distributeOp)) {
       valid = false;
@@ -6037,6 +6850,18 @@ bool AddTreeState::apply(void)
     }
     calcSubtype();
   }
+  #ifdef DEBUG_MUQI_type_recovery_AddTreeStateapply
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" after while loop contains calcSubtype \n";
+    myfile2 <<" after while loop contains calcSubtype  \n";
+
+    myfile.close();
+    myfile2.close();
+    #endif
+
   if (!valid) {
     // Distribution transforms were made
     ostringstream s;
@@ -6045,10 +6870,26 @@ bool AddTreeState::apply(void)
     data.warningHeader(s.str());
     return true;
   }
+
+
+  #ifdef DEBUG_MUQI_type_recovery_AddTreeStateapply
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile <<" before buildTree \n";
+    myfile2 <<" before buildTree  \n";
+
+    myfile.close();
+    myfile2.close();
+    #endif
+
   buildTree();
   return true;
 }
 
+
+#define DEBUG_MUQI_type_recovery_AddTreeStatebuildTree
 /// The original ADD tree has been successfully spit into \e multiple and
 /// \e non-multiple pieces.  Rewrite the tree as a pointer expression, putting
 /// any \e multiple pieces into a PTRADD operation, creating a PTRSUB if a sub
@@ -6056,6 +6897,21 @@ bool AddTreeState::apply(void)
 void AddTreeState::buildTree(void)
 
 {
+#ifdef DEBUG_MUQI_type_recovery_AddTreeStateapply
+    ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile << "Inside AddTreeState::buildTree  \n";
+    myfile2 << "Inside AddTreeState::buildTree  \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+
   Varnode *multNode = buildMultiples();
   Varnode *extraNode = buildExtra();
   PcodeOp *newop = (PcodeOp *)0;
@@ -6064,19 +6920,65 @@ void AddTreeState::buildTree(void)
   if (multNode != (Varnode *)0) {
     newop = data.newOpBefore(baseOp,CPUI_PTRADD,ptr,multNode,data.newConstant(ptrsize,size));
     multNode = newop->getOut();
+      #ifdef DEBUG_MUQI_type_recovery_AddTreeStateapply
+
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+      myfile << "multNode != (Varnode *)0 is true  \n";
+      myfile2 << "multNode != (Varnode *)0 is true \n";
+
+      myfile.close();
+      myfile2.close();
+      #endif
   }
-  else
+  else{
     multNode = ptr;		// Zero multiple terms
 
+    #ifdef DEBUG_MUQI_type_recovery_AddTreeStateapply
+
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+      myfile << "multNode != (Varnode *)0 is false  \n";
+      myfile2 << "multNode != (Varnode *)0 is false \n";
+
+      myfile.close();
+      myfile2.close();
+      #endif
+  }
+
+
   // Create PTRSUB portion of operation
   if (isSubtype) {
     newop = data.newOpBefore(baseOp,CPUI_PTRSUB,multNode,data.newConstant(ptrsize,offset));
     multNode = newop->getOut();
+    #ifdef DEBUG_MUQI_type_recovery_AddTreeStateapply
+
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+      myfile << "isSubtype is true \n";
+      myfile2 << "isSubtype is true \n";
+
+      myfile << "ptrsize is: " <<ptrsize <<"\n";
+      myfile << "size is: " << size << "\n";
+      myfile << "offset is: "<< offset << "\n";
+
+      myfile2 << "ptrsize is: " <<ptrsize <<"\n";
+      myfile2 << "size is: " << size << "\n";
+      myfile2 << "offset is: "<< offset << "\n";
+
+      myfile.close();
+      myfile2.close();
+      #endif
   }
 
   // Add back in any remaining terms
-  if (extraNode != (Varnode *)0)
+  if (extraNode != (Varnode *)0){
     newop = data.newOpBefore(baseOp,CPUI_INT_ADD,multNode,extraNode);
+  }
+    
 
   if (newop == (PcodeOp *)0) {
     // This should never happen
@@ -6084,7 +6986,108 @@ void AddTreeState::buildTree(void)
     return;
   }
   data.opSetOutput(newop,baseOp->getOut());
+
   data.opDestroy(baseOp);
+
+  #ifdef DEBUG_MUQI_type_recovery_AddTreeStatebuildTree
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+
+   
+                  if(newop && newop->code()){
+
+                      myfile2 <<"newop name is : " << newop->getOpName() << "\n newop name is : "<< get_opname(newop->code())<<" \n address is "<< std::hex << newop->getAddr().getOffset() <<"\n";
+                      myfile2 << "seqnum is : "<< newop->getSeqNum().getTime() <<"\n";
+                      if (newop->getOut()){
+                          myfile2 << "var out of newop is: "<< newop->getOut()->getOffset() << "\n";
+                          myfile2 << "addr of var is: "<< newop->getOut()->getAddr().getOffset() <<"\n";
+                          myfile2 << "name of addr space is: " <<newop->getOut()->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(newop->getOut()->getType()){
+                              metatype2string(newop->getOut()->getType()->getMetatype(),temp);
+                              myfile2 << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile2 << "var's type is: NOT known\n";
+                          }
+                          myfile2 << "raw info ------------- :\n";
+                          newop->getOut()->printRaw(myfile2);
+                          myfile2 <<" \n-----------end raw \n";
+                      }
+                      for (int i = 0; i <newop->numInput(); i ++){
+                        if (newop->getIn(i)){
+                          myfile2 << "var"<< i<<" of newop is: "<< newop->getIn(i)->getOffset() << "\n";
+                          myfile2 << "addr of var is: "<< newop->getIn(i)->getAddr().getOffset() <<"\n";
+                          myfile2 << "name of addr space is: " <<newop->getIn(i)->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(newop->getIn(i)->getType()){
+                              metatype2string(newop->getIn(i)->getType()->getMetatype(),temp);
+                              myfile2 << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile2 << "var's type is: NOT known\n";
+                          }
+                          myfile2 << "raw info ------------- :\n";
+                          newop->getIn(i)->printRaw(myfile2);
+                          myfile2 <<" \n-----------end raw \n";
+                        }
+                      }
+                  
+                  }
+                  else{
+                    myfile2 << "newop is null \n";
+                  }
+
+                  if(newop && newop->code()){
+
+                      myfile <<"newop name is : " << newop->getOpName() << "\n newop name is : "<< get_opname(newop->code())<<" \n address is "<< std::hex << newop->getAddr().getOffset() <<"\n";
+                      myfile << "seqnum is : "<< newop->getSeqNum().getTime() <<"\n";
+                      if (newop->getOut()){
+                          myfile << "var out of newop is: "<< newop->getOut()->getOffset() << "\n";
+                          myfile << "addr of var is: "<< newop->getOut()->getAddr().getOffset() <<"\n";
+                          myfile << "name of addr space is: " <<newop->getOut()->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(newop->getOut()->getType()){
+                              metatype2string(newop->getOut()->getType()->getMetatype(),temp);
+                              myfile << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile << "var's type is: NOT known\n";
+                          }
+                          myfile << "raw info ------------- :\n";
+                          newop->getOut()->printRaw(myfile);
+                          myfile <<" \n-----------end raw \n";
+                      }
+                      for (int i = 0; i <newop->numInput(); i ++){
+                        if (newop->getIn(i)){
+                          myfile << "var"<< i<<" of newop is: "<< newop->getIn(i)->getOffset() << "\n";
+                          myfile << "addr of var is: "<< newop->getIn(i)->getAddr().getOffset() <<"\n";
+                          myfile << "name of addr space is: " <<newop->getIn(i)->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(newop->getIn(i)->getType()){
+                              metatype2string(newop->getIn(i)->getType()->getMetatype(),temp);
+                              myfile << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile << "var's type is: NOT known\n";
+                          }
+                          myfile << "raw info ------------- :\n";
+                          newop->getIn(i)->printRaw(myfile);
+                          myfile <<" \n-----------end raw \n";
+                        }
+                      }
+                  
+                  }
+                  else{
+                    myfile << "newop is null \n";
+                  }
+
+
+    myfile.close();
+    myfile2.close();
+    #endif
+
+
+
+
 }
 
 /// \brief Verify that given PcodeOp occurs at the bottom of the CPUI_INT_ADD tree
@@ -6101,6 +7104,72 @@ bool RulePtrArith::verifyAddTreeBottom(PcodeOp *op,int4 slot)
   Varnode *vn = op->getOut();
   Varnode *ptrbase = op->getIn(slot);
   list<PcodeOp *>::const_iterator iter=vn->beginDescend();
+
+#ifdef DEBUG_MUQI_type_recovery_verifyAddTreeBottom
+    ofstream myfile;
+    ofstream myfile2;
+
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    list<PcodeOp *>::const_iterator it;
+    myfile <<" Inside verifyAddTreeBottom: \n";
+
+   for (it = vn->beginDescend(); it != vn->endDescend(); ++it){
+                  myfile << (*it)->getAddr().getOffset() <<"\n"; 
+                  myfile <<"(*it) name is : " << (*it)->getOpName() << "\n (*it) name is : "<< get_opname((*it)->code())<<" \n address is "<< std::hex << (*it)->getAddr().getOffset() <<"\n";
+                  myfile << "seqnum is : "<< (*it)->getSeqNum().getTime() <<"\n";
+                 
+                  if ((*it)->getOut()){
+                      myfile << "var out of (*it) is: "<< (*it)->getOut()->getOffset() << "\n";
+                      myfile << "addr of var is: "<< (*it)->getOut()->getAddr().getOffset() <<"\n";
+                      myfile << "name of addr space is: " <<(*it)->getOut()->getSpace()->getName() <<"\n";
+                      string temp;
+                      if((*it)->getOut()->getType()){
+                          metatype2string((*it)->getOut()->getType()->getMetatype(),temp);
+                          myfile << "var's type is: "<< temp <<"\n";
+                      }else{
+                          myfile << "var's type is: NOT known\n";
+                      }
+                      myfile << "raw info ------------- :\n";
+                      (*it)->getOut()->printRaw(myfile);
+                      myfile <<" \n-----------end raw \n";
+                  } 
+              }
+
+    myfile2 <<" Inside verifyAddTreeBottom: \n";
+   for (it = vn->beginDescend(); it != vn->endDescend(); ++it){
+                  myfile2 << (*it)->getAddr().getOffset() <<"\n"; 
+                  myfile2 <<"(*it) name is : " << (*it)->getOpName() << "\n (*it) name is : "<< get_opname((*it)->code())<<" \n address is "<< std::hex << (*it)->getAddr().getOffset() <<"\n";
+                  myfile2 << "seqnum is : "<< (*it)->getSeqNum().getTime() <<"\n";
+                 
+                  if ((*it)->getOut()){
+                      myfile2 << "var out of (*it) is: "<< (*it)->getOut()->getOffset() << "\n";
+                      myfile2 << "addr of var is: "<< (*it)->getOut()->getAddr().getOffset() <<"\n";
+                      myfile2 << "name of addr space is: " <<(*it)->getOut()->getSpace()->getName() <<"\n";
+                      string temp;
+                      if((*it)->getOut()->getType()){
+                          metatype2string((*it)->getOut()->getType()->getMetatype(),temp);
+                          myfile2 << "var's type is: "<< temp <<"\n";
+                      }else{
+                          myfile2 << "var's type is: NOT known\n";
+                      }
+                      myfile2 << "raw info ------------- :\n";
+                      (*it)->getOut()->printRaw(myfile2);
+                      myfile2 <<" \n-----------end raw \n";
+                  }   
+              }
+
+    myfile << "size of desend of vn's list is :" << vn->sizeofDescend() <<"\n";
+    myfile2 << "size of desend of vn's list is :" << vn->sizeofDescend() <<"\n";          
+    
+    myfile << "iter == vn->endDescend() is :" << bool (iter == vn->endDescend()) <<"\n";
+    myfile2 << "iter == vn->endDescend() is :" << bool (iter == vn->endDescend()) <<"\n";
+
+    myfile.close();
+    myfile2.close();
+   #endif
+
+
   OpCode opc;
   if (iter == vn->endDescend()) return false; // Don't bother if no descendants
   PcodeOp *lowerop = *iter++;
@@ -6158,6 +7227,25 @@ void RulePtrArith::getOpList(vector<uint4> &oplist) const
 int4 RulePtrArith::applyOp(PcodeOp *op,Funcdata &data)
 
 {
+    ofstream myfile;
+    ofstream myfile2;
+  #ifdef DEBUG_MUQI_type_recovery_RulePtrArith
+            myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "Inside RulePtrArith::applyOp \n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "Inside RulePtrArith::applyOp \n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+  #endif
   int4 slot;
   const Datatype *ct = (const Datatype *)0; // Unnecessary initialization
 
@@ -6173,7 +7261,50 @@ int4 RulePtrArith::applyOp(PcodeOp *op,Funcdata &data)
   const TypePointer *tp = (const TypePointer *) ct;
   ct = tp->getPtrTo();		// Type being pointed to
   int4 unitsize = AddrSpace::addressToByteInt(1,tp->getWordSize());
+
+    #ifdef DEBUG_MUQI_type_recovery_RulePtrArith
+            myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "slot is: "<<slot<<"\n";
+                  myfile << "Type being pointed to is: " << ct->getName() <<"\n";
+                  myfile << "unitsize is: "<< unitsize <<"\n";
+                  myfile << "ct->getSize() is: " << ct->getSize() <<"\n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "slot is: "<<slot<<"\n";
+                  myfile2 << "Type being pointed to is: " << ct->getName() <<"\n";
+                  myfile2 << "unitsize is: "<< unitsize <<"\n";
+                  myfile2 << "ct->getSize() is: " << ct->getSize() <<"\n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+    #endif
+
   if (ct->getSize() == unitsize) { // Degenerate case
+    #ifdef DEBUG_MUQI_type_recovery_RulePtrArith
+            myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "Inside Degenerate case \n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "Inside Degenerate case\n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+    #endif
+
     vector<Varnode *> newparams;
     newparams.push_back( op->getIn(slot) );
     newparams.push_back( op->getIn(1-slot) );
@@ -6190,6 +7321,26 @@ int4 RulePtrArith::applyOp(PcodeOp *op,Funcdata &data)
   AddTreeState state(data,op,slot);
   if (!state.apply())
     return 0;
+
+
+      #ifdef DEBUG_MUQI_type_recovery_RulePtrArith
+            myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "Inside after apply of addtreestate \n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "Inside after apply of addtreestate\n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+    #endif
+
   return 1;
 }
 
@@ -6271,27 +7422,299 @@ void RulePushPtr::getOpList(vector<uint4> &oplist) const
 int4 RulePushPtr::applyOp(PcodeOp *op,Funcdata &data)
 
 {
+
   int4 i,j;
   PcodeOp *decop,*newop;
   Varnode *vn;
   Varnode *vni = (Varnode *)0;
   const Datatype *ct;
 
-  if (!data.isTypeRecoveryOn()) return 0;
+
+  ofstream myfile;
+  ofstream myfile2;
+    #ifdef DEBUG_MUQI_type_recovery_pushptr
+    int instruction_address_being_logged = 4198786; //401182 -> 4198786  40118d->4198797 401191->4198801 401196->4198806 401199->4198809
+
+    //int instruction_address_being_logged2 = 4198801; 
+    int instruction_address_being_logged2 = 4198768;
+    int instruction_address_being_logged5 = 4198768;  //401170->4198768
+
+   
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+      
+      if(op->getAddr().getOffset()==instruction_address_being_logged
+      ){
+            myfile << "inside RulePushPtr::applyOp: \n";
+            if(op && op->code()){
+
+                myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+                myfile << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+                myfile << "data physical address is: " <<hex<<&data <<"\n";
+                myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+                myfile << "data name is: " << data.getName() <<"\n";
+                 if (op->getOut()){
+                    myfile << "var out of op is: "<< op->getOut()->getOffset() << "\n";
+                    myfile << "addr of var is: "<< op->getOut()->getAddr().getOffset() <<"\n";
+                    myfile << "name of addr space is: " <<op->getOut()->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getOut()->getType()){
+                        metatype2string(op->getOut()->getType()->getMetatype(),temp);
+                        myfile << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile << "var's type is: NOT known\n";
+                    }
+                    myfile << "raw info ------------- :\n";
+                    op->getOut()->printRaw(myfile);
+                    myfile <<" \n-----------end raw \n";
+                }
+                for (int i = 0; i <op->numInput(); i ++){
+                  if (op->getIn(i)){
+                    myfile << "var"<< i<<" of op is: "<< op->getIn(i)->getOffset() << "\n";
+                    myfile << "addr of var is: "<< op->getIn(i)->getAddr().getOffset() <<"\n";
+                    myfile << "name of addr space is: " <<op->getIn(i)->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getIn(i)->getType()){
+                        metatype2string(op->getIn(i)->getType()->getMetatype(),temp);
+                        myfile << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile << "var's type is: NOT known\n";
+                    }
+                    myfile << "raw info ------------- :\n";
+                    op->getIn(i)->printRaw(myfile);
+                    myfile <<" \n-----------end raw \n";
+                  }
+                }
+            
+            }
+            else{
+              myfile << "op is null \n";
+            }
+      }
+      if(op->getAddr().getOffset()==instruction_address_being_logged2
+      ){
+            myfile2 << "inside RulePushPtr::applyOp: \n";
+            if(op && op->code()){
+
+                myfile2 <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+                myfile2 << "seqnum is : "<< op->getSeqNum().getTime() <<"\n";
+                myfile2 << "data physical address is: " <<hex<<&data <<"\n";
+                myfile2 << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+                myfile2 << "data name is: " << data.getName() <<"\n";
+                if (op->getOut()){
+                    myfile2 << "var out of op is: "<< op->getOut()->getOffset() << "\n";
+                    myfile2 << "addr of var is: "<< op->getOut()->getAddr().getOffset() <<"\n";
+                    myfile2 << "name of addr space is: " <<op->getOut()->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getOut()->getType()){
+                        metatype2string(op->getOut()->getType()->getMetatype(),temp);
+                        myfile2 << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile2 << "var's type is: NOT known\n";
+                    }
+                    myfile2 << "raw info ------------- :\n";
+                    op->getOut()->printRaw(myfile2);
+                    myfile2 <<" \n-----------end raw \n";
+                }
+                for (int i = 0; i <op->numInput(); i ++){
+                  if (op->getIn(i)){
+                    myfile2 << "var"<< i<<" of op is: "<< op->getIn(i)->getOffset() << "\n";
+                    myfile2 << "addr of var is: "<< op->getIn(i)->getAddr().getOffset() <<"\n";
+                    myfile2 << "name of addr space is: " <<op->getIn(i)->getSpace()->getName() <<"\n";
+                    string temp;
+                    if(op->getIn(i)->getType()){
+                        metatype2string(op->getIn(i)->getType()->getMetatype(),temp);
+                        myfile2 << "var's type is: "<< temp <<"\n";
+                    }else{
+                        myfile2 << "var's type is: NOT known\n";
+                    }
+                    myfile2 << "raw info ------------- :\n";
+                    op->getIn(i)->printRaw(myfile2);
+                    myfile2 <<" \n-----------end raw \n";
+
+                  }
+                }
+            
+            }
+            else{
+              myfile2 << "op is null \n";
+            }
+      }
+      
+      myfile.close();
+      myfile2.close();
+      #endif
+  if (!data.isTypeRecoveryOn()) {
+     #ifdef DEBUG_MUQI_type_recovery_pushptr 
+              myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << " exit in isTypeRecoveryOn \n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << " exit in isTypeRecoveryOn \n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+        #endif
+
+    return 0;
+  }
+
+        #ifdef DEBUG_MUQI_type_recovery_pushptr 
+              myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "step 2 \n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "step 2 \n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+        #endif
+
   for(i=0;i<op->numInput();++i) { // Search for pointer type
     vni = op->getIn(i);
     ct = vni->getType();
     if (ct->getMetatype() == TYPE_PTR) break;
   }
+
+  //log here to print i, variable type and vn->getdef, check whether it is RAXx01 triggered this type recovery.
+  #ifdef DEBUG_MUQI_type_recovery_pushptr 
+              myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "i is: "<< i<< "\n";
+                  myfile << "vni's ops address is: "<< std::hex << op->getAddr().getOffset() <<"\n";
+                  string temp;
+                  metatype2string(ct->getMetatype(),temp);
+                  myfile << "vni's type is: "<< temp <<"\n";
+                  myfile << "raw info ------------- :\n";
+                  vni->printRaw(myfile);
+                  myfile <<" \n-----------end raw \n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "i is: "<< i<< "\n";
+                  myfile2 << "vni's ops address is: "<< std::hex << op->getAddr().getOffset() <<"\n";
+                  string temp;
+                  metatype2string(ct->getMetatype(),temp);
+                  myfile2 << "vni's type is: "<< temp <<"\n";
+                  myfile2 << "raw info ------------- :\n";
+                  vni->printRaw(myfile2);
+                  myfile2 <<" \n-----------end raw \n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+  #endif
+
+
   if (i == op->numInput()) return 0;
   if ((i==0)&&(op->getIn(1)->getType()->getMetatype() == TYPE_PTR)) return 0;	// Prevent infinite loops
-  
+        #ifdef DEBUG_MUQI_type_recovery_pushptr 
+              myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "step 3 \n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "step 3 \n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+        #endif
   vn = op->getOut();
   if ((decop=vn->loneDescend()) == (PcodeOp *)0) return 0;
+
+        #ifdef DEBUG_MUQI_type_recovery_pushptr 
+              myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "step 4 \n";
+                  //myfile << "decop->code()  is: "<< get_opname(decop->code()) <<"\n";
+                  myfile <<"decop name is : " << decop->getOpName() << "\n decop name is : "<< get_opname(decop->code())<<" \n address is "<< std::hex << decop->getAddr().getOffset() <<"\n";
+                  myfile << "seqnum is : "<< decop->getSeqNum().getTime() <<"\n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "step 4 \n";
+                  myfile2 <<"decop name is : " << decop->getOpName() << "\n decop name is : "<< get_opname(decop->code())<<" \n address is "<< std::hex << decop->getAddr().getOffset() <<"\n";
+                  myfile2 << "seqnum is : "<< decop->getSeqNum().getTime() <<"\n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+        #endif
+//muqi check here!!!!
+/*      if(op->getAddr().getOffset()==instruction_address_being_logged){
+         
+      }else {
+        if (decop->code() != CPUI_INT_ADD) return 0;
+      }
+      */
   if (decop->code() != CPUI_INT_ADD) return 0;
+        #ifdef DEBUG_MUQI_type_recovery_pushptr 
+              myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "step 5 \n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "step 5 \n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+        #endif
 
   j = decop->getSlot(vn);
   if (decop->getIn(1-j)->getType()->getMetatype() == TYPE_PTR) return 0; // Prevent infinite loops
+          #ifdef DEBUG_MUQI_type_recovery_pushptr 
+              myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "step 6 \n";
+            }
+
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "step 6 \n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+        #endif
 
   Varnode *vnadd1 = decop->getIn(1-j);
   Varnode *vnadd2 = op->getIn(1-i);
@@ -6299,7 +7722,42 @@ int4 RulePushPtr::applyOp(PcodeOp *op,Funcdata &data)
 
   // vni and vnadd2 are propagated, so they shouldn't be free
   if (vnadd2->isFree() && (!vnadd2->isConstant())) return 0;
+            #ifdef DEBUG_MUQI_type_recovery_pushptr 
+              myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "step 7 \n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "step 7 \n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+        #endif
   if (vni->isFree() && (!vni->isConstant())) return 0;
+            #ifdef DEBUG_MUQI_type_recovery_pushptr 
+              myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "step 8 \n";
+            }
+
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "step 8 \n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+        #endif
 
   newop = data.newOp(2,decop->getAddr());
   data.opSetOpcode(newop,CPUI_INT_ADD);
@@ -6312,6 +7770,220 @@ int4 RulePushPtr::applyOp(PcodeOp *op,Funcdata &data)
   data.opSetInput(newop,vnadd2,1);
 
   data.opInsertBefore(newop,decop);
+                #ifdef DEBUG_MUQI_type_recovery_pushptr 
+              myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+            myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+            
+            if(decop->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "after RulePushPtr::applyOp: --decomp--  \n";
+                  if(decop && decop->code()){
+
+                      myfile <<"p name is : " << decop->getOpName() << "\n decop name is : "<< get_opname(decop->code())<<" \n address is "<< std::hex << decop->getAddr().getOffset() <<"\n";
+                      myfile << "seqnum is : "<< decop->getSeqNum().getTime() <<"\n";
+                      myfile << "data physical address is: " <<hex<<&data <<"\n";
+                      myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+                      myfile << "data name is: " << data.getName() <<"\n";
+                      if (decop->getOut()){
+                          myfile << "var out of decop is: "<< decop->getOut()->getOffset() << "\n";
+                          myfile << "addr of var is: "<< decop->getOut()->getAddr().getOffset() <<"\n";
+                          myfile << "name of addr space is: " <<decop->getOut()->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(decop->getOut()->getType()){
+                              metatype2string(decop->getOut()->getType()->getMetatype(),temp);
+                              myfile << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile << "var's type is: NOT known\n";
+                          }
+                          myfile << "raw info ------------- :\n";
+                          decop->getOut()->printRaw(myfile);
+                          myfile <<" \n-----------end raw \n";
+                      }
+                      for (int i = 0; i <decop->numInput(); i ++){
+                        if (decop->getIn(i)){
+                          myfile << "var"<< i<<" of decop is: "<< decop->getIn(i)->getOffset() << "\n";
+                          myfile << "addr of var is: "<< decop->getIn(i)->getAddr().getOffset() <<"\n";
+                          myfile << "name of addr space is: " <<decop->getIn(i)->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(decop->getIn(i)->getType()){
+                              metatype2string(decop->getIn(i)->getType()->getMetatype(),temp);
+                              myfile << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile << "var's type is: NOT known\n";
+                          }
+                          myfile << "raw info ------------- :\n";
+                          decop->getIn(i)->printRaw(myfile);
+                          myfile <<" \n-----------end raw \n";
+                        }
+                      }
+                  
+                  }
+                  else{
+                    myfile << "decop is null \n";
+                  }
+            }
+
+            if(decop->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "after RulePushPtr::applyOp: --decomp--  \n";
+                  if(decop && decop->code()){
+
+                      myfile2 <<"p name is : " << decop->getOpName() << "\n decop name is : "<< get_opname(decop->code())<<" \n address is "<< std::hex << decop->getAddr().getOffset() <<"\n";
+                      myfile2 << "seqnum is : "<< decop->getSeqNum().getTime() <<"\n";
+                      myfile2 << "data physical address is: " <<hex<<&data <<"\n";
+                      myfile2 << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+                      myfile2 << "data name is: " << data.getName() <<"\n";
+                      if (decop->getOut()){
+                          myfile2 << "var out of decop is: "<< decop->getOut()->getOffset() << "\n";
+                          myfile2 << "addr of var is: "<< decop->getOut()->getAddr().getOffset() <<"\n";
+                          myfile2 << "name of addr space is: " <<decop->getOut()->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(decop->getOut()->getType()){
+                              metatype2string(decop->getOut()->getType()->getMetatype(),temp);
+                              myfile2 << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile2 << "var's type is: NOT known\n";
+                          }
+                          myfile2 << "raw info ------------- :\n";
+                          decop->getOut()->printRaw(myfile2);
+                          myfile2 <<" \n-----------end raw \n";
+                      }
+                      for (int i = 0; i <decop->numInput(); i ++){
+                        if (decop->getIn(i)){
+                          myfile2 << "var"<< i<<" of decop is: "<< decop->getIn(i)->getOffset() << "\n";
+                          myfile2 << "addr of var is: "<< decop->getIn(i)->getAddr().getOffset() <<"\n";
+                          myfile2 << "name of addr space is: " <<decop->getIn(i)->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(decop->getIn(i)->getType()){
+                              metatype2string(decop->getIn(i)->getType()->getMetatype(),temp);
+                              myfile2 << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile2 << "var's type is: NOT known\n";
+                          }
+                          myfile2 << "raw info ------------- :\n";
+                          decop->getIn(i)->printRaw(myfile2);
+                          myfile2 <<" \n-----------end raw \n";
+                        }
+                      }
+                  
+                  }
+                  else{
+                    myfile2 << "decop is null \n";
+                  }
+            }
+
+
+            if(newop->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "after RulePushPtr::applyOp: --newop--  \n";
+                  if(newop && newop->code()){
+
+                      myfile <<"p name is : " << newop->getOpName() << "\n newop name is : "<< get_opname(newop->code())<<" \n address is "<< std::hex << newop->getAddr().getOffset() <<"\n";
+                      myfile << "seqnum is : "<< newop->getSeqNum().getTime() <<"\n";
+                      myfile << "data physical address is: " <<hex<<&data <<"\n";
+                      myfile << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+                      myfile << "data name is: " << data.getName() <<"\n";
+                      if (newop->getOut()){
+                          myfile << "var out of newop is: "<< newop->getOut()->getOffset() << "\n";
+                          myfile << "addr of var is: "<< newop->getOut()->getAddr().getOffset() <<"\n";
+                          myfile << "name of addr space is: " <<newop->getOut()->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(newop->getOut()->getType()){
+                              metatype2string(newop->getOut()->getType()->getMetatype(),temp);
+                              myfile << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile << "var's type is: NOT known\n";
+                          }
+                          myfile << "raw info ------------- :\n";
+                          newop->getOut()->printRaw(myfile);
+                          myfile <<" \n-----------end raw \n";
+                      }
+                      for (int i = 0; i <newop->numInput(); i ++){
+                        if (newop->getIn(i)){
+                          myfile << "var"<< i<<" of newop is: "<< newop->getIn(i)->getOffset() << "\n";
+                          myfile << "addr of var is: "<< newop->getIn(i)->getAddr().getOffset() <<"\n";
+                          myfile << "name of addr space is: " <<newop->getIn(i)->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(newop->getIn(i)->getType()){
+                              metatype2string(newop->getIn(i)->getType()->getMetatype(),temp);
+                              myfile << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile << "var's type is: NOT known\n";
+                          }
+                          myfile << "raw info ------------- :\n";
+                          newop->getIn(i)->printRaw(myfile);
+                          myfile <<" \n-----------end raw \n";
+                        }
+                      }
+                  
+                  }
+                  else{
+                    myfile << "newop is null \n";
+                  }
+            }
+
+            if(newop->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "after RulePushPtr::applyOp: --newop--  \n";
+                  if(newop && newop->code()){
+
+                      myfile2 <<"p name is : " << newop->getOpName() << "\n newop name is : "<< get_opname(newop->code())<<" \n address is "<< std::hex << newop->getAddr().getOffset() <<"\n";
+                      myfile2 << "seqnum is : "<< newop->getSeqNum().getTime() <<"\n";
+                      myfile2 << "data physical address is: " <<hex<<&data <<"\n";
+                      myfile2 << "data address is: " << std::hex << data.getAddress().getOffset() << "\n";
+                      myfile2 << "data name is: " << data.getName() <<"\n";
+                      if (newop->getOut()){
+                          myfile2 << "var out of newop is: "<< newop->getOut()->getOffset() << "\n";
+                          myfile2 << "addr of var is: "<< newop->getOut()->getAddr().getOffset() <<"\n";
+                          myfile2 << "name of addr space is: " <<newop->getOut()->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(newop->getOut()->getType()){
+                              metatype2string(newop->getOut()->getType()->getMetatype(),temp);
+                              myfile2 << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile2 << "var's type is: NOT known\n";
+                          }
+                          myfile2 << "raw info ------------- :\n";
+                          newop->getOut()->printRaw(myfile2);
+                          myfile2 <<" \n-----------end raw \n";
+                      }
+                      for (int i = 0; i <newop->numInput(); i ++){
+                        if (newop->getIn(i)){
+                          myfile2 << "var"<< i<<" of newop is: "<< newop->getIn(i)->getOffset() << "\n";
+                          myfile2 << "addr of var is: "<< newop->getIn(i)->getAddr().getOffset() <<"\n";
+                          myfile2 << "name of addr space is: " <<newop->getIn(i)->getSpace()->getName() <<"\n";
+                          string temp;
+                          if(newop->getIn(i)->getType()){
+                              metatype2string(newop->getIn(i)->getType()->getMetatype(),temp);
+                              myfile2 << "var's type is: "<< temp <<"\n";
+                          }else{
+                              myfile2 << "var's type is: NOT known\n";
+                          }
+                          myfile2 << "raw info ------------- :\n";
+                          newop->getIn(i)->printRaw(myfile2);
+                          myfile2 <<" \n-----------end raw \n";
+                        }
+                      }
+                  
+                  }
+                  else{
+                    myfile2 << "newop is null \n";
+                  }
+            }
+
+            if(op->getAddr().getOffset()==instruction_address_being_logged
+            ){
+                  myfile << "step 9 \n";
+            }
+            if(op->getAddr().getOffset()==instruction_address_being_logged2
+            ){
+                  myfile2 << "step 9 \n";
+            }
+            myfile.close();
+            myfile2.close();
+        
+        #endif
 
   return 1;
 }
@@ -7910,10 +9582,46 @@ void RuleSubvarZext::getOpList(vector<uint4> &oplist) const
 int4 RuleSubvarZext::applyOp(PcodeOp *op,Funcdata &data)
 
 {
+#ifdef DEBUG_MUQI_0x80
+    int instruction_address_being_logged5 = 4198816; //004011a0->4198816 004011b4->4198836
+    int instruction_address_being_logged6 = 4198836; 
+    ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+#endif
+
   Varnode *vn = op->getOut();
   Varnode *invn = op->getIn(0);
   uintb mask = calc_mask(invn->getSize());
 
+#ifdef DEBUG_MUQI_0x80
+  if(op->getAddr().getOffset()==instruction_address_being_logged5){
+    myfile<<"Inside RuleSubvarZext::applyOp "<<"\n";
+    myfile<<"mask is: "<<hex<<mask<<"\n";
+    myfile<<"vn name is: " << vn->getAddr().getSpace()->getName() <<"\n";
+    myfile<<"vn offset is: "<< vn->getAddr().getOffset()<<"\n";
+    myfile<<"invn name is: " << invn->getAddr().getSpace()->getName()<<"\n";
+    myfile<<"invn offset is: "<< invn->getAddr().getOffset()<<"\n";
+    myfile<<"direct vn address is: " << hex<<vn<<"\n";
+    myfile<<"direct invn address is: "<< hex<<invn<<"\n";
+    myfile<<"invn->isPtrFlow() is: "<<invn->isPtrFlow()<<"\n";
+    
+  }
+  if(op->getAddr().getOffset()==instruction_address_being_logged6){
+    myfile2<<"Inside RuleSubvarZext::applyOp "<<"\n";
+    myfile2<<"mask is: "<<hex<<mask<<"\n";
+    myfile2<<"vn name is: " << vn->getAddr().getSpace()->getName()<<"\n";
+    myfile2<<"vn offset is: "<< vn->getAddr().getOffset()<<"\n";
+    myfile2<<"invn name is: " << invn->getAddr().getSpace()->getName()<<"\n";
+    myfile2<<"invn offset is: "<< invn->getAddr().getOffset()<<"\n";
+    myfile2<<"direct vn address is: " << hex<<vn<<"\n";
+    myfile2<<"direct invn address is: "<< hex<<invn<<"\n";
+    myfile2<<"invn->isPtrFlow() is: "<<invn->isPtrFlow()<<"\n";
+  }
+  myfile.close();
+  myfile2.close();
+#endif
   SubvariableFlow subflow(&data,vn,mask,invn->isPtrFlow(),false,false);
   if (!subflow.doTrace()) return 0;
   subflow.doReplacement();
@@ -7931,12 +9639,58 @@ void RuleSubvarSext::getOpList(vector<uint4> &oplist) const
 int4 RuleSubvarSext::applyOp(PcodeOp *op,Funcdata &data)
 
 {
+
+#ifdef DEBUG_MUQI_0x80
+    ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+#endif
   Varnode *vn = op->getOut();
   Varnode *invn = op->getIn(0);
   uintb mask = calc_mask(invn->getSize());
-
+#ifdef DEBUG_MUQI_0x80
+  if(op->getAddr().getOffset()==instruction_address_being_logged5){
+    myfile<<"Inside  RuleSubvarSext::applyOp "<<"\n";
+    myfile<<"mask is: "<<hex<<mask<<"\n";
+    myfile<<"vn name is: " << vn->getAddr().getSpace()->getName() <<"\n";
+    myfile<<"vn offset is: "<< vn->getAddr().getOffset()<<"\n";
+    myfile<<"invn name is: " << invn->getAddr().getSpace()->getName()<<"\n";
+    myfile<<"invn offset is: "<< invn->getAddr().getOffset()<<"\n";
+    
+  }
+  if(op->getAddr().getOffset()==instruction_address_being_logged6){
+    myfile2<<"Inside  RuleSubvarSext::applyOp "<<"\n";
+    myfile2<<"mask is: "<<hex<<mask<<"\n";
+    myfile2<<"vn name is: " << vn->getAddr().getSpace()->getName()<<"\n";
+    myfile2<<"vn offset is: "<< vn->getAddr().getOffset()<<"\n";
+    myfile2<<"invn name is: " << invn->getAddr().getSpace()->getName()<<"\n";
+    myfile2<<"invn offset is: "<< invn->getAddr().getOffset()<<"\n";
+  }
+#endif
   SubvariableFlow subflow(&data,vn,mask,isaggressive,true,false);
-  if (!subflow.doTrace()) return 0;
+  if (!subflow.doTrace()) {
+#ifdef DEBUG_MUQI_0x80
+    if(op->getAddr().getOffset()==instruction_address_being_logged5){
+      myfile<<"do trace return here\n";
+    }
+    if(op->getAddr().getOffset()==instruction_address_being_logged6){
+      myfile2<<"do trace return here\n";
+    }
+    myfile.close();
+    myfile2.close();
+#endif
+    return 0;}
+#ifdef DEBUG_MUQI_0x80
+  if(op->getAddr().getOffset()==instruction_address_being_logged5){
+      myfile<<"doReplacement inside\n";
+    }
+    if(op->getAddr().getOffset()==instruction_address_being_logged6){
+      myfile2<<"doReplacement inside\n";
+    }
+    myfile.close();
+    myfile2.close();  
+#endif
   subflow.doReplacement();
   return 1;
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
index f8c1580a8..3c779a0b3 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
@@ -775,6 +775,19 @@ int4 ConstructTpl::fillinBuild(vector<int4> &check,AddrSpace *const_space)
   vector<OpTpl *>::iterator iter;
   OpTpl *op;
   VarnodeTpl *indvn;
+  
+#ifdef DEBUG_MUQI_0x80
+    ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "Inside ConstructTpl::fillinBuild \n ";
+    myfile.close();
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "Inside ConstructTpl::fillinBuild \n ";
+    myfile2.close();
+#endif
 
   for(iter=vec.begin();iter!=vec.end();++iter) {
     op = *iter;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc
index bbb3f2ca7..be8f20ca1 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/subflow.cc
@@ -49,6 +49,7 @@ int4 SubvariableFlow::doesAndClear(PcodeOp *andop,uintb mask)
   return -1;
 }
 
+//#define DEBUG_MUQI_sign_extend
 /// \brief Add the given Varnode as a new node in the logical subgraph
 ///
 /// A new ReplaceVarnode object is created, representing the given Varnode within
@@ -64,6 +65,20 @@ SubvariableFlow::ReplaceVarnode *SubvariableFlow::setReplacement(Varnode *vn,uin
 
 {
   ReplaceVarnode *res;
+
+#ifdef DEBUG_MUQI_0x80
+    ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile<<"In SubvariableFlow::setReplacement \n";
+    myfile2<<"In SubvariableFlow::setReplacement \n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
   if (vn->isMark()) {		// Already seen before
     map<Varnode *,ReplaceVarnode>::iterator iter;
     iter = varmap.find(vn);
@@ -73,6 +88,26 @@ SubvariableFlow::ReplaceVarnode *SubvariableFlow::setReplacement(Varnode *vn,uin
       return (ReplaceVarnode *)0;
     return res;
   }
+#ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile<<"after isMark \n";
+    myfile2<<"after isMark \n";
+    myfile<<"vn->isConstant(): "<<vn->isConstant()<<"\n";
+    myfile2<<"vn->isConstant(): "<<vn->isConstant()<<" \n";
+    myfile<<"vn->getAddr().getOffset(): "<<vn->getAddr().getOffset()<<"\n";
+    myfile2<<"vn->getAddr().getOffset(): "<<vn->getAddr().getOffset()<<"\n";
+    myfile<<"vn->getOffset(): "<<vn->getOffset()<<"\n";
+    myfile2<<"vn->getOffset(): "<<vn->getOffset()<<"\n";
+    myfile<<"sextrestrictions: "<<sextrestrictions<<"\n";
+    myfile2<<"sextrestrictions: "<<sextrestrictions<<"\n";
+    if(vn->getDef()){
+      myfile<<"vn->getdef->addr->getoffset(): "<<vn->getDef()->getAddr().getOffset() <<"\n";
+      myfile2<<"vn->getdef->addr->getoffset(): "<<vn->getDef()->getAddr().getOffset() <<"\n";
+    }
+    myfile.close();
+    myfile2.close();
+#endif
 
   if (vn->isConstant()) {
     inworklist = false;
@@ -80,18 +115,61 @@ SubvariableFlow::ReplaceVarnode *SubvariableFlow::setReplacement(Varnode *vn,uin
       uintb cval = vn->getOffset();
       uintb smallval = cval & mask; // From its logical size
       uintb sextval = sign_extend(smallval,flowsize,vn->getSize());// to its fullsize
-      if (sextval != cval)
+#ifdef DEBUG_MUQI_sign_extend
+      ofstream myfile;
+      ofstream myfile2;
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"mask: "<< hex <<mask<<" \n";
+      myfile<<"cval: "<< hex<<cval<<" \n";
+      myfile<<"smallval: "<< hex<<smallval<<" \n";
+      myfile<<"sextval: "<< hex<<sextval<<" \n";
+      myfile<<"flowsize: "<< flowsize<<"\n";
+      myfile<<"vn->getSize(): "<<vn->getSize()<<"\n";
+
+      myfile2<<"mask: "<< hex <<mask<<" \n";
+      myfile2<<"cval: "<< hex<<cval<<" \n";
+      myfile2<<"smallval: "<< hex<<smallval<<" \n";
+      myfile2<<"sextval: "<< hex<<sextval<<" \n";
+      myfile2<<"flowsize: "<< flowsize<<"\n";
+      myfile2<<"vn->getSize(): "<<vn->getSize()<<"\n";
+      myfile.close();
+      myfile2.close();
+#endif
+    //  if (sextval != cval || sextval == uintb(127))
+    if (sextval != cval)
 	return (ReplaceVarnode *)0;
     }
     return addConstant((ReplaceOp *)0,mask,0,vn->getOffset());
   }
-
+ #ifdef DEBUG_MUQI_0x80
+  myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile<<"after isConstant \n";
+    myfile2<<"after isConstant \n";
+  myfile.close();
+  myfile2.close();
+#endif
   if (vn->isFree())
     return (ReplaceVarnode *)0; // Abort
-
+#ifdef DEBUG_MUQI_0x80
+myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile<<"after isFree \n";
+    myfile2<<"after isFree \n";
+   myfile.close();
+   myfile2.close();
+#endif
   if (vn->isAddrForce() && (vn->getSize() != flowsize))
     return (ReplaceVarnode *)0;
-
+#ifdef DEBUG_MUQI_0x80
+  myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile<<"after isAddrForce \n";
+    myfile2<<"after isAddrForce \n";
+  myfile.close();
+  myfile2.close();
+#endif
   if (sextrestrictions) {
     if (vn->getSize() != flowsize) {
       if ((!aggressive)&& vn->isInput()) return (ReplaceVarnode *)0; // Cannot assume input is sign extended
@@ -123,7 +201,14 @@ SubvariableFlow::ReplaceVarnode *SubvariableFlow::setReplacement(Varnode *vn,uin
       // or the mechanisms we use for inputs will give us spurious temporary inputs
     }
   }
-
+#ifdef DEBUG_MUQI_0x80
+myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile<<"after sextrestrictions \n";
+    myfile2<<"after sextrestrictions \n";
+    myfile.close();
+    myfile2.close();
+#endif
   res = & varmap[ vn ];
   vn->setMark();
   res->vn = vn;
@@ -144,6 +229,14 @@ SubvariableFlow::ReplaceVarnode *SubvariableFlow::setReplacement(Varnode *vn,uin
       }
     }
   }
+#ifdef DEBUG_MUQI_0x80
+myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile<<"at last  \n";
+    myfile2<<"at last \n";
+myfile.close();
+myfile2.close();
+#endif
   return res;
 }
 
@@ -346,6 +439,15 @@ bool SubvariableFlow::traceForward(ReplaceVarnode *rvn)
   int4 hcount = 0;
   int4 callcount = 0;
 
+#ifdef DEBUG_MUQI_0x80
+    ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile<<"Inside SubvariableFlow::traceForward\n ";
+    myfile2<<"Inside SubvariableFlow::traceForward\n ";
+#endif
   list<PcodeOp *>::const_iterator iter,enditer;
   enditer = rvn->vn->endDescend();
   for(iter = rvn->vn->beginDescend();iter != enditer;++iter) {
@@ -613,7 +715,15 @@ bool SubvariableFlow::traceBackward(ReplaceVarnode *rvn)
   int4 sa;
   uintb newmask;
   ReplaceOp *rop;
-
+#ifdef DEBUG_MUQI_0x80
+    ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile<<"Inside SubvariableFlow::traceBackward\n ";
+    myfile2<<"Inside SubvariableFlow::traceBackward\n ";
+#endif
   switch(op->code()) {
   case CPUI_COPY:
   case CPUI_MULTIEQUAL:
@@ -796,6 +906,16 @@ bool SubvariableFlow::traceForwardSext(ReplaceVarnode *rvn)
   int4 hcount = 0;
   int4 callcount = 0;
 
+#ifdef DEBUG_MUQI_0x80
+    ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile<<"Inside SubvariableFlow::traceForwardSext \n";
+  myfile2<<"Inside SubvariableFlow::traceForwardSext \n";
+  myfile.close();
+  myfile2.close();
+#endif
   list<PcodeOp *>::const_iterator iter,enditer;
   enditer = rvn->vn->endDescend();
   for(iter=rvn->vn->beginDescend();iter != enditer;++iter) {
@@ -812,16 +932,59 @@ bool SubvariableFlow::traceForwardSext(ReplaceVarnode *rvn)
     case CPUI_INT_XOR:
     case CPUI_INT_OR:
     case CPUI_INT_AND:
+#ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"Inside SubvariableFlow::traceForwardSext case1\n";
+      myfile2<<"Inside SubvariableFlow::traceForwardSext case1\n";
+    myfile.close();
+  myfile2.close();
+#endif
       rop = createOpDown(op->code(),op->numInput(),op,rvn,slot);
       if (!createLink(rop,rvn->mask,-1,outvn)) return false;
       hcount += 1;
       break;
     case CPUI_INT_SEXT:		// extended logical variable into even larger container
+#ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"Inside SubvariableFlow::traceForwardSext case2\n";
+      myfile2<<"Inside SubvariableFlow::traceForwardSext case2\n";
+      myfile.close();
+  myfile2.close();
+#endif
       rop = createOpDown(CPUI_COPY,1,op,rvn,0);
       if (!createLink(rop,rvn->mask,-1,outvn)) return false;
       hcount += 1;
+#ifdef DEBUG_MUQI_0x80
+       myfile<<"Inside SubvariableFlow::traceForwardSext \n";
+      if (rop->op){
+        myfile<<"rop's op seqnum is: " << rop->op->getSeqNum().getTime() <<"\n";
+      }
+      if (rop->replacement){
+        myfile<<"rop's replace seqnum is: " << rop->replacement->getSeqNum().getTime() <<"\n";
+      }
+      myfile.close();
+
+      myfile2<<"Inside SubvariableFlow::traceForwardSext \n";
+      if (rop->op){
+        myfile2<<"rop's op seqnum is: " << rop->op->getSeqNum().getTime()<<"\n";
+      }
+      if (rop->replacement){
+        myfile2<<"rop's replace seqnum is: " << rop->replacement->getSeqNum().getTime()<<"\n";
+      }
+      myfile2.close();
+#endif
       break;
     case CPUI_INT_SRIGHT:
+#ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"Inside SubvariableFlow::traceForwardSext case3\n";
+      myfile2<<"Inside SubvariableFlow::traceForwardSext case3\n";
+      myfile.close();
+  myfile2.close();
+#endif
       if (!op->getIn(1)->isConstant()) return false; // Right now we only deal with constant shifts
       rop = createOpDown(CPUI_INT_SRIGHT,2,op,rvn,0);
       if (!createLink(rop,rvn->mask,-1,outvn)) return false; // Keep the same mask size
@@ -829,6 +992,14 @@ bool SubvariableFlow::traceForwardSext(ReplaceVarnode *rvn)
       hcount += 1;
       break;
     case CPUI_SUBPIECE:
+#ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"Inside SubvariableFlow::traceForwardSext case4\n";
+      myfile2<<"Inside SubvariableFlow::traceForwardSext case4\n";
+      myfile.close();
+  myfile2.close();
+#endif
       if (op->getIn(1)->getOffset() != 0) return false;	// Only allow proper truncation
       if (outvn->getSize() > flowsize) return false;
       if (outvn->getSize() == flowsize)
@@ -843,12 +1014,28 @@ bool SubvariableFlow::traceForwardSext(ReplaceVarnode *rvn)
     case CPUI_INT_SLESSEQUAL:
     case CPUI_INT_EQUAL:	// Everything works if both sides are sign extended
     case CPUI_INT_NOTEQUAL:
+ #ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"Inside SubvariableFlow::traceForwardSext case5\n";
+      myfile2<<"Inside SubvariableFlow::traceForwardSext case5\n";
+      myfile.close();
+  myfile2.close();
+#endif
       outvn = op->getIn(1-slot); // The OTHER side of the comparison
       if (!createCompareBridge(op,rvn,slot,outvn)) return false;
       hcount += 1;
       break;
     case CPUI_CALL:
     case CPUI_CALLIND:
+#ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"Inside SubvariableFlow::traceForwardSext case6\n";
+      myfile2<<"Inside SubvariableFlow::traceForwardSext case6\n";
+      myfile.close();
+  myfile2.close();
+#endif
       callcount += 1;
       if (callcount > 1)
 	slot = op->getRepeatSlot(rvn->vn, slot, iter);
@@ -856,21 +1043,64 @@ bool SubvariableFlow::traceForwardSext(ReplaceVarnode *rvn)
       hcount += 1;		// Dealt with this descendant
       break;
     case CPUI_RETURN:
+#ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"Inside SubvariableFlow::traceForwardSext case7\n";
+      myfile2<<"Inside SubvariableFlow::traceForwardSext case7\n";
+      myfile.close();
+  myfile2.close();
+#endif
       if (!tryReturnPull(op,rvn,slot)) return false;
       hcount += 1;
       break;
     case CPUI_BRANCHIND:
+#ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"Inside SubvariableFlow::traceForwardSext case8\n";
+      myfile2<<"Inside SubvariableFlow::traceForwardSext case8\n";
+      myfile.close();
+  myfile2.close();
+#endif
       if (!trySwitchPull(op,rvn)) return false;
       hcount += 1;
       break;
     default:
+#ifdef DEBUG_MUQI_0x80
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"Inside SubvariableFlow::traceForwardSext case9\n";
+      myfile2<<"Inside SubvariableFlow::traceForwardSext case9\n";
+      myfile.close();
+  myfile2.close();
+#endif
       return false;
     }
   }
   if (dcount != hcount) {
     // Must account for all descendants of an input
-    if (rvn->vn->isInput()) return false;
+    if (rvn->vn->isInput()) 
+    {
+  #ifdef DEBUG_MUQI_0x80
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"Inside SubvariableFlow::traceForwardSext return false at end\n";
+      myfile2<<"Inside SubvariableFlow::traceForwardSext return false at end\n";
+      myfile.close();
+  myfile2.close();
+  #endif
+      return false;
+      }
   }
+#ifdef DEBUG_MUQI_0x80
+  myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile<<"Inside SubvariableFlow::traceForwardSext return true at end\n";
+      myfile2<<"Inside SubvariableFlow::traceForwardSext return true at end\n";
+      myfile.close();
+  myfile2.close();
+#endif
   return true;
 }
 
@@ -884,7 +1114,12 @@ bool SubvariableFlow::traceBackwardSext(ReplaceVarnode *rvn)
   PcodeOp *op = rvn->vn->getDef();
   if (op == (PcodeOp *)0) return true; // If vn is input
   ReplaceOp *rop;
-
+#ifdef DEBUG_MUQI_0x80
+    ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+#endif
   switch(op->code()) {
   case CPUI_COPY:
   case CPUI_MULTIEQUAL:
@@ -906,8 +1141,28 @@ bool SubvariableFlow::traceBackwardSext(ReplaceVarnode *rvn)
     break;
   case CPUI_INT_SEXT:
     if (flowsize != op->getIn(0)->getSize()) return false;
-    rop = createOp(CPUI_COPY,1,rvn);
+    rop = createOp(CPUI_COPY,1,rvn);    
     if (!createLink(rop,rvn->mask,0,op->getIn(0))) return false;
+
+/*
+    myfile<<"Inside SubvariableFlow::traceBackwardSext \n";
+    if (rop->op){
+      myfile<<"rop's op seqnum is: " << rop->op->getSeqNum().getTime() <<"\n";
+    }
+    if (rop->replacement){
+      myfile<<"rop's replace seqnum is: " << rop->replacement->getSeqNum().getTime() <<"\n";
+    }
+    myfile.close();
+
+    myfile2<<"Inside SubvariableFlow::traceBackwardSext \n";
+    if (rop->op){
+      myfile2<<"rop's op seqnum is: " << rop->op->getSeqNum().getTime()<<"\n";
+    }
+    if (rop->replacement){
+      myfile2<<"rop's replace seqnum is: " << rop->replacement->getSeqNum().getTime()<<"\n";
+    }
+    myfile2.close();
+*/
     return true;
   case CPUI_INT_SRIGHT:
     // A sign-extended logical value is arithmetically right-shifted
@@ -979,8 +1234,41 @@ bool SubvariableFlow::createCompareBridge(PcodeOp *op,ReplaceVarnode *inrvn,int4
 {
   bool inworklist;
   ReplaceVarnode *rep = setReplacement(othervn,inrvn->mask,inworklist);
-  if (rep == (ReplaceVarnode *)0) return false;
-
+ #ifdef DEBUG_MUQI_0x80
+    ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile<<"Inside SubvariableFlow::createCompareBridge \n";
+    myfile2<<"Inside SubvariableFlow::createCompareBridge \n";
+    myfile.close();
+  myfile2.close();
+ #endif
+    if (op)
+    {
+#ifdef DEBUG_MUQI_0x80
+          myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+      myfile <<"op->getSeqNum(): "<<op->getSeqNum().getTime() <<"\n";
+      myfile2 <<"p name is : " << op->getOpName() << "\n op name is : "<< get_opname(op->code())<<" \n address is "<< std::hex << op->getAddr().getOffset() <<"\n";
+      myfile2 <<"op->getSeqNum(): "<<op->getSeqNum().getTime()<< "\n";
+      myfile.close();
+  myfile2.close();
+  #endif
+    }
+  if (rep == (ReplaceVarnode *)0) {
+ #ifdef DEBUG_MUQI_0x80
+     myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    
+    myfile<<"return false\n";
+    myfile2<<"return false\n";
+    myfile.close();
+  myfile2.close();
+#endif
+    return false;
+  }
   if (slot==0)
     addComparePatch(inrvn,rep,op);
   else
@@ -988,6 +1276,14 @@ bool SubvariableFlow::createCompareBridge(PcodeOp *op,ReplaceVarnode *inrvn,int4
 
   if (inworklist)
     worklist.push_back(rep);
+#ifdef DEBUG_MUQI_0x80
+myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile<<"return true\n";
+  myfile2<<"return true\n";
+      myfile.close();
+  myfile2.close();
+ #endif
   return true;
 }
 
@@ -1247,11 +1543,44 @@ bool SubvariableFlow::processNextWork(void)
 
   worklist.pop_back();
 
+#ifdef DEBUG_MUQI_0x80
+  ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+#endif
   if (sextrestrictions) {
-    if (!traceBackwardSext(rvn)) return false;
+    if (!traceBackwardSext(rvn)) {
+#ifdef DEBUG_MUQI_0x80
+      myfile << "return false after traceBackwardSext\n";
+      myfile2 << "return false after traceBackwardSext\n";
+          myfile.close();
+  myfile2.close();
+#endif
+      return false;}
+#ifdef DEBUG_MUQI_0x80
+    myfile << "return traceForwardSext(rvn)\n";
+    myfile2 << "return traceForwardSext(rvn)\n";
+        myfile.close();
+  myfile2.close();
+#endif
     return traceForwardSext(rvn);
   }
-  if (!traceBackward(rvn)) return false;
+  if (!traceBackward(rvn)) {
+#ifdef DEBUG_MUQI_0x80
+    myfile << "return false after traceBackward(rvn)\n";
+      myfile2 << "return false after traceBackward(rvn)\n";
+          myfile.close();
+  myfile2.close();
+#endif
+    return false;
+  }
+#ifdef DEBUG_MUQI_0x80
+  myfile << "return traceForward(rvn)\n";
+      myfile2 << "return traceForward(rvn)\n";
+          myfile.close();
+  myfile2.close();
+#endif
   return traceForward(rvn);
 }
 
@@ -1329,6 +1658,15 @@ void SubvariableFlow::doReplacement(void)
 {
   list<PatchRecord>::iterator piter;
   list<ReplaceOp>::iterator iter;
+#ifdef DEBUG_MUQI_0x80
+    ofstream myfile;
+    ofstream myfile2;
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+
+    myfile << "Inside SubvariableFlow::doReplacement\n";
+    myfile2 << "Inside SubvariableFlow::doReplacement\n";
+#endif
 
   // Do up front processing of the call return patches, which will be at the front of the list
   for(piter=patchlist.begin();piter!=patchlist.end();++piter) {
@@ -1344,6 +1682,17 @@ void SubvariableFlow::doReplacement(void)
     fd->opSetInput(newZext,newVn,0);
     fd->opSetOutput(newZext,oldVn);
     fd->opInsertAfter(newZext, pushOp);
+#ifdef DEBUG_MUQI_0x80
+    if (newVn->getDef()) {
+      myfile<< "newVn doreplacement: "<<newVn->getDef()->getSeqNum().getTime()<<"\n";
+      myfile2<< "newVn doreplacement: "<<newVn->getDef()->getSeqNum().getTime()<<"\n";
+
+    }
+    if (oldVn->getDef()) {
+      myfile<< "newVn doreplacement: "<<oldVn->getDef()->getSeqNum().getTime()<<"\n";
+      myfile2<< "newVn doreplacement: "<<oldVn->getDef()->getSeqNum().getTime()<<"\n";
+    }
+    #endif
   }
 
   // Define all the outputs first
@@ -1360,15 +1709,34 @@ void SubvariableFlow::doReplacement(void)
     //      }
     fd->opSetOutput(newop,getReplaceVarnode(rout));
     fd->opInsertAfter(newop,(*iter).op);
+#ifdef DEBUG_MUQI_0x80
+    if (rout->replacement->getDef()) {
+      myfile<< "rout->replacement->getDef() doreplacement: "<<rout->replacement->getDef()->getSeqNum().getTime()<<"\n";
+      myfile2<< "rout->replacement->getDef() doreplacement: "<<rout->replacement->getDef()->getSeqNum().getTime()<<"\n";
+    }
+#endif
   }
 
   // Set all the inputs
   for(iter=oplist.begin();iter!=oplist.end();++iter) {
     PcodeOp *newop = (*iter).replacement;
-    for(uint4 i=0;i<(*iter).input.size();++i)
+    for(uint4 i=0;i<(*iter).input.size();++i){
       fd->opSetInput(newop,getReplaceVarnode((*iter).input[i]),i);
+
+#ifdef DEBUG_MUQI_0x80
+      if (newop) {
+        myfile<< "newop->getSeqNum() doreplacement: "<<newop->getSeqNum().getTime()<<"\n";
+        myfile2<< "newop->getSeqNum() doreplacement: "<<newop->getSeqNum().getTime()<<"\n";
+      }
+#endif
+    }
+      
   }
 
+#ifdef DEBUG_MUQI_0x80
+      myfile.close();
+  myfile2.close();
+#endif
   // These are operations that carry flow from the small variable into an existing
   // variable of the correct size
   for(;piter!=patchlist.end();++piter) {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc
index b05109d69..37d4abfd2 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/type.cc
@@ -568,6 +568,11 @@ int4 TypeArray::compare(const Datatype &op,int4 level) const
     if (id == op.getId()) return 0;
     return (id < op.getId()) ? -1 : 1;
   }
+        ofstream myfile2;
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  //myfile2 << "test TypeArray2\n";
+  myfile2.close();
+
   ta = (TypeArray *) &op;	// Both must be arrays
   return arrayof->compare(*ta->arrayof,level); // Compare array elements
 }
@@ -576,7 +581,10 @@ int4 TypeArray::compareDependency(const Datatype &op) const
 
 {
   TypeArray *ta;
-
+        ofstream myfile2;
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+ // myfile2 << "test TypeArray3\n";
+  myfile2.close();
   if (size != op.getSize()) return (op.getSize()-size);
   if (metatype != op.getMetatype()) return (metatype < op.getMetatype()) ? -1 : 1;
   ta = (TypeArray *) &op;	// Both must be arrays
@@ -2071,7 +2079,14 @@ TypePointer *TypeFactory::getTypePointerNoDepth(int4 s,Datatype *pt,uint4 ws)
 TypeArray *TypeFactory::getTypeArray(int4 as,Datatype *ao)
 
 {
+        ofstream myfile2;
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "test TypeArray4\n";
+  myfile2.close();
   TypeArray tmp(as,ao);
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "test TypeArray4 end\n";
+  myfile2.close();
   return (TypeArray *) findAdd(tmp);
 }
 
@@ -2326,6 +2341,10 @@ Datatype *TypeFactory::restoreXmlTypeNoRef(const Element *el,bool forcecore)
     break;
   case TYPE_ARRAY:
     {
+            ofstream myfile2;
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+ // myfile2 << "test TypeArray5\n";
+  myfile2.close();
       TypeArray ta;
       ta.restoreXml(el,*this);
       if (forcecore)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/type.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/type.hh
index cb6e879a8..53dbd7164 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/type.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/type.hh
@@ -250,6 +250,7 @@ public:
   virtual void saveXml(ostream &s) const;
 };
 
+#define DEBUG_MUQI_TypeArray
 /// \brief Datatype object representing an array of elements
 class TypeArray : public Datatype {
 protected:
@@ -261,12 +262,36 @@ protected:
   TypeArray(void) : Datatype(0,TYPE_ARRAY) { arraysize = 0; arrayof = (Datatype *)0; }
 public:
   /// Construct from another TypeArray
-  TypeArray(const TypeArray &op) : Datatype(op) { arrayof = op.arrayof; arraysize = op.arraysize; }
+  TypeArray(const TypeArray &op) : Datatype(op) { 
+    ofstream myfile2;
+    #ifdef DEBUG_MUQI_TypeArray
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "In TypeArray, first constructor\n";
+  myfile2 << "Arraysize is: "<<op.arraysize <<"\n";
+  myfile2.close();
+  #endif
+    
+    arrayof = op.arrayof; arraysize = op.arraysize; }
   /// Construct given an array size and element data-type
   TypeArray(int4 n,Datatype *ao) : Datatype(n*ao->getSize(),TYPE_ARRAY) {
+    ofstream myfile2;
+    #ifdef DEBUG_MUQI_TypeArray
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "In TypeArray, second constructor\n";
+  myfile2 << "Arraysize is: "<<n <<"\n";
+  myfile2.close();
+  #endif
     arraysize = n; arrayof = ao; }
   Datatype *getBase(void) const { return arrayof; }	///< Get the element data-type
-  int4 numElements(void) const { return arraysize; }	///< Get the number of elements
+  int4 numElements(void) const { 
+    ofstream myfile2;
+   #ifdef DEBUG_MUQI_TypeArray
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "In TypeArray\n";
+  myfile2 << "Arraysize is: "<<arraysize <<"\n";
+  myfile2.close();
+  #endif
+    return arraysize; }	///< Get the number of elements
   Datatype *getSubEntry(int4 off,int4 sz,int4 *newoff,int4 *el) const;	///< Figure out what a byte range overlaps
   virtual void printRaw(ostream &s) const;
   virtual Datatype *getSubType(uintb off,uintb *newoff) const;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
index 7a651026c..006b8c318 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
@@ -16,6 +16,8 @@
 #include "varmap.hh"
 #include "funcdata.hh"
 
+#define DEBUG_MUQI_createEntry
+
 /// \brief Can the given intersecting RangeHint coexist with \b this at their given offsets
 ///
 /// Determine if the data-type information in the two ranges \e line \e up
@@ -465,19 +467,40 @@ bool ScopeLocal::adjustFit(RangeHint &a) const
   return true;
 }
 
+
+
 /// A name and final data-type is constructed for the RangeHint, and they are entered as
 /// a new Symbol into \b this scope.
 /// \param a is the given RangeHint to create a Symbol for
 void ScopeLocal::createEntry(const RangeHint &a)
 
 {
+  #ifdef DEBUG_MUQI_createEntry
+  ofstream myfile2;
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "In ScopeLocal::createEntry\n";
+  myfile2 << "a is " << hex <<&a <<"\n";
+  myfile2.close();
+  #endif
+
   Address addr(space,a.start);
   Address usepoint;
   Datatype *ct = glb->types->concretize(a.type);
   int4 num = a.size/ct->getSize();
+
+  #ifdef DEBUG_MUQI_createEntry
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "before getTypearray\n";
+  myfile2.close();
+  #endif
   if (num>1)
     ct = glb->types->getTypeArray(num,ct);
 
+  #ifdef DEBUG_MUQI_createEntry
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "End ScopeLocal::createEntry\n";
+  myfile2.close();
+  #endif
   addSymbol("",ct,addr,usepoint);
 }
 
@@ -997,6 +1020,13 @@ void MapState::gatherOpen(const Funcdata &fd)
 void ScopeLocal::restructureVarnode(bool aliasyes)
 
 {
+  #ifdef DEBUG_MUQI_createEntry
+  ofstream myfile2;
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "In ScopeLocal::restructureVarnode\n";
+  myfile2.close();
+  #endif
+
   clearUnlockedCategory(-1);	// Clear out any unlocked entries
   MapState state(space,getRangeTree(),fd->getFuncProto().getParamRange(),
 		  glb->types->getBase(1,TYPE_UNKNOWN)); // Organize list of ranges to insert
@@ -1010,6 +1040,11 @@ void ScopeLocal::restructureVarnode(bool aliasyes)
   state.gatherSymbols(maptable[space->getIndex()]);
   restructure(state);
 
+#ifdef DEBUG_MUQI_createEntry
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "End ScopeLocal::restructureVarnode\n";
+  myfile2.close();
+  #endif
   // At some point, processing mapped input symbols may be folded
   // into the above gather/restructure process, but for now
   // we just define fake symbols so that mark_unaliased will work
@@ -1027,7 +1062,14 @@ void ScopeLocal::restructureVarnode(bool aliasyes)
 /// a HighVariable.
 void ScopeLocal::restructureHigh(void)
 
-{				// Define stack mapping based on highs
+{
+  #ifdef DEBUG_MUQI_createEntry
+  ofstream myfile2;
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "In ScopeLocal::restructureHigh\n";
+  myfile2.close();
+  #endif
+  				// Define stack mapping based on highs
   clearUnlockedCategory(-1);	// Clear out any unlocked entries
   MapState state(space,getRangeTree(),fd->getFuncProto().getParamRange(),
 		  glb->types->getBase(1,TYPE_UNKNOWN)); // Organize list of ranges to insert
@@ -1041,6 +1083,12 @@ void ScopeLocal::restructureHigh(void)
   state.gatherSymbols(maptable[space->getIndex()]);
   bool overlapProblems = restructure(state);
 
+#ifdef DEBUG_MUQI_createEntry
+  myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+  myfile2 << "End of ScopeLocal::restructureHigh\n";
+  myfile2.close();
+  #endif
+
   if (overlapProblems)
     fd->warningHeader("Could not reconcile some variable overlaps");
 }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc
index 919230507..631a63852 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.cc
@@ -16,6 +16,7 @@
 #include "varnode.hh"
 #include "funcdata.hh"
 
+//#define DEBUG_MUQI_0x80
 /// Compare by location then by definition.
 /// This is the same as the normal varnode compare, but we distinguish identical frees by their
 /// pointer address.  Thus varsets defined with this comparison act like multisets for free varnodes
@@ -523,6 +524,27 @@ bool Varnode::operator==(const Varnode &op2) const
 Varnode::Varnode(int4 s,const Address &m,Datatype *dt)
   : loc(m)
 {				// Construct a varnode
+
+#ifdef DEBUG_MUQI_0x80
+   ofstream myfile;
+    ofstream myfile2;
+   
+    myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+    myfile << "In  Varnode::Varnode \n ";
+    myfile << "s is "<<s<<"\n";
+    myfile <<"address offset is: "<<m.getOffset()<<"\n";
+    
+
+    myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+    myfile2 << "In  Varnode::Varnode \n ";
+    myfile2 << "s is "<<s<<"\n";
+    myfile2 <<"address offset is: "<<m.getOffset()<<"\n";
+
+    myfile.close();
+    myfile2.close();
+#endif
+
+
   size = s;
   def = (PcodeOp *)0;		// No defining op yet
   type = dt;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.hh
index 3abcce7b9..6e5576efc 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/varnode.hh
@@ -183,6 +183,7 @@ public:
   Cover *getCover(void) const { updateCover(); return cover; } ///< Get Varnode coverage information
   list<PcodeOp *>::const_iterator beginDescend(void) const { return descend.begin(); } ///< Get iterator to list of syntax tree descendants (reads)
   list<PcodeOp *>::const_iterator endDescend(void) const { return descend.end(); } ///< Get the end iterator to list of descendants
+  int sizeofDescend(void) const {return descend.size();};
   uintb getConsume(void) const { return consumed; } ///< Get mask of consumed bits
   void setConsume(uintb val) { consumed = val; } ///< Set the mask of consumed bits (used by dead-code algorithm)
   bool isConsumeList(void) const { return ((addlflags&Varnode::lisconsume)!=0); } ///< Get marker used by dead-code algorithm
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
index 51fb5870c..196e566d3 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/xml.cc
@@ -2346,10 +2346,13 @@ Document *xml_tree(istream &i)
   }
   return doc;
 }
-
+#define DEBUG_MUQI_0x80
 void xml_escape(ostream &s,const char *str)
 
 {
+  ofstream myfile;
+  ofstream myfile2;
+
   while(*str!='\0') {
     if (*str < '?') {
       if (*str=='<') s << "&lt;";
@@ -2357,10 +2360,29 @@ void xml_escape(ostream &s,const char *str)
       else if (*str=='&') s << "&amp;";
       else if (*str=='"') s << "&quot;";
       else if (*str=='\'') s << "&apos;";
-      else s << *str;
+      else {
+        s << *str;
+ #ifdef DEBUG_MUQI_0x80
+        myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+        myfile << *str;
+        myfile.close();
+        myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+        myfile2 << *str;
+        myfile2.close();
+#endif
+      }
     }
-    else
+    else{
       s << *str;
+#ifdef DEBUG_MUQI_0x80
+      myfile.open("/home/muqi/Downloads/ghidra/build/dist/example1.txt", std::ios_base::app);
+      myfile << *str;
+      myfile.close();
+      myfile2.open("/home/muqi/Downloads/ghidra/build/dist/example2.txt", std::ios_base::app);
+      myfile2 << *str;
+      myfile2.close();
+#endif
+    }
     str++;
   }
 }
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/cmd/function/DecompilerSwitchAnalysisCmd.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/cmd/function/DecompilerSwitchAnalysisCmd.java
index 1eb3de8c3..efb243e07 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/cmd/function/DecompilerSwitchAnalysisCmd.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/cmd/function/DecompilerSwitchAnalysisCmd.java
@@ -50,6 +50,7 @@ public class DecompilerSwitchAnalysisCmd extends BackgroundCommand {
 	private boolean useArraysForSwitchTables = false;
 
 	public DecompilerSwitchAnalysisCmd(DecompileResults decopmileResults) {
+		Msg.debug(this,"Construct the DecompilerSwitchAnalysis");
 		this.decompilerResults = decopmileResults;
 	}
 
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompInterface.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompInterface.java
index 21babd749..c958ec5d3 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompInterface.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompInterface.java
@@ -35,6 +35,8 @@ import ghidra.util.task.CancelledListener;
 import ghidra.util.task.TaskMonitor;
 import ghidra.xml.XmlPullParser;
 
+import ghidra.util.Msg;
+
 /**
  * This is a self-contained interface to a single decompile
  * process, suitable for an open-ended number of function
@@ -223,9 +225,17 @@ public class DecompInterface {
 		ResourceFile pspecfile = sleighdescription.getSpecFile();
 		String pspecxml = fileToString(pspecfile);
 		String cspecxml = compilerSpec.getXMLString();
+		//muqi_for_ruleout_rules
+		String program_name_function = "Unknown_program_function_name";
+
+		if (this!=null){
+			if(this.getProgram()!=null){
+				program_name_function = this.getProgram().getExecutablePath();
+			}
+		}
 
 		decompCallback.setNativeMessage(null);
-		decompProcess.registerProgram(decompCallback, pspecxml, cspecxml, tspec, coretypes);
+		decompProcess.registerProgram(decompCallback, pspecxml, cspecxml, tspec, coretypes,program_name_function);
 		String nativeMessage = decompCallback.getNativeMessage();
 		if ((nativeMessage != null) && (nativeMessage.length() != 0)) {
 			throw new IOException("Could not register program: " + nativeMessage);
@@ -696,6 +706,7 @@ public class DecompInterface {
 	 */
 	public synchronized DecompileResults decompileFunction(Function func, int timeoutSecs,
 			TaskMonitor monitor) {
+		Msg.debug(this,"Inside decompileFunction");
 
 		decompileMessage = "";
 		if (monitor != null && monitor.isCancelled()) {
@@ -711,7 +722,31 @@ public class DecompInterface {
 			return new DecompileResults(func, pcodelanguage, null, dtmanage, decompileMessage, null,
 				DecompileProcess.DisposeState.DISPOSED_ON_CANCEL);
 		}
-
+	
+		 Address funcEntry = func.getEntryPoint();
+                        if (debug != null) {
+                                debug.setFunction(func);
+                        }
+                        decompCallback.setFunction(func, funcEntry, debug);
+                        StringBuilder addrBuf = new StringBuilder();
+                        AddressXML.buildXML(addrBuf, funcEntry);
+		try{
+                        verifyProcess();
+                }catch (Exception ex) {
+                        decompileMessage = "Exception while decompiling1 " + func.getEntryPoint() + ": " +
+                                ex.getMessage() + '\n';
+                }
+		try {
+			//Msg.debug(this,"function string is:" + addrBuf.toString());
+                        res = decompProcess.sendCommand1ParamTimeout("decompileAt", addrBuf.toString(),
+                                timeoutSecs);
+                        decompileMessage = decompCallback.getNativeMessage();
+		}catch (Exception ex) {
+                        decompileMessage = "Exception while decompiling2 " + func.getEntryPoint() + ": " +
+                                ex.getMessage() + '\n';
+                }
+
+		/*	
 		try {
 			Address funcEntry = func.getEntryPoint();
 			if (debug != null) {
@@ -721,6 +756,7 @@ public class DecompInterface {
 			StringBuilder addrBuf = new StringBuilder();
 			AddressXML.buildXML(addrBuf, funcEntry);
 			verifyProcess();
+			//Msg.debug(this,"function string is:" + addrBuf.toString());
 			res = decompProcess.sendCommand1ParamTimeout("decompileAt", addrBuf.toString(),
 				timeoutSecs);
 			decompileMessage = decompCallback.getNativeMessage();
@@ -733,7 +769,7 @@ public class DecompInterface {
 			if (monitor != null) {
 				monitor.removeCancelledListener(monitorListener);
 			}
-		}
+		}*/
 		if (debug != null) {
 			debug.shutdown(pcodelanguage, xmlOptions.getXML(this));
 			debug = null;
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java
index 1779fd65a..789ec539d 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileCallback.java
@@ -919,7 +919,8 @@ public class DecompileCallback {
 			HighSymbol.buildMapSymXML(res, highSymbol);
 		}
 		res.append("</result>\n");
-
+		//Msg.debug(this,"In buildResult");
+		//Msg.debug(this,res.toString());
 		return res.toString();
 	}
 
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java
index 4ffff75e3..bf7951a08 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java
@@ -178,7 +178,9 @@ public class DecompileOptions {
 	private final static String COMMENTSTYLE_OPTIONSTRING = "Display.Comment style";
 	private final static String COMMENTSTYLE_OPTIONDESCRIPTION =
 		"Choice between either the C style comments /* */ or C++ style // ";
-	public static final int SUGGESTED_DECOMPILE_TIMEOUT_SECS = 30;
+	//muqi change timeout seconds to reduce the time of export file
+	//public static final int SUGGESTED_DECOMPILE_TIMEOUT_SECS = 30;
+	public static final int SUGGESTED_DECOMPILE_TIMEOUT_SECS = 2;
 	public static final int SUGGESTED_MAX_PAYLOAD_BYTES = 50;
 	public static final int SUGGESTED_MAX_INSTRUCTIONS = 100000;		// Must match Architecture::resetDefaultsInternal
 
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileProcess.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileProcess.java
index 1461e77f4..f03e84f20 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileProcess.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileProcess.java
@@ -433,7 +433,7 @@ public class DecompileProcess {
 	 * @throws DecompileException for problems executing the command
 	 */
 	public synchronized void registerProgram(DecompileCallback cback, String pspecxml,
-			String cspecxml, String tspecxml, String coretypesxml)
+			String cspecxml, String tspecxml, String coretypesxml,  String program_name_function)
 			throws IOException, DecompileException {
 		callback = cback;
 
@@ -446,6 +446,7 @@ public class DecompileProcess {
 			writeString(cspecxml);
 			writeString(tspecxml);
 			writeString(coretypesxml);
+			writeString(program_name_function);
 			write(command_end);
 			restring = readResponse().toString();
 		}
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileResults.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileResults.java
index e6038f665..06aacf629 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileResults.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileResults.java
@@ -15,7 +15,12 @@
  */
 package ghidra.app.decompiler;
 
+import java.io.IOException;
 import java.io.InputStream;
+import java.util.*;
+
+import org.apache.commons.io.IOUtils;
+import java.nio.charset.StandardCharsets;
 
 import ghidra.program.model.lang.CompilerSpec;
 import ghidra.program.model.lang.Language;
@@ -24,6 +29,8 @@ import ghidra.program.model.pcode.*;
 import ghidra.xml.XmlElement;
 import ghidra.xml.XmlPullParser;
 
+import ghidra.util.Msg;
+
 /**
  * Class for getting at the various structures returned
  * by the decompiler.  Depending on how the DecompInterface
@@ -63,6 +70,25 @@ public class DecompileResults {
 	private String errMsg; // Error message from decompiler
 	private DecompileProcess.DisposeState processState;
 
+/*
+	private void dumpResults(String raw) {
+		if (raw == null) {
+			return;
+		}
+		try {
+			File tmpFile = File.createTempFile("decomp", ".xml");
+			OutputStream out = new BufferedOutputStream(new FileOutputStream(tmpFile));
+			out.write(raw.getBytes());
+			out.flush();
+			out.close();
+			Msg.info(this, "Dumped decompile data to: " + tmpFile);
+		}
+		catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+*/
 	public DecompileResults(Function f, Language language, CompilerSpec compilerSpec,
 			PcodeDataTypeManager d, String e, InputStream raw,
 			DecompileProcess.DisposeState processState) {
@@ -75,26 +101,12 @@ public class DecompileResults {
 		hparamid = null;
 		docroot = null;
 		//dumpResults(raw);
+	//	Msg.debug(this,"parseRawString is: ");
+	//	Msg.debug(this, raw);
 		parseRawString(raw);
 	}
 
-//	private void dumpResults(String raw) {
-//		if (raw == null) {
-//			return;
-//		}
-//		try {
-//			File tmpFile = File.createTempFile("decomp", ".xml");
-//			OutputStream out = new BufferedOutputStream(new FileOutputStream(tmpFile));
-//			out.write(raw.getBytes());
-//			out.flush();
-//			out.close();
-//			Msg.info(this, "Dumped decompile data to: " + tmpFile);
-//		}
-//		catch (IOException e) {
-//			// TODO Auto-generated catch block
-//			e.printStackTrace();
-//		}
-//	}
+
 
 	/**
 	 * Returns true if the decompilation producing these
@@ -219,8 +231,20 @@ public class DecompileResults {
 				hparamid = null;
 				docroot = null;
 				parser.start("doc");
+
+				/*
+				try{
+					String rawxml_string_debug = IOUtils.toString(rawxml, StandardCharsets.UTF_8);
+					Msg.debug(this,rawxml_string_debug);
+				
+				} catch (IOException e) {
+					// TODO Auto-generated catch block
+					e.printStackTrace();
+				}
+*/
 				while(parser.peek().isStart()) {
 					XmlElement el = parser.peek();
+					
 					if (el.getName().equals("function")) {
 						if (hfunc ==  null) {
 							hfunc = new HighFunction(function, language, compilerSpec, dtmanage);
@@ -228,6 +252,20 @@ public class DecompileResults {
 						}
 						else {		// TODO: This is an ugly kludge to get around duplicate XML tag names
 							docroot = ClangXML.buildClangTree(parser, hfunc);
+							Msg.debug(this,"high function localmap is: ");
+							Iterator<HighSymbol> ptr =hfunc.getLocalSymbolMap().getSymbols();
+							while(ptr.hasNext()) {
+								HighSymbol symbol = ptr.next();
+								//Msg.debug(this,symbol.getName());	
+							}
+							Msg.debug(this,"high function globalmap is: ");
+							Iterator<HighSymbol> ptr2 =hfunc.getGlobalSymbolMap().getSymbols();
+							while(ptr2.hasNext()) {
+								HighSymbol symbol = ptr2.next();
+								//Msg.debug(this,symbol.getName());	
+							}
+							Msg.debug(this,"parseRawString is: ");
+							//Msg.debug(this, docroot.toString());
 							if (docroot == null) {
 								errMsg = "Unable to parse C (xml)";
 							}							
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
index 37fe757b0..acdeab132 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/PrettyPrinter.java
@@ -21,7 +21,7 @@ import java.util.List;
 import ghidra.app.decompiler.component.DecompilerUtils;
 import ghidra.program.model.listing.Function;
 import ghidra.util.StringUtilities;
-
+import ghidra.util.Msg;
 /**
  * This class is used to convert a C language
  * token group into readable C code.
@@ -79,6 +79,7 @@ public class PrettyPrinter {
 	 * @return a string of readable C code
 	 */
 	public DecompiledFunction print(boolean removeInvalidChars) {
+		Msg.debug(this,"Inside pretty print");
 		StringBuffer buff = new StringBuffer();
 
 		for (ClangLine line : lines) {
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java
index f817902c8..f7403048b 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/component/DecompilerPanel.java
@@ -54,7 +54,7 @@ import ghidra.util.*;
 import ghidra.util.bean.field.AnnotatedTextFieldElement;
 import ghidra.util.task.SwingUpdateManager;
 import util.CollectionUtils;
-
+import ghidra.util.Msg;
 /**
  * Class to handle the display of a decompiled function
  */
@@ -221,6 +221,7 @@ public class DecompilerPanel extends JPanel implements FieldMouseListener, Field
 	 * @param decompileData the new data
 	 */
 	void setDecompileData(DecompileData decompileData) {
+		Msg.debug(this,"Inside setDecompileData");
 		if (layoutMgr == null) {
 			// we've been disposed!
 			return;
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java
index 60adbfba2..001434ba9 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/decompile/DecompilerProvider.java
@@ -721,6 +721,19 @@ public class DecompilerProvider extends NavigatableComponentProviderAdapter
 			title = "Decompile: " + function.getName();
 			subTitle = " (" + programName + ")";
 		}
+		/*
+		int temp = 1;
+		if (temp == 1){
+			try
+			{
+				throw new NullPointerException("demo");
+			}
+			catch(NullPointerException e)
+			{
+				System.out.println("Caught inside fun().");
+				throw e; // rethrowing the exception
+			}}
+			*/
 		if (!isConnected()) {
 			title = "[" + title + "]";
 		}
diff --git a/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/mgr/ToolTaskManager.java b/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/mgr/ToolTaskManager.java
index a791b6ea3..283d70388 100644
--- a/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/mgr/ToolTaskManager.java
+++ b/Ghidra/Framework/Project/src/main/java/ghidra/framework/plugintool/mgr/ToolTaskManager.java
@@ -227,6 +227,7 @@ public class ToolTaskManager implements Runnable {
 			}
 		}
 		else {
+			Msg.debug(this,"In scheduleFollowOnCommand, command being executed is: "+ cmd.getName());
 			executeCommand(cmd, obj);
 		}
 	}
@@ -405,6 +406,7 @@ public class ToolTaskManager implements Runnable {
 		task.getCommand().taskCompleted();
 		double totalTime = (System.currentTimeMillis() - start_time) / 1000.00;
 		Msg.debug(this, "  task complete (" + totalTime + " secs)");
+		//muqi : here we have already output c code
 	}
 
 	/**
diff --git a/Ghidra/Framework/SoftwareModeling/Sleigh.launch b/Ghidra/Framework/SoftwareModeling/Sleigh.launch
index 0582eb91e..e1aaeaf72 100644
--- a/Ghidra/Framework/SoftwareModeling/Sleigh.launch
+++ b/Ghidra/Framework/SoftwareModeling/Sleigh.launch
@@ -19,6 +19,7 @@
     <listAttribute key="org.eclipse.jdt.launching.CLASSPATH">
         <listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry path=&quot;5&quot; projectName=&quot;Framework Utility&quot; type=&quot;1&quot;/&gt;&#10;"/>
     </listAttribute>
+    <stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.buildship.core.classpathprovider"/>
     <booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
     <stringAttribute key="org.eclipse.jdt.launching.JRE_CONTAINER" value="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-11"/>
     <stringAttribute key="org.eclipse.jdt.launching.MAIN_TYPE" value="ghidra.GhidraLauncher"/>
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighConstant.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighConstant.java
index d17bcb5b6..65048f12d 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighConstant.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighConstant.java
@@ -24,6 +24,11 @@ import ghidra.util.xml.SpecXmlUtils;
 import ghidra.xml.XmlElement;
 import ghidra.xml.XmlPullParser;
 
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import ghidra.util.Msg;
+
+
 /**
  * 
  *
@@ -33,7 +38,7 @@ public class HighConstant extends HighVariable {
 
 	private HighSymbol symbol;
 	private Address pcaddr;		// null or Address of PcodeOp which defines the representative
-
+	static final Logger log = LogManager.getLogger(HighConstant.class);
 	/**
 	 * Constructor for use with restoreXml
 	 * @param func is the HighFunction this constant belongs to
@@ -53,6 +58,7 @@ public class HighConstant extends HighVariable {
 	public HighConstant(String name, DataType type, Varnode vn, Address pc, HighFunction func) {
 		super(name, type, vn, null, func);
 		pcaddr = pc;
+		//Msg.debug(this, "name is"+ name);
 	}
 
 	@Override
@@ -89,6 +95,7 @@ public class HighConstant extends HighVariable {
 
 	@Override
 	public void restoreXml(XmlPullParser parser) throws PcodeXMLException {
+		//Msg.debug(this, "test test test!!!");
 		XmlElement el = parser.start("high");
 		long symref = SpecXmlUtils.decodeLong(el.getAttribute("symref"));
 		restoreInstances(parser, el);
@@ -116,6 +123,7 @@ public class HighConstant extends HighVariable {
 			}
 		}
 		parser.end(el);
+		//Msg.debug(this, "restoreXml: name is"+ name);
 	}
 
 }
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java
index bf4097402..0a16b9ac7 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighFunction.java
@@ -35,6 +35,11 @@ import ghidra.util.exception.InvalidInputException;
 import ghidra.util.xml.SpecXmlUtils;
 import ghidra.xml.*;
 
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+
 /**
  *
  *
@@ -51,7 +56,7 @@ public class HighFunction extends PcodeSyntaxTree {
 	private GlobalSymbolMap globalSymbols;
 	private List<JumpTable> jumpTables;
 	private List<DataTypeSymbol> protoOverrides;
-
+	static final Logger log = LogManager.getLogger(HighFunction.class);
 	/**
 	 * @param function  function associated with the higher level function abstraction.
 	 * @param language  description of the processor language of the function
@@ -263,6 +268,7 @@ public class HighFunction extends PcodeSyntaxTree {
 		}
 		while (!parser.peek().isEnd()) {
 			XmlElement subel = parser.peek();
+			//Msg.debug(this,subel.getText());
 			if (subel.getName().equals("addr")) {
 				subel = parser.start("addr");
 				Address addr = AddressXML.readXML(subel, getAddressFactory());
@@ -490,6 +496,7 @@ public class HighFunction extends PcodeSyntaxTree {
 			resBuf.append("</override>\n");
 		}
 		resBuf.append("</function>\n");
+		//Msg.debug(this,resBuf.toString());
 		return resBuf.toString();
 	}
 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighVariable.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighVariable.java
index ee5b3824e..8d1fa2ebb 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighVariable.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/HighVariable.java
@@ -22,6 +22,8 @@ import ghidra.util.xml.SpecXmlUtils;
 import ghidra.xml.XmlElement;
 import ghidra.xml.XmlPullParser;
 
+import ghidra.util.Msg;
+
 /**
  * 
  *
@@ -50,6 +52,8 @@ public abstract class HighVariable {
 		type = tp;
 		function = func;
 		attachInstances(inst, rep);
+		Msg.debug(this,"variable name is: "+nm);
+						
 	}
 
 	/**
@@ -74,6 +78,7 @@ public abstract class HighVariable {
 	 * @return get the name of the variable
 	 */
 	public String getName() {
+		Msg.debug(this,"variable name is: "+name);
 		return name;
 	}
 
@@ -149,6 +154,7 @@ public abstract class HighVariable {
 	 */
 	protected void restoreInstances(XmlPullParser parser, XmlElement el)
 			throws PcodeXMLException {
+				//Msg.debug(this, "test test test!!!");
 		int repref = SpecXmlUtils.decodeInt(el.getAttribute("repref"));
 		Varnode rep = function.getRef(repref);
 		if (rep == null) {
diff --git a/Ghidra/Processors/JVM/src/main/java/ghidra/javaclass/analyzers/JavaAnalyzer.java b/Ghidra/Processors/JVM/src/main/java/ghidra/javaclass/analyzers/JavaAnalyzer.java
index c439d86f4..28c8a0929 100644
--- a/Ghidra/Processors/JVM/src/main/java/ghidra/javaclass/analyzers/JavaAnalyzer.java
+++ b/Ghidra/Processors/JVM/src/main/java/ghidra/javaclass/analyzers/JavaAnalyzer.java
@@ -139,6 +139,19 @@ public class JavaAnalyzer extends AbstractJavaAnalyzer implements AnalysisWorker
 		processInstructions(program, constantPoolData, classFile, monitor);
 		recordJavaVersionInfo(program, classFile);
 		ProgramCompilerSpec.enableJavaLanguageDecompilation(program);
+		/*
+		int temp = 1;
+		if (temp == 1){
+			try
+			{
+				throw new NullPointerException("demo");
+			}
+			catch(NullPointerException e)
+			{
+				System.out.println("Caught inside fun().");
+				throw e; // rethrowing the exception
+			}}
+			*/
 		return true;
 	}
 
diff --git a/Ghidra/Processors/x86/src/main/java/ghidra/app/plugin/core/analysis/X86Analyzer.java b/Ghidra/Processors/x86/src/main/java/ghidra/app/plugin/core/analysis/X86Analyzer.java
index 8ef0143bd..36c27e785 100644
--- a/Ghidra/Processors/x86/src/main/java/ghidra/app/plugin/core/analysis/X86Analyzer.java
+++ b/Ghidra/Processors/x86/src/main/java/ghidra/app/plugin/core/analysis/X86Analyzer.java
@@ -87,7 +87,18 @@ public class X86Analyzer extends ConstantPropagationAnalyzer {
 		};
 
 		AddressSet resultSet = symEval.flowConstants(flowStart, flowSet, eval, true, monitor);
-
+		/*int temp = 1;
+		if (temp == 1){
+			try
+			{
+				throw new NullPointerException("demo");
+			}
+			catch(NullPointerException e)
+			{
+				System.out.println("Caught inside fun().");
+				throw e; // rethrowing the exception
+			}}
+*/
 		return resultSet;
 	}
 }
