diff --git a/include/klee/Constraints.h b/include/klee/Constraints.h
index 87069f8..eb35d03 100755
--- a/include/klee/Constraints.h
+++ b/include/klee/Constraints.h
@@ -44,6 +44,8 @@ public:
   ref<Expr> simplifyExpr(ref<Expr> e) const;
 
   void addConstraint(ref<Expr> e);
+  //muqi
+  void dump_constraints();
   
   bool empty() const {
     return constraints.empty();
diff --git a/include/klee/ExecutionState.h b/include/klee/ExecutionState.h
index fa88891..b3922d0 100755
--- a/include/klee/ExecutionState.h
+++ b/include/klee/ExecutionState.h
@@ -336,6 +336,8 @@ public:
   /// used for searchers to decide what paths to explore
   double weight;
 
+  std::vector< llvm::Instruction*> history_br_instructions;
+
   /// @brief Exploration depth, i.e., number of times KLEE branched for this state
   unsigned depth;
 
diff --git a/include/klee/Expr.h b/include/klee/Expr.h
index 212053b..a950f92 100755
--- a/include/klee/Expr.h
+++ b/include/klee/Expr.h
@@ -24,6 +24,10 @@
 #include <vector>
 #include <map>
 
+#include <string>
+#include <mutex>
+
+
 namespace llvm {
   class Type;
   class raw_ostream;
@@ -38,6 +42,12 @@ class ObjectState;
 
 template<class T> class ref;
 
+//muqi
+extern std::string klee_muqi_compare_file_path;
+extern std::mutex mtx;
+extern std::string klee_muqi_external_function_file_path;
+extern std::string klee_muqi_external_bool_file_path;
+extern std::string klee_muqi_angr_numargs;
 
 /// Class representing symbolic expressions.
 /**
@@ -1001,9 +1011,11 @@ public:
 private:
   llvm::APInt value;
 
-  ConstantExpr(const llvm::APInt &v) : value(v) {}
+  //ConstantExpr(const llvm::APInt &v) : value(v) {}
 
 public:
+  //muqi
+  ConstantExpr(const llvm::APInt &v) : value(v) {}
   ~ConstantExpr() {}
 
   Width getWidth() const { return value.getBitWidth(); }
diff --git a/include/klee/Internal/Support/ErrorHandling.h b/include/klee/Internal/Support/ErrorHandling.h
index 2945169..3d8588a 100755
--- a/include/klee/Internal/Support/ErrorHandling.h
+++ b/include/klee/Internal/Support/ErrorHandling.h
@@ -16,6 +16,17 @@
 #endif
 #endif
 
+//muqi
+#include "klee/Internal/Support/ErrorHandling.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Function.h"
+#include "llvm/ADT/Twine.h"
+#include "llvm/Support/raw_ostream.h"
+
+
 #include <stdio.h>
 
 namespace klee {
@@ -23,6 +34,11 @@ namespace klee {
 extern FILE *klee_warning_file;
 extern FILE *klee_message_file;
 
+//muqi
+extern FILE *klee_muqi_file;
+extern FILE *klee_muqi_compare_file;
+extern FILE *klee_muqi_compare_file_test;
+
 /// Print "KLEE: ERROR: " followed by the msg in printf format and a
 /// newline on stderr and to warnings.txt, then exit with an error.
 void klee_error(const char *msg, ...)
@@ -32,6 +48,15 @@ void klee_error(const char *msg, ...)
 /// newline on stderr and to messages.txt.
 void klee_message(const char *msg, ...) __attribute__((format(printf, 1, 2)));
 
+
+//muqi
+void klee_muqi(const char *msg, ...) __attribute__((format(printf, 1, 2)));
+
+void klee_muqi_compare(const char *msg, ...) __attribute__((format(printf, 1, 2)));
+
+void klee_muqi_compare_test(const char *function_name, const char *msg, ...);
+
+
 /// Print "KLEE: " followed by the msg in printf format and a
 /// newline to messages.txt.
 void klee_message_to_file(const char *msg, ...)
diff --git a/lib/Core/AddressSpace.cpp b/lib/Core/AddressSpace.cpp
index 62f1fa7..2efced4 100755
--- a/lib/Core/AddressSpace.cpp
+++ b/lib/Core/AddressSpace.cpp
@@ -12,6 +12,8 @@
 #include "Memory.h"
 #include "TimingSolver.h"
 
+#include "klee/Internal/Support/ErrorHandling.h"
+
 #include "klee/Expr.h"
 #include "klee/TimerStatIncrementer.h"
 
diff --git a/lib/Core/ExecutionState.cpp b/lib/Core/ExecutionState.cpp
index c48e1a5..50a0c8f 100755
--- a/lib/Core/ExecutionState.cpp
+++ b/lib/Core/ExecutionState.cpp
@@ -22,6 +22,10 @@
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/raw_ostream.h"
 
+//muqi
+#include "llvm/ADT/APInt.h"
+#include "klee/Internal/Support/ErrorHandling.h"
+
 #include <iomanip>
 #include <sstream>
 #include <cassert>
@@ -244,6 +248,24 @@ ExecutionState::~ExecutionState() {
     cur_mergehandler->removeOpenState(this);
   }
 
+  //muqi
+  klee_muqi("Inside ExecutionState::~ExecutionState() \n");
+  int temp = 0;
+  klee_muqi("the address of stack will be poped are: \n");
+  for (std::vector<StackFrame>::iterator it = stack.begin() ; it != stack.end(); ++it){
+    //(*it).locals->value.get()->dump();
+    for (std::vector<const MemoryObject *>::iterator temp_it = (*it).allocas.begin(); temp_it != (*it).allocas.end(); ++ temp_it){
+      auto temp_address = reinterpret_cast<std::uint8_t*>((*temp_it)->address);
+      llvm::APInt outputtemp1 = llvm::APInt(Context::get().getPointerWidth(), (*temp_it)->address);
+      ConstantExpr *output = new ConstantExpr(outputtemp1);
+      //output->dump();
+      klee_muqi("address of mo memoryobject is %u\n",temp_address);
+    }
+    temp ++;
+  }
+  klee_muqi("the number of stackframe will be poped is %d\n",temp);
+  klee_muqi("double check by stack.size,  the number of stackframe is %d", stack.size());
+  klee_muqi("\n End of ExecutionState::~ExecutionState() printing \n");
 
   while (!stack.empty()) popFrame();
 }
@@ -834,8 +856,9 @@ void ExecutionState::updateLCMState() {
      }
      else if (seq->getType() == identifier) {
        if (curr != 0 ) {
-        Identifier *id = dynamic_cast<Identifier*>(seq);
-        assert(id);
+       // Identifier *id = dynamic_cast<Identifier*>(seq);
+        Identifier *id = static_cast<Identifier*>(seq);
+	assert(id);
         llvm::outs() << " next step " << id->getValue() << " to execute " << "\n";
         Function *func = moduleHandle->getFunction(id->getValue());
         //initiateAsync(func); 
diff --git a/lib/Core/Executor.cpp b/lib/Core/Executor.cpp
index 54e659c..520708e 100755
--- a/lib/Core/Executor.cpp
+++ b/lib/Core/Executor.cpp
@@ -82,6 +82,18 @@
 #include "klee/Internal/Support/CompressionStream.h"
 #endif
 
+//muqi
+#include "llvm/ADT/APInt.h"
+#include "llvm/IR/Metadata.h"
+#include "llvm/IR/DebugInfoMetadata.h"
+#ifdef ENABLE_Z3
+#include "./Z3Builder.h"
+#endif
+#define Muqi_DEBUG;
+#define Muqi_support_foreverloop;
+#define Muqi_external_call;
+#define Muqi_out_of_bound_pointer;
+
 #include <cassert>
 #include <algorithm>
 #include <iomanip>
@@ -95,6 +107,7 @@
 
 #include <errno.h>
 #include <cxxabi.h>
+#include <regex>
 
 using namespace llvm;
 using namespace klee;
@@ -1122,7 +1135,7 @@ bool isLoopBoundExcluded(std::string s, std::string fname) {
   }
   return false;
 }
-
+/*
 void addForkFreq(ExecutionState &state, std::string inst, bool isTrue) {
   long s = (long)&state;
   std::map<std::string, unsigned> m;
@@ -1165,6 +1178,25 @@ unsigned getForkFreq(ExecutionState &state, std::string inst, bool isTrue) {
      else return 0; 
   }
 }
+*/
+void addForkFreq(ExecutionState *state, llvm::Instruction* inst) {
+  state->history_br_instructions.push_back(inst);
+}
+unsigned getForkFreq(ExecutionState &state, llvm::Instruction* inst) {
+  unsigned result = 0;
+  for (auto i = state.history_br_instructions.begin(); i != state.history_br_instructions.end(); ++i){
+    if (*i == inst){
+      result= result + 1;
+    }
+  }
+  return result;
+}
+
+void showForkfreq(ExecutionState &state){
+  for (auto i = state.history_br_instructions.begin(); i != state.history_br_instructions.end(); ++i){
+    llvm::errs() << "\nhistory instruction " << **i << "\n";
+  }
+}
 
 
 std::string getAsyncFunction(std::string fn) {
@@ -1806,7 +1838,13 @@ bool isAllocTypeLazyInit(Type *t, bool &single, int &count) {
      }
   }
   if (t->getPrimitiveSizeInBits()) {
-      count = primArraySize; 
+      //count = primArraySize; 
+      
+      //muqi 256&8 we want the size of array be 256 bytes
+      count == 256*8/t->getPrimitiveSizeInBits();
+      if (count == 0)
+          count = 1;
+      
       single = false;
       return true;
   }
@@ -1849,7 +1887,14 @@ void collectEmbeddedPointerTypes(Type *t, std::vector<std::string> &lazyTypes, s
      else if (t->getPrimitiveSizeInBits()) {
         if (pointerType) {
            lazyTypes.push_back(rso.str());
-           lazyInitNumInstances[rso.str()] = primArraySize;
+           //lazyInitNumInstances[rso.str()] = primArraySize;
+	   
+	   //muqi 256&8 we want the size of array be 256 bytes
+	   int temp_count = 256*8/t->getPrimitiveSizeInBits();
+           if (temp_count == 0)
+             temp_count = 1;
+            
+           lazyInitNumInstances[rso.str()] = temp_count;
         }
      }
 
@@ -2590,9 +2635,14 @@ void Executor::branch(ExecutionState &state,
       addConstraint(*result[i], conditions[i]);
 }
 
+//muqi
 Executor::StatePair 
 Executor::fork(ExecutionState &current, ref<Expr> condition, bool isInternal) {
 
+  KInstruction *currentInstruction = current.prevPC;
+  Instruction *i = currentInstruction->inst;
+  klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Executor::StatePair Executor::fork");
+  klee_muqi("in the fork of Executor::\n");
 
   Solver::Validity res;
   std::map< ExecutionState*, std::vector<SeedInfo> >::iterator it = 
@@ -2621,6 +2671,10 @@ Executor::fork(ExecutionState &current, ref<Expr> condition, bool isInternal) {
       bool success = solver->getValue(current, condition, value);
       assert(success && "FIXME: Unhandled solver failure");
       (void) success;
+      //start of symbolic execution 151515
+      klee_muqi("in if condition of !isSeeding && !isa<ConstantExpr>(condition) && \n");
+      klee_muqi_compare_test(i->getFunction()->getName().data(),"\nIn if condition of !isSeeding && !isa<ConstantExpr>(condition) &&");
+      
       addConstraint(current, EqExpr::create(value, condition));
       current.lastConstraint = EqExpr::create(value, condition);
       condition = value;
@@ -2653,10 +2707,14 @@ Executor::fork(ExecutionState &current, ref<Expr> condition, bool isInternal) {
         // add constraints
         if(branch) {
           res = Solver::True;
+          klee_muqi("in if condition of isSeeding, branch is true \n");
+          klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside fork, First branch");
           addConstraint(current, condition);
           current.lastConstraint = condition;
         } else  {
           res = Solver::False;
+          klee_muqi("in if condition of isSeeding, branch is false \n");
+          klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside fork, Second branch");
           addConstraint(current, Expr::createIsZero(condition));
           current.lastConstraint = Expr::createIsZero(condition);
         }
@@ -2680,10 +2738,16 @@ Executor::fork(ExecutionState &current, ref<Expr> condition, bool isInternal) {
 
         TimerStatIncrementer timer(stats::forkTime);
         if (theRNG.getBool()) {
+          klee_muqi("in if condition of not isSeeding, branch is true \n");
+          klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside fork, First branch");
+          
           addConstraint(current, condition);
           res = Solver::True;        
           current.lastConstraint = condition;
         } else {
+          klee_muqi("in if condition of not isSeeding, branch is false \n");
+          klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside fork, Second branch");
+          
           addConstraint(current, Expr::createIsZero(condition));
           res = Solver::False;
           current.lastConstraint = Expr::createIsZero(condition);
@@ -2718,6 +2782,9 @@ Executor::fork(ExecutionState &current, ref<Expr> condition, bool isInternal) {
       assert(trueSeed || falseSeed);
       
       res = trueSeed ? Solver::True : Solver::False;
+      klee_muqi("in Fix branch in only-replay-seed mode, if we don't have both true \n");
+      klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside fork, Fix branch in only-replay-seed mode");
+      
       addConstraint(current, trueSeed ? condition : Expr::createIsZero(condition));
       if (trueSeed)
          current.lastConstraint = condition;
@@ -2816,8 +2883,19 @@ Executor::fork(ExecutionState &current, ref<Expr> condition, bool isInternal) {
       }
     }
 
+    #ifndef Muqi_support_foreverloop
+    klee_muqi("Add constraint for trueStatement final\n");
+    klee_muqi_compare_test(i->getFunction()->getName().data(),"\nAdd constraint for trueStatement ");
+    #endif
+
     addConstraint(*trueState, condition);
     trueState->lastConstraint = condition;
+
+    #ifndef Muqi_support_foreverloop
+    klee_muqi("Add constraint for falseStatement final\n");
+    klee_muqi_compare_test(i->getFunction()->getName().data(),"\nAdd constraint for falseStatement  ");
+    #endif 
+
     addConstraint(*falseState, Expr::createIsZero(condition));
     falseState->lastConstraint = Expr::createIsZero(condition);
     // Kinda gross, do we even really still want this option?
@@ -3128,9 +3206,11 @@ void Executor::executeCall(ExecutionState &state,
       klee_error("unknown intrinsic: %s", f->getName().data());
     }
 
-    if (InvokeInst *ii = dyn_cast<InvokeInst>(i))
+    if (InvokeInst *ii = dyn_cast<InvokeInst>(i)){
+      klee_muqi_compare_test(i->getFunction()->getName().data(),"\nfunction declared, executeCall named: %s, transferToBasicBlock ",f->getName().data()); 
       transferToBasicBlock(ii->getNormalDest(), i->getParent(), state);
       successorsPaths->insert(&state);
+    }
   } else {
 
        /* SYSREL extension */
@@ -3174,9 +3254,14 @@ void Executor::executeCall(ExecutionState &state,
     // instead of the actual instruction, since we can't make a KInstIterator
     // from just an instruction (unlike LLVM).
     KFunction *kf = kmodule->functionMap[f];
+    klee_muqi_compare_test(i->getFunction()->getName().data(),"\nfunction not declared, executeCall named: %s, state.pc ++ ", f->getName().data());
+    klee_muqi("Inside Executor::executeCall, state.pc before is %d", state.pc);
+
     state.pushFrame(state.prevPC, kf);
     state.pc = kf->instructions;
-
+    
+    klee_muqi("Inside Executor::executeCall, state.pc after is %d", state.pc);
+    
     if (recordStackTraces)
        recordStackTrace(state);
 
@@ -3384,11 +3469,96 @@ static inline const llvm::fltSemantics * fpWidthToSemantics(unsigned width) {
   }
 }
 
+//muqi
+void muqi_transfertoblock_info(BasicBlock *BB_src,BasicBlock *BB_dest,Instruction *inst_src, Instruction *inst_dest){
+      //muqi: add for identifing the block will be executed 
+      Function *Func;
+      if (BB_src){
+        Func = BB_src->getFirstNonPHI()->getFunction();
+        int temp_BB = 0;
+        int BB_src_num = -1;
+        int BB_dest_num = -1;
+        for (Function::iterator BB_temp = Func->begin(), E = Func->end(); BB_temp != E; ++BB_temp) {
+            if (BB_src == (&*BB_temp)){
+              BB_src_num = temp_BB;
+            }
+            if (BB_dest == (&*BB_temp)){
+              BB_dest_num = temp_BB;
+            }
+            temp_BB ++;
+        }
+        klee_muqi_compare_test(Func->getName().data(),"\nTransferTobasic (used for lifter.ll), BB from %d to %d ", BB_src_num, BB_dest_num );
+        //muqi: add end
+        //muqi: have the metadata of line number
+        DILocation *Loc;
+        unsigned Line_src = 2147483647;
+        unsigned Line_des = 2147483647;
+        //find the line info for source of BB
+        if (Loc = BB_src->getFirstNonPHI()->getDebugLoc()) { 
+          Line_src =  Loc->getLine();
+        }
+        //if first line of BB has some errors, find the instruction line being executed.
+        if (Line_src == 2147483647 && inst_src) {
+          if (Loc = inst_src->getDebugLoc()) { 
+            Line_src =  Loc->getLine();
+          }
+        }
+
+        //find the line info for destination of BB
+        if(BB_dest == NULL) {
+          Line_des = 2147483647;
+        }else{
+          if (Loc = BB_dest->getFirstNonPHI()->getDebugLoc()){
+            Line_des =  Loc->getLine();
+          }
+        }
+        
+        if (Line_des == 2147483647 && inst_dest) {
+          if (Loc = inst_dest->getDebugLoc()) { 
+            Line_des =  Loc->getLine();
+          }
+        }
+        klee_muqi_compare_test(Func->getName().data(),"\nTransferTobasic (used for generatedc.ll), Linenumber of instruction in c file from %d to %d ", Line_src, Line_des );
+        klee_muqi("\nTransferTobasic (used for lifter.ll), BB from %d to %d ", BB_src_num, BB_dest_num );
+        klee_muqi("\nTransferTobasic (used for generatedc.ll), Linenumber of instruction in c file from %d to %d ", Line_src, Line_des );
+        //muqi: add end
+      }else {
+        Func = NULL;
+        klee_muqi_compare_test("unknown","\nTransferTobasic (used for lifter.ll), BB from -1 to -1 ");
+        klee_muqi_compare_test("unknown","\nTransferTobasic (used for generatedc.ll), Linenumber of instruction in c file from 2147483647 to 2147483647 ");
+        klee_muqi("\nTransferTobasic (used for lifter.ll), BB from -1 to -1 ");
+        klee_muqi("\nTransferTobasic (used for generatedc.ll), Linenumber of instruction in c file from 2147483647 to 2147483647 ");
+        
+      }
+      
+      
+      
+}
+
+//muqi
+std::vector<Instruction *> vector_i;
+std::vector<ExecutionState *>vector_state;
+std::vector<KInstruction *>vector_ki;
+std::vector<ref<Expr> >vector_constantexpr;
+std::vector<BasicBlock *> vector_BB_symbolized;
+
+
 void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
 
   state.stackFrameBeforeExecInst = state.stack.size() - 1; 
 
   Instruction *i = ki->inst;
+
+  //muqi
+  std::string temp_out = i->getOpcodeName();
+  klee_muqi("current instruction for this instruction is %d", state.prevPC);
+  klee_muqi("next instruction for this instruction is %d", state.pc);
+  klee_muqi("current Function name is: %s", i->getFunction()->getName());
+ 
+  klee_muqi("Instruction is: %s; ", temp_out.c_str());
+  const InstructionInfo *temp_info = ki->info;
+  klee_muqi("corresponding assembly line is %d \n", temp_info->assemblyLine);
+
   switch (i->getOpcode()) {
     // Control flow
   case Instruction::Ret: {
@@ -3402,7 +3572,7 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
     /* SYSREL EXTENSION */
     state.checkAndSetPMCallbackCompleted(ri->getParent()->getParent()->getName());
     /* SYSREL EXTENSION */
-
+    klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Ret ");
     llvm::outs() << "handling return for function " << ri->getParent()->getParent()->getName()  << "\n";
     if (!isVoidReturn) {
       result = eval(ki, 0, state).value;
@@ -3424,6 +3594,12 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
        generateValuedInstruction(state, ki);
 
     if (state.stack.size() <= 1) {
+      muqi_transfertoblock_info(i->getParent(),NULL,i,NULL);
+      klee_muqi("\nInside Ret, state.stack.size() is 1\n");
+      klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Ret state.pc ++");
+      klee_muqi("\nInside Ret, state.pc ++ , state.pc before is %d", state.pc);
+
+
       assert(!caller && "caller set on initial stack frame");
       /* SYSREL extension */
 
@@ -3503,6 +3679,7 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
       }
       /* SYSREL extension */
     } else {
+      klee_muqi("\nInside Ret, state.stack.size() is more than one\n");
       state.stackFrameBeforeExecInst = state.stack.size() - 1; 
       state.popFrame();
 
@@ -3511,13 +3688,26 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
 
       if (InvokeInst *ii = dyn_cast<InvokeInst>(caller)) {
         llvm::outs() << "returning to basic block of " << (*caller) << "\n";
+        //muqi
+                muqi_transfertoblock_info(caller->getParent(),ii->getNormalDest(),i,caller);
+        klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Ret transferToBasicBlock ");
+        klee_muqi("\nInside Instruction::Ret transferToBasicBlock ");
+
         transferToBasicBlock(ii->getNormalDest(), caller->getParent(), state);
       } else {
+        //muqi
+        muqi_transfertoblock_info(i->getParent(),caller->getParent(),i,caller);
+        klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Ret state.pc ++");
+        klee_muqi("\nInside Ret, state.pc ++ , state.pc before is %d", state.pc);
+
         state.pc = kcaller;
         ++state.pc;
+
+        klee_muqi("\nInside Ret, state.pc ++ , state.pc after is %d", state.pc);
+        
         llvm::outs() << "returning to " <<  (*state.pc->inst) << "\n"; 
       }
-
+      klee_muqi("In ret, Function name is: %s", caller->getFunction()->getName());
       if (!isVoidReturn) {
         Type *t = caller->getType();
         if (t != Type::getVoidTy(i->getContext())) {
@@ -3544,31 +3734,135 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
         // We check that the return value has no users instead of
         // checking the type, since C defaults to returning int for
         // undeclared functions.
-        /* SYSREL extension */        
-        llvm::errs() << "Warning: return void when caller expected a result\n";
+        /* SYSREL extension */  
+        //muqi
+        result = ConstantExpr::alloc(0, Expr::Int64);
+        bindLocal(kcaller, state, result);
+        klee_warning("Injected fake return for function: %s",
+                       ri->getFunction()->getName().str().c_str());
+
+        //llvm::errs() << "Warning: return void when caller expected a result\n";
         /* SYSREL extension */
       }
-    }      
+    } 
+
+//muqi
+    if (result.isNull() == true ){
+      result = ConstantExpr::alloc(0, Expr::Int64);
+    }
+    result->dump();
+    #ifdef ENABLE_Z3
+    Z3Builder temp_build = Z3Builder(false,NULL);
+    //Z3ASTHandle result_z3 = temp_build.construct(result);
+    int *width = (int *)malloc(sizeof(int));
+      *width = 0;
+    Z3ASTHandle result_z3 = temp_build.construct_muqi(result,width);
+    llvm::errs()<<"after result dumped, *width is:" << *width<<"\n";
+    if (*width == 1){
+
+      *width = 64;
+      result = SelectExpr::create(result,ConstantExpr::create(1,64),ConstantExpr::create(0,64));
+      result_z3 = temp_build.construct_muqi(result,width);  
+    }
+    while (*width < 64 && *width != 1){
+      //concat the result to 64bits
+        result = ConcatExpr::create(ConstantExpr::create(0,8),result);
+        result_z3 = temp_build.construct_muqi(result,width);  
+        llvm::errs()<<"after result dumped, *width is:" << *width<<"\n";
+    }
+    result_z3.dump();
+    
+    #endif  
+
     break;
   }
   case Instruction::Br: {
     BranchInst *bi = cast<BranchInst>(i);
     if (bi->isUnconditional()) {
-      transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), state);
-      successorsPaths->insert(&state);
+      //muqi add loopbound here, since the loop use unconditional branch to back to previous label, which generates the loop
+      //possible error??
+      Function *func_unconditon = i->getParent()->getParent(); 
+      bool lbe_uncondition = isLoopBoundExcluded(state.prevPC->getSourceLocation(), func_unconditon->getName());
+      llvm::errs() << "loop bound= " << loopBound  << " excl? " << lbe_uncondition << "\n";
+
+      if (loopBound && !lbe_uncondition) {
+        unsigned tc;
+        tc = getForkFreq(state, i);
+        showForkfreq(state);
+        addForkFreq(&state, i);
+        if (tc >= loopBound) {
+            llvm::errs() << "path terminated early due to reaching bound for unconditional branches\n";
+            terminateStateEarly(state, "Loop Bound for unconditional reached\n");
+            //muqi, we give a fake return value
+            klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Ret");
+            //klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Br uncondition transferToBasicBlock ");
+            muqi_transfertoblock_info(i->getParent(),NULL,i,NULL);
+            klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Ret state.pc ++");
+            ref<Expr> fake_result =NULL;
+            fake_result = ConstantExpr::alloc(0, Expr::Int64);
+            fake_result->dump();
+            Z3Builder temp_build = Z3Builder(false,NULL);
+            int *width = (int *)malloc(sizeof(int));
+            *width = 64;
+            #ifdef ENABLE_Z3
+            Z3ASTHandle fake_result_z3 = temp_build.construct_muqi(fake_result,width);
+            fake_result_z3.dump();
+            #endif
+        }
+        else{
+            klee_muqi("br in Unconditional \n");
+            klee_muqi("br is %d \n", bi);
+            klee_muqi("br transfer from %d to %d\n", bi->getParent(), bi->getSuccessor(0));
+            klee_muqi_compare_test(i->getFunction()->getName().data(),"\nbr in Unconditional ");
+            klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Br uncondition transferToBasicBlock ");
+            //muqi: add for identifing the block will be executed 
+            muqi_transfertoblock_info(i->getParent(),bi->getSuccessor(0),i,NULL);
+            transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), state);
+            successorsPaths->insert(&state);
+        }
+      }
+      else{
+        klee_muqi("br in Unconditional \n");
+        klee_muqi("br is %d \n", bi);
+        klee_muqi("br transfer from %d to %d\n", bi->getParent(), bi->getSuccessor(0));
+        klee_muqi_compare_test(i->getFunction()->getName().data(),"\nbr in Unconditional ");
+        klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Br uncondition transferToBasicBlock ");
+        //muqi: add for identifing the block will be executed 
+        muqi_transfertoblock_info(i->getParent(),bi->getSuccessor(0),i,NULL);
+        transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), state);
+        successorsPaths->insert(&state);
+      }
     } else {
       // FIXME: Find a way that we don't have this hidden dependency.
+      klee_muqi("br in conditional \n");
+      klee_muqi("br is %d \n", bi);
+      klee_muqi_compare_test(i->getFunction()->getName().data(),"\nbr in conditional ");
       assert(bi->getCondition() == bi->getOperand(0) &&
              "Wrong operand index!");
       ref<Expr> cond = eval(ki, 0, state).value;
+      
+      Expr *temp = cond.get();
+     // cond = optimizer.optimizeExpr(cond, false);
       Executor::StatePair branches = fork(state, cond, false);
+      
+      #ifdef Muqi_support_foreverloop
+      ref<Expr> cond_to_log = cond;
+      if (branches.first){
+          cond_to_log = branches.first->lastConstraint;          
+      }
+      #endif
 
-      if (branches.first)
+      klee_muqi_compare_test(i->getFunction()->getName().data(),"\nFork finished");
+      klee_muqi("Fork finished\n");
+      if (branches.first){
          branches.first->lastBranchInstConstraint = branches.first->lastConstraint;
-
-      if (branches.second)
+	 branches.first->history_br_instructions = state.history_br_instructions;
+         
+      }
+      if (branches.second){
          branches.second->lastBranchInstConstraint = branches.second->lastConstraint;
-
+	 branches.second->history_br_instructions = state.history_br_instructions;
+      }
       // NOTE: There is a hidden dependency here, markBranchVisited
       // requires that we still be in the context of the branch
       // instruction (it reuses its statistic id). Should be cleaned
@@ -3582,7 +3876,9 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
       bool lbe = isLoopBoundExcluded(state.prevPC->getSourceLocation(), func->getName());
       //llvm::errs() << "loop bound= " << loopBound  << " excl? " << lbe << "\n";
       if (loopBound && !lbe) {
-         if (branches.first) {
+         
+	 /*
+	 if (branches.first) {
             addForkFreq(state,getSourceWithContext(state, state.prevPC), true);
          }
 
@@ -3591,31 +3887,105 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
          }
          tc = getForkFreq(state, getSourceWithContext(state, state.prevPC), true);
          fc = getForkFreq(state, getSourceWithContext(state, state.prevPC), false);
+	*/
+	 tc = getForkFreq(state, i);
+	 fc = tc;
+	 if (branches.first) {
+             addForkFreq(branches.first, i);
+         }
+
+         if (branches.second) {
+             addForkFreq(branches.second, i);
+         }
+
          llvm::errs() << "forked at " << state.prevPC->getSourceLocation() << " true branch " << tc << " times\n";
          llvm::errs() << "forked at " << state.prevPC->getSourceLocation() << " false branch " << fc << " times\n";
          
          if (branches.first && branches.second) {
-            if (fc > loopBound && tc > loopBound) {
-               // terminate state
+            vector_BB_symbolized.push_back(i->getParent());
+            llvm:errs() << "i->getParent()" << i->getParent() <<"\n";
+	    //if (fc > loopBound && tc > loopBound) {
+            if (fc >= loopBound && tc >= loopBound) { 
+	      // terminate state
                llvm::errs() << "path terminated early due to reaching bound for both branches\n";
                terminateStateEarly(state, "Loop Bound for both successors reached\n");
-            }
+            
+	       //we need to pop the addstates, since in previous fork(), we "addedStates.push_back(falseState);"!!!
+               addedStates.pop_back();
+
+               //muqi, we give a fake return value
+               klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Ret");
+               //klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Br uncondition transferToBasicBlock ");
+               muqi_transfertoblock_info(i->getParent(),NULL,i,NULL);
+               klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Ret state.pc ++");
+               ref<Expr> fake_result =NULL;
+               fake_result = ConstantExpr::alloc(0, Expr::Int64);
+               fake_result->dump();
+               Z3Builder temp_build = Z3Builder(false,NULL);
+               int *width = (int *)malloc(sizeof(int));
+               *width = 64;
+               #ifdef ENABLE_Z3
+               Z3ASTHandle fake_result_z3 = temp_build.construct_muqi(fake_result,width);
+               fake_result_z3.dump();
+               #endif
+	    }
+	    /*
             else if (tc > loopBound) {
                llvm::errs() << "path terminated for the true branch\n";
                terminateStateEarly(*branches.first, "Loop Bound for true successor reached\n");
+
+	       klee_muqi_compare_test(i->getFunction()->getName().data(),"\n1Inside Instruction::Br condition second transferToBasicBlock ");
+               klee_muqi("\nInside Instruction::Br condition second transferToBasicBlock ");
+               //muqi: add for identifing the block will be executed
+               muqi_transfertoblock_info(i->getParent(),bi->getSuccessor(1),i,NULL);
+
                transferToBasicBlock(bi->getSuccessor(1), bi->getParent(), *branches.second); 
                successorsPaths->insert(branches.second);
             }
             else if (fc > loopBound) {
                llvm::errs() << "path terminated for the false branch\n";
                terminateStateEarly(*branches.second, "Loop Bound for false successor reached\n");
-               transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.first);
+               
+	       klee_muqi_compare_test(i->getFunction()->getName().data(),"\n2Inside Instruction::Br condition first transferToBasicBlock ");
+               klee_muqi("\nInside Instruction::Br condition first transferToBasicBlock ");
+               //muqi: add for identifing the block will be executed 
+               muqi_transfertoblock_info(i->getParent(),bi->getSuccessor(0),i,NULL);
+
+	       transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.first);
                successorsPaths->insert(branches.first);
-            }
+            }*/
             else {
-               transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.first);
+               
+	       #ifdef Muqi_support_foreverloop		
+               klee_muqi("Add constraint for trueStatement final\n");
+               klee_muqi_compare_test(i->getFunction()->getName().data(),"\nAdd constraint for trueStatement ");
+
+               #if defined(Muqi_DEBUG)
+               cond_to_log->dump();
+               #ifdef ENABLE_Z3
+               Z3Builder temp_build = Z3Builder(false,NULL);
+               Z3ASTHandle result_z3 = temp_build.construct(cond_to_log);
+               result_z3.dump();
+               #endif
+                
+               #endif
+               klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::3Br condition first transferToBasicBlock ");
+               klee_muqi("\nInside Instruction::Br condition first transferToBasicBlock ");
+               //muqi: add for identifing the block will be executed 
+               muqi_transfertoblock_info(i->getParent(),bi->getSuccessor(0),i,NULL);
+               #endif 
+
+	       transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.first);
                successorsPaths->insert(branches.first);
-               transferToBasicBlock(bi->getSuccessor(1), bi->getParent(), *branches.second);
+               
+	       #ifdef Muqi_support_foreverloop
+               klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::4Br condition second transferToBasicBlock ");
+               klee_muqi("\nInside Instruction::Br condition second transferToBasicBlock ");
+               //muqi: add for identifing the block will be executed 
+               muqi_transfertoblock_info(i->getParent(),bi->getSuccessor(1),i,NULL);  
+               #endif 
+	       
+	       transferToBasicBlock(bi->getSuccessor(1), bi->getParent(), *branches.second);
                successorsPaths->insert(branches.second);
                singleSuccessor = false;
                bool abort = false;
@@ -3635,24 +4005,78 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
          }         
          else {
             if (branches.first) {
-               if (tc > loopBound) {
-                  llvm::errs() << "branching to the false successor due to reaching loop bound for the true branch\n";
-                  transferToBasicBlock(bi->getSuccessor(1), bi->getParent(), *branches.first);
-                  successorsPaths->insert(branches.first);
+               if (tc >= loopBound) {
+		   //muqi, we give a fake return value
+                   klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Ret");
+                   //klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Br uncondition transferToBasicBlock ");
+                   muqi_transfertoblock_info(i->getParent(),NULL,i,NULL);
+                   klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Ret state.pc ++");
+                   ref<Expr> fake_result =NULL;
+                   fake_result = ConstantExpr::alloc(0, Expr::Int64);
+                   fake_result->dump();
+                   Z3Builder temp_build = Z3Builder(false,NULL);
+                   int *width = (int *)malloc(sizeof(int));
+                   *width = 64;
+                   #ifdef ENABLE_Z3
+                   Z3ASTHandle fake_result_z3 = temp_build.construct_muqi(fake_result,width);
+                   fake_result_z3.dump();
+                   #endif
+                 
+		     //llvm::errs() << "branching to the false successor due to reaching loop bound for the true branch\n";
+                     llvm::errs() << "path terminated for the true branch2 instead of branching to the false successor due to reaching loop bound for the true branch\n";
+                     terminateStateEarly(*branches.first, "Loop Bound for true successor reached\n");
+
+                     //muqi we do not want to run false successor anymore.
+                     //transferToBasicBlock(bi->getSuccessor(1), bi->getParent(), *branches.first);
+                     transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.first);
+
+                     //llvm::errs() << "branching to the false successor due to reaching loop bound for the true branch\n";
+                     //transferToBasicBlock(bi->getSuccessor(1), bi->getParent(), *branches.first);
+                     successorsPaths->insert(branches.first);
+		   
                }
                else {
+		  klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::6Br condition first transferToBasicBlock ");
+                  klee_muqi("\nInside Instruction::Br condition first transferToBasicBlock ");
+                  //muqi: add for identifing the block will be executed
+                  muqi_transfertoblock_info(i->getParent(),bi->getSuccessor(0),i,NULL);
                   transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.first);
                   successorsPaths->insert(branches.first);  
                }
             }
             if (branches.second) {
-               if (fc > loopBound) {
-                  //llvm::errs() << "path terminated for the false branch\n";
-                  //terminateStateEarly(*branches.second, "Loop Bound for false successor reached\n");                  
+               if (fc >= loopBound) {
+                  //muqi, we give a fake return value
+                  klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Ret");
+                  //klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Br uncondition transferToBasicBlock ");
+                  muqi_transfertoblock_info(i->getParent(),NULL,i,NULL);
+                  klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Ret state.pc ++");
+                  ref<Expr> fake_result =NULL;
+                  fake_result = ConstantExpr::alloc(0, Expr::Int64);
+                  fake_result->dump();
+                  Z3Builder temp_build = Z3Builder(false,NULL);
+                  int *width = (int *)malloc(sizeof(int));
+                  *width = 64;
+                  #ifdef ENABLE_Z3
+                  Z3ASTHandle fake_result_z3 = temp_build.construct_muqi(fake_result,width);
+                  fake_result_z3.dump();
+                  #endif
+
+		  llvm::errs() << "path terminated for the false branch\n";
+                  terminateStateEarly(*branches.second, "Loop Bound for false successor reached\n");                  
                   transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.second);
                   successorsPaths->insert(branches.second);
                }
-               else {               
+               else {
+		  klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::8Br condition second transferToBasicBlock ");
+                  klee_muqi("\nInside Instruction::Br condition second transferToBasicBlock ");
+                  //muqi: add for identifing the block will be executed
+                  muqi_transfertoblock_info(i->getParent(),bi->getSuccessor(0),i,NULL);
+		  //added by muqi to fix double loop
+                  llvm::errs() << "path terminated for the false branch2\n";
+                  //terminateStateEarly(*branches.second, "Loop Bound for false successor reached\n");              
+                  //transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.second);
+                  	       
                   transferToBasicBlock(bi->getSuccessor(1), bi->getParent(), *branches.second);
                   successorsPaths->insert(branches.second);
                }
@@ -3661,10 +4085,20 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
       }
       else {
          if (branches.first) {
+            klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Br condition first transferToBasicBlock ");
+            klee_muqi("\nInside Instruction::Br condition first transferToBasicBlock ");
+            //muqi: add for identifing the block will be executed 
+            muqi_transfertoblock_info(i->getParent(),bi->getSuccessor(0),i,NULL);
+            
             transferToBasicBlock(bi->getSuccessor(0), bi->getParent(), *branches.first);
             successorsPaths->insert(branches.first);
          }
          if (branches.second) {
+            klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Br condition second transferToBasicBlock ");
+            klee_muqi("\nInside Instruction::Br condition second transferToBasicBlock ");
+            //muqi: add for identifing the block will be executed 
+            muqi_transfertoblock_info(i->getParent(),bi->getSuccessor(1),i,NULL);
+
             transferToBasicBlock(bi->getSuccessor(1), bi->getParent(), *branches.second);
             successorsPaths->insert(branches.second);
          }
@@ -3693,13 +4127,20 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
   }
   case Instruction::IndirectBr: {
     // implements indirect branch to a label within the current function
+    klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::IndirectBr");
+    
     const auto bi = cast<IndirectBrInst>(i);
     auto address = eval(ki, 0, state).value;
     address = toUnique(state, address);
 
     // concrete address
     if (const auto CE = dyn_cast<ConstantExpr>(address.get())) {
+      klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::IndirectBr first transferToBasicBlock ");
+      
       const auto bb_address = (BasicBlock *) CE->getZExtValue(Context::get().getPointerWidth());
+
+      //muqi: add for identifing the block will be executed 
+      muqi_transfertoblock_info(i->getParent(),bb_address,i,NULL);
       transferToBasicBlock(bb_address, bi->getParent(), state);
       successorsPaths->insert(&state);
       break;
@@ -3759,6 +4200,10 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
     assert(targets.size() == branches.size());
     for (std::vector<ExecutionState *>::size_type k = 0; k < branches.size(); ++k) {
       if (branches[k]) {
+
+        klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::IndirectBr for loop transferToBasicBlock ");
+        //muqi: add for identifing the block will be executed 
+        muqi_transfertoblock_info(i->getParent(),targets[k],i,NULL); 
         transferToBasicBlock(targets[k], bi->getParent(), *branches[k]);
         successorsPaths->insert(branches[k]);
       }
@@ -3767,6 +4212,8 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
     break;
   }
   case Instruction::Switch: {
+    klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Switch");
+    
     SwitchInst *si = cast<SwitchInst>(i);
     ref<Expr> cond = eval(ki, 0, state).value;
     BasicBlock *bb = si->getParent();
@@ -3778,6 +4225,13 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
       llvm::IntegerType *Ty = cast<IntegerType>(si->getCondition()->getType());
       ConstantInt *ci = ConstantInt::get(Ty, CE->getZExtValue());
       unsigned index = si->findCaseValue(ci).getSuccessorIndex();
+
+
+      klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Switch first transferToBasicBlock ");
+      
+      //muqi: add for identifing the block will be executed 
+      muqi_transfertoblock_info(si->getParent(),si->getSuccessor(index),i,NULL); 
+
       transferToBasicBlock(si->getSuccessor(index), si->getParent(), state);
       successorsPaths->insert(&state);
     } else {
@@ -3877,6 +4331,11 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
            it != ie; ++it) {
         ExecutionState *es = *bit;
         if (es) {
+          klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Switch second transferToBasicBlock ");
+          //muqi: add for identifing the block will be executed
+          muqi_transfertoblock_info(bb,*it,i,NULL); 
+
+
           transferToBasicBlock(*it, bb, *es);
           successorsPaths->insert(es); 
         }
@@ -3885,14 +4344,35 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
     }
     break;
   }
-  case Instruction::Unreachable:
+  case Instruction::Unreachable:{
     // Note that this is not necessarily an internal bug, llvm will
     // generate unreachable instructions in cases where it knows the
     // program will crash. So it is effectively a SEGV or internal
     // error.
-    terminateStateOnExecError(state, "reached \"unreachable\" instruction");
+    //original
+    //terminateStateOnExecError(state, "reached \"unreachable\" instruction");
+    
+    //muqi add for abort()
+    terminateStateEarly(state, "Instruction::Unreachable: termiantes state\n");
+               
+    //muqi, we give a fake return value
+    klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Ret");
+    //klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Instruction::Br uncondition transferToBasicBlock ");
+    muqi_transfertoblock_info(i->getParent(),NULL,i,NULL);
+    klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside Ret state.pc ++");
+    ref<Expr> fake_result =NULL;
+    fake_result = ConstantExpr::alloc(0, Expr::Int64);
+    fake_result->dump();
+    Z3Builder temp_build = Z3Builder(false,NULL);
+    int *width = (int *)malloc(sizeof(int));
+    *width = 64;
+    #ifdef ENABLE_Z3
+    Z3ASTHandle fake_result_z3 = temp_build.construct_muqi(fake_result,width);
+    fake_result_z3.dump();
+    #endif
     break;
 
+   }
   case Instruction::Invoke:
   case Instruction::Call: {
     CallSite cs(i);
@@ -4283,17 +4763,57 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
  
     // Memory instructions...
   case Instruction::Alloca: {
-    AllocaInst *ai = cast<AllocaInst>(i);
-    unsigned elementSize = 
-      kmodule->targetData->getTypeStoreSize(ai->getAllocatedType());
-    ref<Expr> size = Expr::createPointer(elementSize);
-    if (ai->isArrayAllocation()) {
-      ref<Expr> count = eval(ki, 0, state).value;
-      count = Expr::createZExtToPointerWidth(count);
-      size = MulExpr::create(size, count);
+    klee_muqi("Inside Allocate case\n");
+
+
+  //muqi change here!!!
+///*
+    Instruction *temp_next = state.pc->inst;
+    //for here, we use a vector to store all alloca instructions at the begining of function, which can be first in first out.
+    //when the last alloca instruction is executed, we allocate all instructions in vector.
+    if (temp_next){
+      unsigned temp_out_next = temp_next->getOpcode();
+      klee_muqi("Next Instruction num is: %u; ", temp_out_next); //alloc == 29 for llvm 3.8, alloc == 31 for llvm 10
+      if (temp_out_next == Instruction::Alloca){
+        klee_muqi(" Here we push to vector\n");
+        vector_i.push_back(i);
+        vector_ki.push_back(ki);
+        vector_state.push_back(&state);
+
+      }else{
+        vector_i.push_back(i);
+        vector_ki.push_back(ki);
+        vector_state.push_back(&state);
+
+        klee_muqi(" Here we allocate all\n");
+        int count = 0;
+        while(!vector_i.empty()){
+              klee_muqi(" count is %u\n",count);
+              count ++;
+              Instruction *temp_i = vector_i.back();
+              vector_i.pop_back();
+              KInstruction *temp_ki = vector_ki.back();
+              vector_ki.pop_back();
+              ExecutionState *temp_state = vector_state.back();
+              vector_state.pop_back();
+
+              AllocaInst *ai = cast<AllocaInst>(temp_i);
+              unsigned elementSize = 
+                kmodule->targetData->getTypeStoreSize(ai->getAllocatedType());
+              ref<Expr> size = Expr::createPointer(elementSize);
+              if (ai->isArrayAllocation()) {
+                ref<Expr> count = eval(temp_ki, 0, *temp_state).value;
+                count = Expr::createZExtToPointerWidth(count);
+                size = MulExpr::create(size, count);
+              }
+              executeAlloc(*temp_state, size, true, temp_ki);
+        }
+      }   
     }
-    executeAlloc(state, size, true, ki);
-    break;
+    else{
+      klee_muqi("SOME HORRIBLE THING WRONG IN ALLOCATE\n");
+    }
+  break;
   }
 
   case Instruction::Load: {
@@ -4304,6 +4824,15 @@ void Executor::executeInstruction(ExecutionState &state, KInstruction *ki) {
   case Instruction::Store: {
     ref<Expr> base = eval(ki, 1, state).value;
     ref<Expr> value = eval(ki, 0, state).value;
+    /*
+    klee_muqi("Inside instruction:store ");
+    klee_muqi("value is ");
+    value.get()->print(errs());
+    errs()<<"\n";
+    klee_muqi("base is ");
+    base.get()->print(errs());
+    errs()<<"\n";
+    */
     executeMemoryOperation(state, true, base, value, 0);
     break;
   }
@@ -4972,6 +5501,8 @@ void Executor::doDumpStates() {
 
 }
 
+int muqi_external_call_function_once = 0;
+
 void Executor::run(ExecutionState &initialState) {
   bindModuleConstants();
 
@@ -5136,11 +5667,261 @@ void Executor::run(ExecutionState &initialState) {
     else {
     /* SYSREL */
       KInstruction *ki = state.pc;
+      const InstructionInfo *temp_info = ki->info;
+      
       stepInstruction(state);
       singleSuccessor = true;
       llvm::errs() << "\nnext instruction: " << (*ki->inst) << "\n";
       ExprPPrinter::printConstraints(llvm::errs(), state.constraints);
-      executeInstruction(state, ki);
+
+     // executeInstruction(state, ki);
+      //for here, when we face the call instruction in main, skip it and assign 0 as the return result. 
+    #if defined(Muqi_external_call)
+          Instruction *i = ki->inst;
+	  Type *t = i->getType();
+	  if (i->getOpcode() == Instruction::Call){
+
+		bool run_external = false;
+                std::ifstream file(klee_muqi_external_bool_file_path);
+
+		llvm::errs() << "\nklee_muqi_angr_numargs1: " << klee_muqi_angr_numargs << "\n";
+		llvm::errs() << "\nEntryPoint1: " <<EntryPoint << "\n";
+
+		
+		std::string filename = klee_muqi_angr_numargs;
+		filename.erase(filename.length()-EntryPoint.length()-1);
+		
+		/*
+		const char *EntryPoint_string  = EntryPoint.c_str();
+	        char * klee_muqi_angr_numargs_string  = &klee_muqi_angr_numargs[0];
+		//char * klee_muqi_angr_numargs_string  = klee_muqi_angr_numargs.data();
+		char *token = strtok(klee_muqi_angr_numargs_string, EntryPoint_string);
+		llvm::errs() << "\nklee_muqi_angr_numargs1: " << klee_muqi_angr_numargs_string << "\n";
+                llvm::errs() << "\nEntryPoint1: " <<EntryPoint_string << "\n";
+		llvm::errs() << "\ntoken: " <<token<<"\n";
+
+	
+		klee_muqi_angr_numargs = strtok(const_cast<char*>(klee_muqi_angr_numargs.c_str()), EntryPoint.c_str());
+		klee_muqi_angr_numargs += "_angr_numargs.txt";
+		*/
+		llvm::errs() << "\nklee_muqi_angr_numargs: " << klee_muqi_angr_numargs << "\n";
+		llvm::errs() << "\nEntryPoint: " << EntryPoint<<"\n";
+		llvm::errs() << "\nfilename: "<<filename<<"\n";
+		std::ifstream file_angrnum("/tmp/call_count_"+filename+"_angr_numargs.txt");
+		std::stringstream string_angrnum;	
+		std::string string_angrnum_line;
+                if (file.is_open()) {
+                      std::string firstline;
+                      std::getline(file, firstline);
+                      run_external = true;
+                      file.close();
+                }
+		
+		std::string called_function_name;
+		if (run_external == true){
+                  Function* called_fn = cast<CallInst>(i)->getCalledFunction();
+                  if(called_fn != NULL) {
+			  called_function_name = called_fn->getName().str();
+		  }else{
+		  	Function* called_fn2;
+                        CallInst * called_i = cast<CallInst>(i);
+                        called_fn2 = dyn_cast<Function>(called_i->getCalledValue()->stripPointerCasts());
+			called_function_name = called_fn2->getName().str();
+		  }
+		}
+
+		std::string last_num;
+		std::vector<std::string> last_num_vec;
+		if (file_angrnum){
+			string_angrnum << file_angrnum.rdbuf();    
+     			file_angrnum.close();
+		
+			while(std::getline(string_angrnum,string_angrnum_line,'\n')){
+     				if (string_angrnum_line.find(EntryPoint) != std::string::npos ){
+					if (string_angrnum_line.find(called_function_name) != std::string::npos ){
+						std::stringstream ss(string_angrnum_line);
+    						while (!ss.eof()) {
+							std::getline(ss, last_num, '|');
+    						}
+						std::stringstream ss2(last_num);
+						std::string tmp;
+						while(!ss2.eof()){
+							std::getline(ss2,tmp,',');
+							last_num_vec.push_back(tmp);
+						}
+						llvm::errs() << "\nlast_num: "<<last_num<<"\n";
+						llvm::errs() << "\nstring_angrnum_line: "<<string_angrnum_line<<"\n";
+					}
+				}
+    			}
+		}
+
+		ref<Expr> result_external = ConstantExpr::create(0,64);
+                if (run_external == true){
+                  Function* fn = cast<CallInst>(i)->getCalledFunction();
+                  if(fn != NULL) {
+		      FunctionType *FTy = fn->getFunctionType();
+                      if (fn->arg_empty() == true)
+                      {}
+                      else{
+                          int count = 0;
+                          for(Function::arg_iterator arg = fn->arg_begin(); arg != fn->arg_end(); ++arg) {
+		   	    if (count < last_num_vec.size() &&last_num_vec[count].find("999") != std::string::npos){
+				llvm::errs() << "\nskip this "<<last_num_vec[count]<<"\n";
+				llvm::errs() << "\nskip this "<<count<<"\n";
+			    	continue;
+			    }
+                            ref<Expr> next_value = eval(ki, count+1, state).value;
+			    if (FTy->getParamType(count)->isPointerTy()){
+				llvm::errs() << "next_value0: "<<next_value<<" \n";
+                                ref<Expr> next_value_pointer = executeMemoryOperation_muqi(state, false, next_value, 0, ki);
+                                next_value = next_value_pointer;
+				llvm::errs() << "next_value_pointer: "<<next_value_pointer<<" \n";
+                            }
+                            ref<Expr> next_value_extend = SExtExpr::create(next_value,64);
+                            llvm::errs() << "next_value: "<<next_value<<" \n";
+                            llvm::errs() << "next_value_extend: "<<next_value_extend<<" \n";
+
+                            result_external = AddExpr::create(next_value_extend, result_external);
+                            count += 1;
+                          }
+                      }
+                    }
+                    else{
+			//https://stackoverflow.com/questions/53086557/casting-tail-call-void-i32-bitcast-to-an-llvmfunction-to-get-the-fnattr
+                      //handle " call void (i64, i64, i64, ...) bitcast (void (...)* @test2 to void (i64, i64, i64, ...)*)(i64 %5, i64 %7, i64 %9)"
+                        //type will be: i64, i64, i64, void (i64, i64, i64, ...)*
+                        int count =0;
+			Function* fn2;
+			CallInst * call_i = cast<CallInst>(i);
+			fn2 = dyn_cast<Function>(call_i->getCalledValue()->stripPointerCasts());
+
+			if (fn2 != NULL){
+				FunctionType *FTy = fn2->getFunctionType();
+				for (;count<ki->inst->getNumOperands()-1;count+= 1) {
+
+					if (count < last_num_vec.size() && last_num_vec[count].find("999") != std::string::npos){
+						llvm::errs() << "\nskip this "<<last_num_vec[count]<<"\n";
+						llvm::errs() << "\nskip this "<<count<<"\n";
+                                		continue;
+                            		}
+					ref<Expr> next_value = eval(ki, count+1, state).value;
+					Type *argtype = call_i-> getArgOperand(count)->getType();
+					if (argtype->isPointerTy()){
+                                  		ref<Expr> next_value_pointer = executeMemoryOperation_muqi(state, false, next_value, 0, ki);
+						next_value = next_value_pointer;
+					}
+					ref<Expr> next_value_extend = SExtExpr::create(next_value,64);
+                                	result_external = AddExpr::create(next_value_extend, result_external);
+
+				}
+			}
+                    }
+                }
+                //we just want the last 8 bytes information,
+                //hence we first truncate then zero extend it to 64 bits
+                //and then truncate it back to size of retval
+                ref<Expr> result_trunc_8bytes = ExtractExpr::create(result_external,
+                                                              0,
+                                                              8);
+                ref<Expr> result_trunc_64bytes =ZExtExpr::create(result_trunc_8bytes,64);
+                ref<Expr> result_trunc;
+		if (!t->isVoidTy()) {
+                  result_trunc = ExtractExpr::create(result_trunc_64bytes,
+                                                              0,
+                                                              getWidthForLLVMType(t));
+                } else{
+                  //void return which is waht we dont care
+                    result_trunc = ExtractExpr::create(result_trunc_64bytes,
+                                                              0,
+                                                              8);
+		}
+		
+                Function *calledFunction = cast<CallInst>(i)->getCalledFunction();
+                Function *calledFunction_bitcaset;
+                bool check_memcpy = false;
+		if (calledFunction == NULL){
+                  Function *calledFunction_bitcaset = dyn_cast<Function>(cast<CallInst>(i)->getCalledValue()->stripPointerCasts());
+                  check_memcpy = strncmp(calledFunction_bitcaset->getName().str().c_str(),"memcpy)",6)== 0;
+		}else{
+		  check_memcpy = strncmp(calledFunction->getName().str().c_str(),"memcpy)",6)== 0;
+		}
+		
+		if ( check_memcpy){
+		  executeInstruction(state, ki);
+		}
+		else if (calledFunction == NULL && !t->isVoidTy()){
+                  //indirect call and non-void return
+                  Expr::Width to = getWidthForLLVMType(t);
+                  ref<Expr> result_temp = ConstantExpr::create(0,to);
+                  if (run_external == true){
+                    bindLocal(ki, state, result_trunc);
+                  }else{
+                    bindLocal(ki, state, result_temp);
+                  }
+
+                }else if (strncmp(calledFunction->getName().str().c_str(),"SEXT",4)== 0 
+                       || strncmp(calledFunction->getName().str().c_str(),"CONCAT",6)== 0
+                       || strncmp(calledFunction->getName().str().c_str(),"ZEXT",4)== 0
+                       || strncmp(calledFunction->getName().str().c_str(),"SUB",3)== 0){
+                  executeInstruction(state, ki);
+                }else if (calledFunction == NULL && t->isVoidTy()){
+                  //indirect call and void return, just skip it
+                }else if (strcmp(calledFunction->getName().str().c_str(),EntryPoint.c_str())!= 0 && !t->isVoidTy()){
+                  //direct call and non-void return and name is not same as current function
+                  Expr::Width to = getWidthForLLVMType(t);
+                  ref<Expr> result_temp = ConstantExpr::create(0,to);
+                  if (run_external == true){
+                    bindLocal(ki, state, result_trunc);
+                  }else{
+                    bindLocal(ki, state, result_temp);
+                  }
+                }else if (strcmp(calledFunction->getName().str().c_str(),EntryPoint.c_str())!= 0 && t->isVoidTy()){
+                  //direct call and void return and name is not same as current function
+                }else if (strcmp(calledFunction->getName().str().c_str(),EntryPoint.c_str())== 0 && !t->isVoidTy()){
+                  //direct call and void return and name is same as current function
+                  Expr::Width to = getWidthForLLVMType(t);
+                  ref<Expr> result_temp = ConstantExpr::create(0,to);
+                  if (run_external == true){
+                    bindLocal(ki, state, result_trunc);
+                  }else{
+                    bindLocal(ki, state, result_temp);
+                  }
+                }else if (strcmp(calledFunction->getName().str().c_str(),EntryPoint.c_str())!= 0 && !t->isVoidTy()){
+                  //direct call and void return and name is same as current function
+                }else{
+
+                }
+          }else{
+              executeInstruction(state, ki);
+          }
+	  /*
+          if (i->getOpcode() == Instruction::Call && strcmp(cast<CallInst>(i)->getCalledFunction()->getName().str().c_str(),EntryPoint.c_str())!= 0 && !t->isVoidTy() ) {     
+              Expr::Width to = getWidthForLLVMType(t);
+              ref<Expr> result_temp = ConstantExpr::create(0,to);
+              bindLocal(ki, state, result_temp);
+          }else {
+	     if (i->getOpcode() == Instruction::Call && strcmp(cast<CallInst>(i)->getCalledFunction()->getName().str().c_str(),EntryPoint.c_str())== 0  && muqi_external_call_function_once == 0 && t->isVoidTy()){
+                muqi_external_call_function_once += 1;
+                //executeInstruction(state, ki);
+              }else if (i->getOpcode() == Instruction::Call && strcmp(cast<CallInst>(i)->getCalledFunction()->getName().str().c_str(),EntryPoint.c_str())== 0  && muqi_external_call_function_once != 0 &&  t->isVoidTy()){
+                muqi_external_call_function_once += 1;
+              }else if (i->getOpcode() == Instruction::Call && strcmp(cast<CallInst>(i)->getCalledFunction()->getName().str().c_str(),EntryPoint.c_str())!= 0 &&  t->isVoidTy()){
+              }else if (i->getOpcode() == Instruction::Call && strcmp(cast<CallInst>(i)->getCalledFunction()->getName().str().c_str(),EntryPoint.c_str())== 0  && muqi_external_call_function_once == 0 && !t->isVoidTy()){
+                muqi_external_call_function_once += 1;
+                Expr::Width to = getWidthForLLVMType(t);
+                ref<Expr> result_temp = ConstantExpr::create(0,to);
+                bindLocal(ki, state, result_temp);
+              }else if (i->getOpcode() == Instruction::Call && strcmp(cast<CallInst>(i)->getCalledFunction()->getName().str().c_str(),EntryPoint.c_str())== 0  && muqi_external_call_function_once != 0 &&  !t->isVoidTy()){
+                muqi_external_call_function_once += 1;
+              }
+              else {
+                executeInstruction(state, ki);
+              }
+              //executeInstruction(state, ki);
+          }*/
+    #endif
+      
       if (RecordValueFlow)
          generateValuedInstruction(state, ki);
       /* SYSREL extension */
@@ -5976,7 +6757,11 @@ void Executor::executeAlloc(ExecutionState &state,
                             KInstruction *target,
                             bool zeroMemory,
                             bool record,
-                            const ObjectState *reallocFrom) {
+                            const ObjectState *reallocFrom
+                            //muqi change here!!!
+                            ,bool is_instruction_alloc_last,
+                            ref<ConstantExpr> for_last,
+                            bool is_instruction_alloc) {
   llvm::outs() << "Alloc'ing...\n";
   size = toUnique(state, size);
   if (ConstantExpr *CE = dyn_cast<ConstantExpr>(size)) {
@@ -5986,7 +6771,7 @@ void Executor::executeAlloc(ExecutionState &state,
     LLVMContext &ctx = moduleHandle->getContext();
     MemoryObject *mo =
         memory->allocate(CE->getZExtValue(), isLocal, /*isGlobal=*/false,
-                         allocSite, allocationAlignment, CE->getZExtValue(), Type::getInt8Ty(ctx));
+                         allocSite, allocationAlignment, CE->getZExtValue(), Type::getInt8Ty(ctx),is_instruction_alloc_last,is_instruction_alloc);
     recordMemObj(state, mo);
     /* SYSREL extension */
 
@@ -6327,6 +7112,7 @@ bool Executor::executeCheckAddressInBound(ExecutionState &state,
             memoryerror = false;  
          } 
          else {
+            //muqi we do not handle this out of bound pointer
             llvm::errs() << "Offending address " << address << "\n";
             std::string s;
             llvm::raw_string_ostream ors(s);
@@ -6337,6 +7123,7 @@ bool Executor::executeCheckAddressInBound(ExecutionState &state,
             //terminateStateOnError(*unbound, "memory error: out of bound pointer", Ptr,
 	    //NULL, getAddressInfo(*unbound, address));
             memoryerror = true; 
+          
         }
      }
      return false;
@@ -6439,6 +7226,8 @@ ref<Expr> Executor::performLazyInit(ExecutionState &state,
       Type *t = li->getPointerOperand()->getType();
       int count = 0;
       lazyInitTemp = isLazyInit(t, singleInstance, count);
+      //added by muqi
+      lazyInitTemp = false;
       if (!lazyInitTemp && ForwardTypeInference) {
          // let's check if the loaded value might be converted to a pointer soon
          Type *ptype = checkPossiblePtrCast(target->inst);
@@ -6574,6 +7363,106 @@ ref<Expr> Executor::performLazyInit(ExecutionState &state,
   return NULL;  
 }
 
+ref<Expr> Executor::executeMemoryOperation_muqi(ExecutionState &state,
+                                      bool isWrite,
+                                      ref<Expr> address,
+                                      ref<Expr> value /* undef if read */,
+                                      KInstruction *target /* undef if write */) {
+
+
+  llvm::errs() << "state=" << &state << " memory operation (inside " << state.prevPC->inst->getParent()->getParent()->getName() << ") \n";
+  state.prevPC->inst->print(llvm::errs());
+  llvm::errs() << "\n address: " << address << "\n";
+
+  llvm::errs() << "executeMemoryOperation isWrite? " << isWrite  << "\n";
+  if (isWrite)
+     llvm::errs() << "storing value " << value << "\n";
+
+  Expr::Width type = (isWrite ? value->getWidth() :
+                     getWidthForLLVMType(target->inst->getType()));
+
+  unsigned bytes = Expr::getMinBytesForWidth(type);
+
+  llvm::errs() << "width for the memop: " << type << "\n";
+  llvm::errs() << "bytes for the memop: " << bytes << "\n";
+
+
+  if (SimplifySymIndices) {
+    if (!isa<ConstantExpr>(address))
+      address = state.constraints.simplifyExpr(address);
+    if (isWrite && !isa<ConstantExpr>(value))
+      value = state.constraints.simplifyExpr(value);
+  }
+
+  // fast path: single in-bounds resolution
+  ObjectPair op;
+  bool success;
+  solver->setTimeout(coreSolverTimeout);
+  if (!state.addressSpace.resolveOne(state, solver, address, op, success)) {
+    address = toConstant(state, address, "resolveOne failure");
+    success = state.addressSpace.resolveOne(cast<ConstantExpr>(address), op);
+  }
+  solver->setTimeout(0);
+
+  llvm::errs() << "first solver query passed\n";
+
+  if (success) {
+    const MemoryObject *mo = op.first;
+
+    if (MaxSymArraySize && mo->size>=MaxSymArraySize) {
+      address = toConstant(state, address, "max-sym-array-size");
+    }
+
+    ref<Expr> offset = mo->getOffsetExpr(address);
+    llvm::errs() << "address for memop " << address << "\n";
+    llvm::errs() << "default offset for target address " << offset << "\n";
+    llvm::errs() << "base memory address " << mo->getBaseExpr() << "\n";
+    llvm::errs() << "address for memop " << address << "\n";
+    llvm::errs() << "default offset for target address " << offset << "\n";
+    llvm::errs() << "base memory address " << mo->getBaseExpr() << "\n";
+    llvm::errs() << "name of op.first " << mo->name << "\n";
+    bool inBounds;
+    solver->setTimeout(coreSolverTimeout);
+    bool success = solver->mustBeTrue(state,
+                                      mo->getBoundsCheckOffset(offset, bytes),
+                                      inBounds);
+    solver->setTimeout(0);
+
+    llvm::errs() << "bounds check expression logg:: " << mo->getBoundsCheckOffset(offset, bytes) << "\n";
+    llvm::errs() << "in bounds? " << inBounds << "\n";
+
+    if (inBounds) {
+      const ObjectState *os = op.second;
+
+      ref<Expr> result = os->read(offset, type);
+      llvm::errs() << " load result1_0_0: " << os->getObject()->name<< "\n";
+      llvm::errs() << " load result1_0_0: " << offset << "\n";
+      llvm::errs() << " load result1_0: " << result << "\n";
+      if (interpreterOpts.MakeConcreteSymbolic)
+        result = replaceReadWithSymbolic(state, result);
+      llvm::errs() << " load result1_1: " << result << "\n";
+      /* SYSREL EXTENSION */
+      if (!dyn_cast<ConstantExpr>(result)) {
+    bool abort = false;
+    ref<Expr> lresult = performLazyInit(state,address,offset,result,target,op,abort);
+          if (abort)
+            return lresult;
+          if (!lresult.isNull())
+            result = lresult;
+      }
+      llvm::errs() << " load result1_2: " << result << "\n";
+      /* SYSREL EXTENSION */
+
+      if (getDestCell(state, target).value.get())
+        llvm::errs() << "address to be dest: " << getDestCell(state, target).value << "\n";
+
+      //bindLocal(target, state, result);
+
+      llvm::errs() << " load result1: " << result << "\n";
+      return result;
+    }
+  }
+}
 
 // return true if abort
 bool Executor::executeMemoryOperation(ExecutionState &state,
@@ -6767,7 +7656,7 @@ bool Executor::executeMemoryOperation(ExecutionState &state,
   const MemoryObject *emo = op.first;
   //llvm::errs() << "unresolved address=" << address << "\n";
 
-  int unboundResolLimit = 3;
+  int unboundResolLimit = 0;
   int resC = 0;
   llvm::errs() << "resolution size=" << rl.size() << "\n";
   for (ResolutionList::iterator i = rl.begin(), ie = rl.end(); resC < unboundResolLimit && i != ie; ++i, resC++) {
@@ -6838,8 +7727,60 @@ bool Executor::executeMemoryOperation(ExecutionState &state,
       state.dumpStack(ors);
       llvm::outs() << ors.str() ;
       ExprPPrinter::printConstraints(llvm::outs(), state.constraints);
+
+
+      //when we find a out of bound pointer, we 
+      // create a local variable and 
+      // allocate a constant 100 byte size to it  
+      // set zeroMemory as false
+      #if defined(Muqi_external_call)
+          //bool zeroMemory = false;
+          bool zeroMemory = true;
+          ref<Expr> size ;
+          ref<Expr> value ;
+          if (target){
+            Instruction *target_i = target->inst; 
+            Type *t_external = target_i->getType();  
+            Expr::Width to = getWidthForLLVMType(t_external);
+            size = ConstantExpr::create(to,64);
+            value = ConstantExpr::create(0,to);
+          }else{
+            size = ConstantExpr::create(32,64);
+            value = ConstantExpr::create(0,32);
+          }
+          
+          
+          ConstantExpr *CE = dyn_cast<ConstantExpr>(size);
+          const llvm::Value *allocSite = state.prevPC->inst;
+          size_t allocationAlignment = 8;
+          
+          if (allocationAlignment == 0) {
+            allocationAlignment = getAllocationAlignment(allocSite);
+          }
+          
+          MemoryObject *mo =
+              memory->allocate(CE->getZExtValue(), /*isLocal=*/true, /*isGlobal=*/false,
+                              allocSite, allocationAlignment,false,false);
+
+          if (!mo) {
+              //bindLocal(target, state,size);
+            } else {
+              ObjectState *os = bindObjectInState(state, mo, /*isLocal=*/true);
+              if (zeroMemory) {
+                os->initializeToZero();
+              } else {
+                os->initializeToRandom();
+              }
+	      if (target){
+              bindLocal(target, state, value);
+	      }
+            }
+      #endif
+              
+      #if !defined(Muqi_external_call)
       terminateStateOnError(*unbound, "memory error: out of bound pointer", Ptr,
                             NULL, getAddressInfo(*unbound, address));
+                            #endif
     }
   }
   return false;
@@ -7040,11 +7981,14 @@ void Executor::initArgsAsSymbolic(ExecutionState &state, Function *entryFunc, bo
    LLVMContext &ctx = moduleHandle->getContext();
    std::map<unsigned, std::pair<MemoryObject*,ObjectState*> > argObjs;
    std::map<unsigned, unsigned> argSizes;
+
+
    for(llvm::Function::arg_iterator ai = entryFunc->arg_begin(); ai != entryFunc->arg_end(); ai++) {
      Type *at = ai->getType();
      std::string type_str;
      llvm::raw_string_ostream rso(type_str);
      at->print(rso);
+     std::string name_of_args = std::string("prompt_args_") + std::to_string(ind) +std::string("_args_end");
      if (at->isPointerTy()) {
         llvm::outs() << "arg " << ind << " type " << rso.str() << "\n";
         at = at->getPointerElementType();
@@ -7080,14 +8024,20 @@ void Executor::initArgsAsSymbolic(ExecutionState &state, Function *entryFunc, bo
               //mo = memory->allocateForLazyInit(state, state.prevPC->inst, at, singleInstance, count, laddr);
               llvm::outs() << "is arg " << ind <<  " type " << rso.str() << " single instance? " << singleInstance << "\n";
               llvm::outs() << "to be made symbolic? " << mksym << "\n";
-              mo->name = state.getUnique(entryFunc->getName().str() + std::string("_arg_") + std::to_string(ind));
+              //mo->name = state.getUnique(entryFunc->getName().str() + std::string("_arg_") + std::to_string(ind));
+              mo -> name = name_of_args;
               if (!nosym && mksym) {
-                 ObjectState *mos = executeMakeSymbolic(state, mo, 
+               /* 
+                ObjectState *mos = executeMakeSymbolic(state, mo, 
                                      entryFunc->getName().str() + 
                                            std::string("_arg_") + 
                                                 std::to_string(ind),
                                      true, at, true, count);
- 
+                */
+                ObjectState *mos = executeMakeSymbolic(state, mo, 
+                                     name_of_args,
+                                     true, at, true, count);
+               
                  // first simple equalities get applied..
                  applyDataConstraintToArray(state, solver, mo, mos,0, count, true); 
                  // then other constraints
@@ -7103,7 +8053,13 @@ void Executor::initArgsAsSymbolic(ExecutionState &state, Function *entryFunc, bo
 
               }
               llvm::errs() << "Address of lazy allocated arg " << laddr << "\n";
+              //bindArgument(kf, ind, state, laddr);
+
+	      //muqi, for concrete input,
+             
               bindArgument(kf, ind, state, laddr);
+             
+
               llvm::outs() << "binding arg " << ind << " of type " << rso.str() << " to address " << laddr << 
                                                                 " (in " << mo->getBaseExpr() << ")\n";
               argSizes[ind] = count; 
@@ -7122,10 +8078,17 @@ void Executor::initArgsAsSymbolic(ExecutionState &state, Function *entryFunc, bo
         }
         else 
            allocsize = dl.getTypeAllocSize(at); 
+        //muqi we change here, no matter what happens, size being allocated is 64 bits/ 8 bytes.
+	//muqi 256&8 we want the size of array be 256 bytes, input type be 8 bytes
+       	  allocsize = 8;
+	
+        //llvm::outs() << "allocsize is:" << allocsize << " \n"; 
+        
         MemoryObject *mo =  memory->allocate(allocsize, false, /*true*/false, inst, 
                                    allocationAlignment, 1, at);
         recordMemObj(state, mo);
-        mo->name = state.getUnique(entryFunc->getName().str()) + std::string("_arg_") + std::to_string(ind);
+        //mo->name = state.getUnique(entryFunc->getName().str()) + std::string("_arg_") + std::to_string(ind);
+        mo->name = name_of_args;
         std::string uniqueName = mo->name;
         // we're mimicking what executeMemoryOperation do without a relevant load or store instruction
         const Array *array = arrayCache.CreateArray(uniqueName, mo->size);
@@ -7133,8 +8096,13 @@ void Executor::initArgsAsSymbolic(ExecutionState &state, Function *entryFunc, bo
         ref<Expr> result = sos->read(ConstantExpr::alloc(0, Expr::Int64), getWidthForLLVMType(at));         
         llvm::errs() << "Content of lazy allocated arg " << result << "\n";
         ref<Expr> dummy = result;
+        //bindArgument(kf, ind, state, result);
+        
+	
         bindArgument(kf, ind, state, result);
-        constrainPath(state, entryFunc->getName().str(), ind, mo, sos, result);
+       
+
+	constrainPath(state, entryFunc->getName().str(), ind, mo, sos, result);
         // the old interface for API model specs
         applyCommandlineSpecInitializationsToArray(state, solver, mo, sos, at, 1);
         llvm::outs() << "binding nonpointer arg " << ind << " of type " << rso.str() << " to value " << result << "\n"; 
diff --git a/lib/Core/Executor.h b/lib/Core/Executor.h
index ab91659..946f00d 100755
--- a/lib/Core/Executor.h
+++ b/lib/Core/Executor.h
@@ -423,14 +423,19 @@ private:
 
   void generateValuedInstruction(ExecutionState &state, KInstruction *ki);
 
-
+//muqi change zeroMemory = false, to zeroMemory = true
   void executeAlloc(ExecutionState &state,
                     ref<Expr> size,
                     bool isLocal,
                     KInstruction *target,
-                    bool zeroMemory=false,
+                    bool zeroMemory=true,
                     bool record = false,
-                    const ObjectState *reallocFrom=0);
+                    const ObjectState *reallocFrom=0
+                    //muqi change here!!!
+                    ,bool is_instruction_alloc_last=false,
+                    ref<ConstantExpr> for_last=ConstantExpr::create(0,64),
+                    bool is_instruction_alloc=false
+                    );
   /* SYSREL extension */
   void executeAllocThread(ExecutionState &state,
                             ref<Expr> size,
@@ -484,6 +489,11 @@ private:
                               ref<Expr> address,
                               ref<Expr> value /* undef if read */,
                               KInstruction *target /* undef if write */);
+  ref<Expr> executeMemoryOperation_muqi(ExecutionState &state,
+                              bool isWrite,
+                              ref<Expr> address,
+                              ref<Expr> value /* undef if read */,
+                              KInstruction *target /* undef if write */);
   /* SYSREL extension */
   bool loadPointerArguments(ExecutionState &state,   
                                   KInstruction *target,
diff --git a/lib/Core/MemoryManager.cpp b/lib/Core/MemoryManager.cpp
index 6de948b..fd2ec1c 100755
--- a/lib/Core/MemoryManager.cpp
+++ b/lib/Core/MemoryManager.cpp
@@ -74,11 +74,13 @@ void recordMemObj(ExecutionState &state, const MemoryObject *mo) {
     }
 }
 
+//muqi
 namespace {
 llvm::cl::opt<bool> DeterministicAllocation(
     "allocate-determ",
     llvm::cl::desc("Allocate memory deterministically(default=off)"),
-    llvm::cl::init(false));
+    llvm::cl::init(true));
+//    llvm::cl::init(false));
 
 llvm::cl::opt<unsigned> DeterministicAllocationSize(
     "allocate-determ-size",
@@ -96,13 +98,18 @@ llvm::cl::opt<unsigned> RedZoneSpace(
     "red-zone-space",
     llvm::cl::desc("Set the amount of free space between allocations. This is "
                    "important to detect out-of-bound accesses (default=10)."),
-    llvm::cl::init(10));
+  //  llvm::cl::init(10));
+     llvm::cl::init(0));
 
 llvm::cl::opt<unsigned long long> DeterministicStartAddress(
     "allocate-determ-start-address",
-    llvm::cl::desc("Start address for deterministic allocation. Has to be page "
+   /* llvm::cl::desc("Start address for deterministic allocation. Has to be page "
                    "aligned (default=0x7ff30000000)."),
     llvm::cl::init(0x7ff30000000));
+   */
+    llvm::cl::desc("Start address for deterministic allocation. Has to be page "
+                   "aligned (default=0x0)."),
+    llvm::cl::init(0x0));
 }
 
 /***/
@@ -302,7 +309,9 @@ const MemoryObject *MemoryManager::allocateLazyForTypeOrEmbeddingSimple(Executio
         llvm::errs() << "allocation size for void type: " << allocsize << " times " << count << "\n"; 
      }
      llvm::outs() << "allocation size: " << allocsize*count << "\n"; 
-     mo = allocate(allocsize*count, false, /*true*/false, inst, allocationAlignment, count, allocType);
+     ///muqi 256&8 we want the size of array be 256 bytes, input type be 8 bytes
+     mo = allocate(256, false, /*true*/false, inst, allocationAlignment, count, allocType);
+     //mo = allocate(allocsize*count, false, /*true*/false, inst, allocationAlignment, count, allocType);
      recordMemObj(state, mo);
      resaddr = mo->getBaseExpr();
      rallocType = allocType;
@@ -495,10 +504,14 @@ MemoryObject *MemoryManager::allocateForLazyInit(ExecutionState &state, llvm::In
 }
 /* SYSREL extension */
 
+//muqi
 MemoryObject *MemoryManager::allocate(uint64_t size, bool isLocal,
                                       bool isGlobal,
                                       const llvm::Value *allocSite,
-                                      size_t alignment) {
+                                      size_t alignment,
+                                      bool is_instruction_alloc_last,
+                                      bool is_instruction_alloc
+                                      ) {
   if (size > 10 * 1024 * 1024)
     klee_warning_once(0, "Large alloc: %" PRIu64
                          " bytes.  KLEE may run out of memory.",
@@ -513,7 +526,12 @@ MemoryObject *MemoryManager::allocate(uint64_t size, bool isLocal,
     return 0;
   }
 
+   klee_muqi("In MemoryManager::allocate, after two return 0");
   uint64_t address = 0;
+   
+   //muqi change here!!!
+  alignment = 1;
+
   if (DeterministicAllocation) {
 #if LLVM_VERSION_CODE >= LLVM_VERSION(3, 9)
     address = llvm::alignTo((uint64_t)nextFreeSlot + alignment - 1, alignment);
@@ -526,7 +544,8 @@ MemoryObject *MemoryManager::allocate(uint64_t size, bool isLocal,
     // This way, we make sure we have this allocation between its own red zones
     size_t alloc_size = std::max(size, (uint64_t)1);
     if ((char *)address + alloc_size < deterministicSpace + spaceSize) {
-      nextFreeSlot = (char *)address + alloc_size + RedZoneSpace;
+      //nextFreeSlot = (char *)address + alloc_size + RedZoneSpace;
+      nextFreeSlot = (char *)address + alloc_size;
     } else {
       klee_warning_once(0, "Couldn't allocate %" PRIu64
                            " bytes. Not enough deterministic space left.",
@@ -557,7 +576,15 @@ MemoryObject *MemoryManager::allocate(uint64_t size, bool isLocal,
   llvm::outs() << "Allocated object of size " << size << " at address " << address << "\n";
   llvm::outs() << "Basexpr=" << res->getBaseExpr() << "\n";
 
-  objects.insert(res);
+//muqi change here!!!
+  if(is_instruction_alloc){
+    if(is_instruction_alloc_last){
+      objects.insert(res);
+    }
+  }else{
+    objects.insert(res);
+  }
+  
   /* SYSREL EXTENSION */
   if (staticAllocStatTracking)
      staticAlloc++; 
@@ -567,11 +594,15 @@ MemoryObject *MemoryManager::allocate(uint64_t size, bool isLocal,
 
 }
 
+//muqi
 MemoryObject *MemoryManager::allocate(uint64_t size, bool isLocal,
                                       bool isGlobal,
                                       const llvm::Value *allocSite,
                                       size_t alignment, unsigned count, 
-                                      llvm::Type *t) {
+                                      llvm::Type *t,
+                                      bool is_instruction_alloc_last,
+                                      bool is_instruction_alloc
+                                      ) {
   if (size > 10 * 1024 * 1024)
     klee_warning_once(0, "Large alloc: %" PRIu64
                          " bytes.  KLEE may run out of memory.",
@@ -586,7 +617,11 @@ MemoryObject *MemoryManager::allocate(uint64_t size, bool isLocal,
     return 0;
   }
 
+   
+    klee_muqi("In MemoryManager::allocate, after two return 0");
   uint64_t address = 0;
+
+
   if (DeterministicAllocation) {
 #if LLVM_VERSION_CODE >= LLVM_VERSION(3, 9)
     address = llvm::alignTo((uint64_t)nextFreeSlot + alignment - 1, alignment);
@@ -599,7 +634,8 @@ MemoryObject *MemoryManager::allocate(uint64_t size, bool isLocal,
     // This way, we make sure we have this allocation between its own red zones
     size_t alloc_size = std::max(size, (uint64_t)1);
     if ((char *)address + alloc_size < deterministicSpace + spaceSize) {
-      nextFreeSlot = (char *)address + alloc_size + RedZoneSpace;
+      //nextFreeSlot = (char *)address + alloc_size + RedZoneSpace;
+      nextFreeSlot = (char *)address + alloc_size;
     } else {
       klee_warning_once(0, "Couldn't allocate %" PRIu64
                            " bytes. Not enough deterministic space left.",
@@ -630,7 +666,14 @@ MemoryObject *MemoryManager::allocate(uint64_t size, bool isLocal,
   llvm::errs() << "Basexpr=" << res->getBaseExpr() << "\n";
   llvm::errs() << "Basetype=" << getTypeName(t) << "\n";
 
-  objects.insert(res);
+    //muqi change here!!!
+  if(is_instruction_alloc){
+    if(is_instruction_alloc_last){
+      objects.insert(res);
+    }
+  }else{
+    objects.insert(res);
+  }
   /* SYSREL EXTENSION */
   if (staticAllocStatTracking)
      staticAlloc++; 
diff --git a/lib/Core/MemoryManager.h b/lib/Core/MemoryManager.h
index bceaa10..d86f7f7 100755
--- a/lib/Core/MemoryManager.h
+++ b/lib/Core/MemoryManager.h
@@ -46,11 +46,22 @@ public:
    * memory.
    */
   // keeping for old code
+
+  //muqi
   MemoryObject *allocate(uint64_t size, bool isLocal, bool isGlobal,
-                         const llvm::Value *allocSite, size_t alignment); 
+                         const llvm::Value *allocSite, size_t alignment,
+                         bool is_instruction_alloc_last = false,
+                            bool is_instruction_alloc = false);
   MemoryObject *allocate(uint64_t size, bool isLocal, bool isGlobal,
                          const llvm::Value *allocSite, size_t alignment, 
-                         unsigned count, llvm::Type *type);
+                         unsigned count, llvm::Type *type,
+                         bool is_instruction_alloc_last = false,
+                            bool is_instruction_alloc = false);  
+ // MemoryObject *allocate(uint64_t size, bool isLocal, bool isGlobal,
+  //                       const llvm::Value *allocSite, size_t alignment); 
+  //MemoryObject *allocate(uint64_t size, bool isLocal, bool isGlobal,
+    //                     const llvm::Value *allocSite, size_t alignment, 
+      //                   unsigned count, llvm::Type *type);                      
   MemoryObject *allocateFixed(uint64_t address, uint64_t size,
                               const llvm::Value *allocSite);
 
diff --git a/lib/Core/SpecialFunctionHandler.cpp b/lib/Core/SpecialFunctionHandler.cpp
index c6a1fe2..867fe8d 100755
--- a/lib/Core/SpecialFunctionHandler.cpp
+++ b/lib/Core/SpecialFunctionHandler.cpp
@@ -285,6 +285,9 @@ bool SpecialFunctionHandler::handle(ExecutionState &state,
                                     KInstruction *target,
                                     std::vector< ref<Expr> > &arguments) {
   handlers_ty::iterator it = handlers.find(f);
+
+  //muqi
+  klee_muqi("Inside SpecialFunctionHandler::handle, function name is %s", f->getName());
   if (it != handlers.end()) {    
     Handler h = it->second.first;
     bool hasReturnValue = it->second.second;
@@ -506,6 +509,12 @@ void SpecialFunctionHandler::handleMalloc(ExecutionState &state,
 void SpecialFunctionHandler::handleAssume(ExecutionState &state,
                             KInstruction *target,
                             std::vector<ref<Expr> > &arguments) {
+
+  //muqi
+  KInstruction *currentInstruction = state.prevPC;
+  Instruction *i = target->inst;
+  klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside SpecialFunctionHandler::handleAssume");
+
   assert(arguments.size()==1 && "invalid number of arguments to klee_assume");
   
   ref<Expr> e = arguments[0];
@@ -805,7 +814,11 @@ void SpecialFunctionHandler::handleGetValue(ExecutionState &state,
                                             std::vector<ref<Expr> > &arguments) {
   assert(arguments.size()==1 &&
          "invalid number of arguments to klee_get_value");
-
+  
+  //muqi
+  Instruction *i = target->inst;
+  klee_muqi_compare_test(i->getFunction()->getName().data(),"\nInside SpecialFunctionHandler::handleGetValue");
+ 
   executor.executeGetValue(state, arguments[0], target);
 }
 
diff --git a/lib/Core/UserSearcher.cpp b/lib/Core/UserSearcher.cpp
index 2759132..2459f5d 100755
--- a/lib/Core/UserSearcher.cpp
+++ b/lib/Core/UserSearcher.cpp
@@ -36,7 +36,8 @@ namespace {
 			clEnumValN(Searcher::NURS_CPICnt, "nurs:cpicnt", "use NURS with CallPath-Instr-Count"),
 			clEnumValN(Searcher::NURS_QC, "nurs:qc", "use NURS with Query-Cost"),
                         clEnumValN(Searcher::NURS_CustomWeight, "nurs:cusw", "use NURS with custom weight")
-			KLEE_LLVM_CL_VAL_END));
+			KLEE_LLVM_CL_VAL_END)
+      );
 
   cl::opt<bool>
   UseIterativeDeepeningTimeSearch("use-iterative-deepening-time-search", 
diff --git a/lib/Expr/Constraints.cpp b/lib/Expr/Constraints.cpp
index 1b3ad98..e1c470a 100755
--- a/lib/Expr/Constraints.cpp
+++ b/lib/Expr/Constraints.cpp
@@ -20,6 +20,17 @@
 
 using namespace klee;
 
+
+//muqi
+#ifdef ENABLE_Z3
+#include "./Z3Builder.h"
+#endif
+using namespace llvm;
+using namespace llvm::sys;
+
+#define Muqi_support_foreverloop
+#define Muqi_DEBUG;
+
 namespace {
   llvm::cl::opt<bool>
   RewriteEqualities("rewrite-equalities",
@@ -72,6 +83,10 @@ public:
   }
 };
 
+
+//muqi
+//#define Muqi_DEBUG;
+
 bool ConstraintManager::rewriteConstraints(ExprVisitor &visitor) {
   ConstraintManager::constraints_ty old;
   bool changed = false;
@@ -83,6 +98,35 @@ bool ConstraintManager::rewriteConstraints(ExprVisitor &visitor) {
     ref<Expr> e = visitor.visit(ce);
 
     if (e!=ce) {
+      //muqi
+      //dump constraints here now
+      #ifndef Muqi_support_foreverloop
+      #if defined(Muqi_DEBUG)
+      /*
+      std::string Path = klee_muqi_compare_file_path;
+      std::error_code EC;
+      //llvm::sys::fs::OpenFlags F_Append;
+      fs::OpenFlags Flags = (fs::OpenFlags)2;
+
+      llvm::raw_fd_ostream *example_ostream = new llvm::raw_fd_ostream(Path, EC, Flags);
+      */
+      
+
+      e->dump();
+      #ifdef ENABLE_Z3
+      Z3Builder temp_build = Z3Builder(false,NULL);
+      Z3ASTHandle result_z3 = temp_build.construct(e);
+      result_z3.dump();
+      #endif
+      /*
+      mtx.lock(); 
+      (*example_ostream) << "\n----dump end----\n" ; 
+      mtx.unlock(); 
+    
+      delete example_ostream;
+      */
+      #endif
+      #endif 
       addConstraintInternal(e); // enable further reductions
       changed = true;
     } else {
@@ -164,5 +208,35 @@ void ConstraintManager::addConstraintInternal(ref<Expr> e) {
 
 void ConstraintManager::addConstraint(ref<Expr> e) {
   e = simplifyExpr(e);
+
+    //dump constraints here now
+  #ifndef Muqi_support_foreverloop
+  #if defined(Muqi_DEBUG)
+  /*
+  std::string Path = klee_muqi_compare_file_path;
+  std::error_code EC;
+  //llvm::sys::fs::OpenFlags F_Append;
+  fs::OpenFlags Flags = (fs::OpenFlags)2;
+
+  llvm::raw_fd_ostream *example_ostream = new llvm::raw_fd_ostream(Path, EC, Flags);
+  */
+  
+
+  e->dump();
+  #ifdef ENABLE_Z3
+  Z3Builder temp_build = Z3Builder(false,NULL);
+  Z3ASTHandle result_z3 = temp_build.construct(e);
+  result_z3.dump();
+  #endif
+  /*
+  mtx.lock(); 
+  (*example_ostream) << "\n----dump end----\n" ; 
+  mtx.unlock(); 
+ 
+  delete example_ostream;
+   */
+  #endif
+  #endif
+
   addConstraintInternal(e);
 }
diff --git a/lib/Expr/Expr.cpp b/lib/Expr/Expr.cpp
index f73d161..bca7961 100755
--- a/lib/Expr/Expr.cpp
+++ b/lib/Expr/Expr.cpp
@@ -24,6 +24,12 @@
 using namespace klee;
 using namespace llvm;
 
+//muqi
+#include "klee/Internal/Support/ErrorHandling.h"
+#include "llvm/ADT/SmallString.h"
+#include <time.h>
+using namespace llvm::sys;
+
 namespace {
   cl::opt<bool>
   ConstArrayOpt("const-array-opt",
@@ -32,6 +38,13 @@ namespace {
 }
 
 /***/
+namespace klee {
+    std::string klee_muqi_compare_file_path;
+    std::mutex mtx;
+    std::string klee_muqi_external_function_file_path;
+    std::string  klee_muqi_external_bool_file_path;
+    std::string klee_muqi_angr_numargs;
+}
 
 unsigned Expr::count = 0;
 
@@ -311,9 +324,47 @@ void Expr::print(llvm::raw_ostream &os) const {
   ExprPPrinter::printSingleExpr(os, const_cast<Expr*>(this));
 }
 
+//muqi
+#define Muqi_DEBUG;
+
 void Expr::dump() const {
-  this->print(errs());
-  errs() << "\n";
+ #if defined(Muqi_DEBUG)
+   
+  //this->print(errs());
+  //errs()<<"\n";
+  
+  //https://stackoverflow.com/questions/65000322/creating-raw-ostream-object-in-llvm
+  //https://stackoverflow.com/questions/26317177/how-to-redirect-llvmouts-to-file
+  //add sleep to avoid IO failure on output
+  struct timespec ts;
+  long msec = 1;
+  ts.tv_sec = msec / 1000;
+  ts.tv_nsec = (msec % 1000) * 1000000;
+  nanosleep(&ts, &ts);
+  //test ++;
+  //klee_muqi_compare(std::to_string(test).c_str());
+  std::string Path = klee_muqi_compare_file_path;
+  std::error_code EC;
+  //llvm::sys::fs::OpenFlags F_Append;
+   fs::OpenFlags Flags = (fs::OpenFlags)2;
+
+  //llvm::raw_ostream *out = &outs();
+  llvm::raw_fd_ostream *example_ostream = new llvm::raw_fd_ostream(Path, EC, Flags);
+  //out = example_ostream;
+  if(EC)
+    errs() << "Error opening " << Path << "\n";
+  (*example_ostream)  << "\n----dump expr start----\n" ;
+  //mtx.lock(); 
+  this->print(*example_ostream);
+  //this->print(outs());
+  //mtx.unlock();
+  //example_ostream << std::to_string(test).c_str() <<"\n" ; 
+  (*example_ostream) << "\n----dump expr end----\n" ; 
+  
+  nanosleep(&ts, &ts);
+  delete example_ostream;
+  
+  #endif
 }
 
 /***/
diff --git a/lib/Prose/Prose.cpp b/lib/Prose/Prose.cpp
index caf2b85..c99ac24 100644
--- a/lib/Prose/Prose.cpp
+++ b/lib/Prose/Prose.cpp
@@ -492,13 +492,13 @@ bool applyEquality(BoundAST &bast, const MemoryObject *mo, ObjectState *obj,
    ASTNode *n2 = bast.ast->getChild(1);
    ref<Expr> value = NULL;
    unsigned width = getWidth(bast,bast.ast,st);
-   if (dynamic_cast<ConstantNode*>(n1)) {
+   if (static_cast<ConstantNode*>(n1)) {
       value = ConstantExpr::alloc(((ConstantNode*)n1)->value, width);
    }
-   if (dynamic_cast<ConstantNode*>(n2)) {
+   if (static_cast<ConstantNode*>(n2)) {
       value = ConstantExpr::alloc(((ConstantNode*)n2)->value, width);
    }
-   if (dynamic_cast<IdentifierNode*>(n1)) {
+   if (static_cast<IdentifierNode*>(n1)) {
       IdentifierNode *in1 = (IdentifierNode*)n1;
       Binding b1 = bast.bindings[in1->value];
       unsigned o = sl->getElementOffset(b1.index);
@@ -520,7 +520,7 @@ bool applyEquality(BoundAST &bast, const MemoryObject *mo, ObjectState *obj,
         }
       }
    }
-   if (dynamic_cast<IdentifierNode*>(n2)) {
+   if (static_cast<IdentifierNode*>(n2)) {
       IdentifierNode *in2 = (IdentifierNode*)n2;
       Binding b2 = bast.bindings[in2->value];
       unsigned o = sl->getElementOffset(b2.index);
@@ -546,7 +546,7 @@ bool applyEquality(BoundAST &bast, const MemoryObject *mo, ObjectState *obj,
 
    
    bool wrote = false;
-   if (dynamic_cast<IdentifierNode*>(n1)) {
+   if (static_cast<IdentifierNode*>(n1)) {
       IdentifierNode *in1 = (IdentifierNode*)n1;
       Binding b1 = bast.bindings[in1->value];
       unsigned o = sl->getElementOffset(b1.index);
@@ -557,7 +557,7 @@ bool applyEquality(BoundAST &bast, const MemoryObject *mo, ObjectState *obj,
                       << baseOffset + o << " in " << mo->getBaseExpr() << "\n";
       }
    }
-   if (dynamic_cast<IdentifierNode*>(n2)) {
+   if (static_cast<IdentifierNode*>(n2)) {
       IdentifierNode *in2 = (IdentifierNode*)n2;
       Binding b2 = bast.bindings[in2->value];
       unsigned o = sl->getElementOffset(b2.index);
@@ -680,11 +680,11 @@ ref<Expr> generateExp(BoundAST &bast, ASTNode *n, const MemoryObject *mo, const
       return res;
    }
    else if (n->oper == NOOP) {
-      if (dynamic_cast<ConstantNode*>(n)) {
+      if (static_cast<ConstantNode*>(n)) {
          res = ConstantExpr::alloc(((ConstantNode*)n)->value, width);
          return res;          
       }
-      else if (dynamic_cast<IdentifierNode*>(n)) {
+      else if (static_cast<IdentifierNode*>(n)) {
          IdentifierNode *in = (IdentifierNode*)n;
          Binding b = bast.bindings[in->value];
          unsigned o = sl->getElementOffset(b.index);
@@ -713,7 +713,7 @@ ref<Expr> generateExp(BoundAST &bast, ASTNode *n, const MemoryObject *mo, const
 }
 
 unsigned getWidth(BoundAST &bast,ASTNode *n,const StructType *st) {
-  if (dynamic_cast<IdentifierNode*>(n)) {
+  if (static_cast<IdentifierNode*>(n)) {
      IdentifierNode *in = (IdentifierNode*)n;
      Binding b = bast.bindings[in->value];
      Type *et = st->getStructElementType(b.index);
@@ -745,7 +745,7 @@ ref<Expr> generateExp(BoundAST &bast, const MemoryObject *mo, const ObjectState
 
 unsigned getWidth(BoundAST &bast,ASTNode *n, Function *f, ref<Expr> retVal) {
   if (!retVal.isNull()) return retVal->getWidth();
-  if (dynamic_cast<IdentifierNode*>(n)) {
+  if (static_cast<IdentifierNode*>(n)) {
      IdentifierNode *in = (IdentifierNode*)n;
      Binding b = bast.bindings[in->value];
      Type *t = NULL;
@@ -779,13 +779,13 @@ bool applyEquality(BoundAST &bast, Function *f, std::map<unsigned,
    value = NULL;
 
    unsigned width = getWidth(bast,bast.ast,f,NULL);   
-   if (dynamic_cast<ConstantNode*>(n1)) {
+   if (static_cast<ConstantNode*>(n1)) {
       value = ConstantExpr::alloc(((ConstantNode*)n1)->value, width);
    }
-   if (dynamic_cast<ConstantNode*>(n2)) {
+   if (static_cast<ConstantNode*>(n2)) {
       value = ConstantExpr::alloc(((ConstantNode*)n2)->value, width);
    }
-   if (dynamic_cast<IdentifierNode*>(n1)) {
+   if (static_cast<IdentifierNode*>(n1)) {
       IdentifierNode *in = (IdentifierNode*)n1;
       Binding b = bast.bindings[in->value];
       if (b.comptype == "argsize") {
@@ -794,7 +794,7 @@ bool applyEquality(BoundAST &bast, Function *f, std::map<unsigned,
          }        
       }
    }
-   if (dynamic_cast<IdentifierNode*>(n2)) {
+   if (static_cast<IdentifierNode*>(n2)) {
       IdentifierNode *in = (IdentifierNode*)n2;
       Binding b = bast.bindings[in->value];
       if (b.comptype == "argsize") {
@@ -808,7 +808,7 @@ bool applyEquality(BoundAST &bast, Function *f, std::map<unsigned,
 
 
    bool wrote = false;
-   if (dynamic_cast<IdentifierNode*>(n1)) {
+   if (static_cast<IdentifierNode*>(n1)) {
       IdentifierNode *in = (IdentifierNode*)n1;
       Binding b = bast.bindings[in->value];
       if (b.comptype == "return") { // todo
@@ -825,7 +825,7 @@ bool applyEquality(BoundAST &bast, Function *f, std::map<unsigned,
          }
      }
    }
-   if (dynamic_cast<IdentifierNode*>(n2)) {
+   if (static_cast<IdentifierNode*>(n2)) {
       IdentifierNode *in = (IdentifierNode*)n2;
       Binding b = bast.bindings[in->value];
       if (b.comptype == "return") { // todo
@@ -960,11 +960,11 @@ ref<Expr> generateExp(BoundAST &bast, ASTNode *n, Function *f, std::map<unsigned
       return res; 
    } 
    if (n->oper == NOOP) {
-      if (dynamic_cast<ConstantNode*>(n)) {
+      if (static_cast<ConstantNode*>(n)) {
          res = ConstantExpr::alloc(((ConstantNode*)n)->value, width);
          return res;          
       }
-      else if (dynamic_cast<IdentifierNode*>(n)) {
+      else if (static_cast<IdentifierNode*>(n)) {
          IdentifierNode *in = (IdentifierNode*)n;
          Binding b = bast.bindings[in->value];
          if (b.comptype == "return") {
@@ -1008,24 +1008,24 @@ bool isSimpleEquality(BoundAST &bast) {
    if (bast.ast->oper == EQ) {
       ASTNode *n1 = bast.ast->getChild(0);
       ASTNode *n2 = bast.ast->getChild(1);
-      if (dynamic_cast<ConstantNode*>(n1)) {
-        if (dynamic_cast<IdentifierNode*>(n2)) {
+      if (static_cast<ConstantNode*>(n1)) {
+        if (static_cast<IdentifierNode*>(n2)) {
            IdentifierNode *in = (IdentifierNode*)n2;
            Binding b = bast.bindings[in->value];
            if (b.comptype == "none")
               return true;
         }
       }
-      else if (dynamic_cast<ConstantNode*>(n2)) { 
-         if (dynamic_cast<IdentifierNode*>(n1)) {
+      else if (static_cast<ConstantNode*>(n2)) { 
+         if (static_cast<IdentifierNode*>(n1)) {
             IdentifierNode *in = (IdentifierNode*)n1;
             Binding b = bast.bindings[in->value];
             if (b.comptype == "none")
                return true;
          }
       }
-      else if (dynamic_cast<IdentifierNode*>(n1) && 
-                dynamic_cast<IdentifierNode*>(n2)) {
+      else if (static_cast<IdentifierNode*>(n1) && 
+                static_cast<IdentifierNode*>(n2)) {
          IdentifierNode *in1 = (IdentifierNode*)n1;
          IdentifierNode *in2 = (IdentifierNode*)n2;
          Binding b1 = bast.bindings[in1->value]; 
@@ -1047,8 +1047,8 @@ bool isSizeOfConstant(BoundAST &bast, Binding &bout, unsigned &size) {
    if (bast.ast->oper == EQ) {
       ASTNode *n1 = bast.ast->getChild(0);
       ASTNode *n2 = bast.ast->getChild(1);
-      if (dynamic_cast<ConstantNode*>(n1)) {
-        if (dynamic_cast<IdentifierNode*>(n2)) {
+      if (static_cast<ConstantNode*>(n1)) {
+        if (static_cast<IdentifierNode*>(n2)) {
            IdentifierNode *in = (IdentifierNode*)n2;
            Binding b = bast.bindings[in->value];
            if (b.comptype == "sizeof")  {
@@ -1058,8 +1058,8 @@ bool isSizeOfConstant(BoundAST &bast, Binding &bout, unsigned &size) {
            }
         }
       }
-      else if (dynamic_cast<ConstantNode*>(n2)) {
-        if (dynamic_cast<IdentifierNode*>(n1)) {
+      else if (static_cast<ConstantNode*>(n2)) {
+        if (static_cast<IdentifierNode*>(n1)) {
            IdentifierNode *in = (IdentifierNode*)n1;
            Binding b = bast.bindings[in->value];
            if (b.comptype == "sizeof") {
@@ -1078,8 +1078,8 @@ bool isArgSizeConstant(BoundAST &bast, Binding &bout, unsigned &size) {
    if (bast.ast->oper == EQ) {
       ASTNode *n1 = bast.ast->getChild(0);
       ASTNode *n2 = bast.ast->getChild(1);
-      if (dynamic_cast<ConstantNode*>(n1)) {
-        if (dynamic_cast<IdentifierNode*>(n2)) {
+      if (static_cast<ConstantNode*>(n1)) {
+        if (static_cast<IdentifierNode*>(n2)) {
            IdentifierNode *in = (IdentifierNode*)n2;
            Binding b = bast.bindings[in->value];
            if (b.comptype == "argsize")  {
@@ -1089,8 +1089,8 @@ bool isArgSizeConstant(BoundAST &bast, Binding &bout, unsigned &size) {
            }
         }
       }
-      else if (dynamic_cast<ConstantNode*>(n2)) {
-        if (dynamic_cast<IdentifierNode*>(n1)) {
+      else if (static_cast<ConstantNode*>(n2)) {
+        if (static_cast<IdentifierNode*>(n1)) {
            IdentifierNode *in = (IdentifierNode*)n1;
            Binding b = bast.bindings[in->value];
            if (b.comptype == "argsize") {
diff --git a/lib/Prose/lexer.cpp b/lib/Prose/lexer.cpp
index 5a83594..4ea9d45 100644
--- a/lib/Prose/lexer.cpp
+++ b/lib/Prose/lexer.cpp
@@ -1,6 +1,6 @@
-#line 2 "/home/tuba/Documents/releases/PROMPT/lib/Prose/lexer.cpp"
+#line 2 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/lexer.cpp"
 
-#line 4 "/home/tuba/Documents/releases/PROMPT/lib/Prose/lexer.cpp"
+#line 4 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/lexer.cpp"
 
 #define  YY_INT_ALIGNED short int
 
@@ -9,7 +9,7 @@
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 6
-#define YY_FLEX_SUBMINOR_VERSION 0
+#define YY_FLEX_SUBMINOR_VERSION 4
 #if YY_FLEX_SUBMINOR_VERSION > 0
 #define FLEX_BETA
 #endif
@@ -84,60 +84,48 @@ typedef unsigned int flex_uint32_t;
 #define UINT32_MAX             (4294967295U)
 #endif
 
+#ifndef SIZE_MAX
+#define SIZE_MAX               (~(size_t)0)
+#endif
+
 #endif /* ! C99 */
 
 #endif /* ! FLEXINT_H */
 
-#ifdef __cplusplus
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
+/* begin standard C++ headers. */
 
-/* C99 requires __STDC__ to be defined as 1. */
-#if defined (__STDC__)
-
-#define YY_USE_CONST
-
-#endif	/* defined (__STDC__) */
-#endif	/* ! __cplusplus */
-
-#ifdef YY_USE_CONST
+/* TODO: this is always defined, so inline it */
 #define yyconst const
+
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define yynoreturn __attribute__((__noreturn__))
 #else
-#define yyconst
+#define yynoreturn
 #endif
 
 /* Returned upon end-of-file. */
 #define YY_NULL 0
 
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
+/* Promotes a possibly negative, possibly signed char to an
+ *   integer in range [0..255] for use as an array index.
  */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
 
 /* Enter a start condition.  This macro really ought to take a parameter,
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
  */
 #define BEGIN (yy_start) = 1 + 2 *
-
 /* Translate the current start state into a value that can be later handed
  * to BEGIN to return to the state.  The YYSTATE alias is for lex
  * compatibility.
  */
 #define YY_START (((yy_start) - 1) / 2)
 #define YYSTATE YY_START
-
 /* Action number for EOF rule of a given start state. */
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart(yyin  )
-
+#define YY_NEW_FILE yyrestart( yyin  )
 #define YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
@@ -167,17 +155,17 @@ typedef struct yy_buffer_state *YY_BUFFER_STATE;
 typedef size_t yy_size_t;
 #endif
 
-extern yy_size_t yyleng;
+extern int yyleng;
 
 extern FILE *yyin, *yyout;
 
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
-
+    
     /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
      *       access to the local variable yy_act. Since yyless() is a macro, it would break
-     *       existing scanners that call yyless() from OUTSIDE yylex. 
+     *       existing scanners that call yyless() from OUTSIDE yylex.
      *       One obvious solution it to make yy_act a global. I tried that, and saw
      *       a 5% performance hit in a non-yylineno scanner, because yy_act is
      *       normally declared as a register variable-- so it is not worth it.
@@ -210,7 +198,6 @@ extern FILE *yyin, *yyout;
 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
 		} \
 	while ( 0 )
-
 #define unput(c) yyunput( c, (yytext_ptr)  )
 
 #ifndef YY_STRUCT_YY_BUFFER_STATE
@@ -225,7 +212,7 @@ struct yy_buffer_state
 	/* Size of input buffer in bytes, not including room for EOB
 	 * characters.
 	 */
-	yy_size_t yy_buf_size;
+	int yy_buf_size;
 
 	/* Number of characters read into yy_ch_buf, not including EOB
 	 * characters.
@@ -253,7 +240,7 @@ struct yy_buffer_state
 
     int yy_bs_lineno; /**< The line count. */
     int yy_bs_column; /**< The column count. */
-    
+
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
@@ -281,7 +268,7 @@ struct yy_buffer_state
 /* Stack of input buffers. */
 static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
 static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
 
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
@@ -292,7 +279,6 @@ static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                           : NULL)
-
 /* Same as previous macro, but useful when we know that the buffer stack is not
  * NULL or when we need an lvalue. For internal use only.
  */
@@ -301,10 +287,10 @@ static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 /* yy_hold_char holds the character lost when yytext is formed. */
 static char yy_hold_char;
 static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-yy_size_t yyleng;
+int yyleng;
 
 /* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
+static char *yy_c_buf_p = NULL;
 static int yy_init = 0;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
@@ -313,63 +299,57 @@ static int yy_start = 0;	/* start state number */
  */
 static int yy_did_buffer_switch_on_eof;
 
-void yyrestart (FILE *input_file  );
-void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
-void yy_delete_buffer (YY_BUFFER_STATE b  );
-void yy_flush_buffer (YY_BUFFER_STATE b  );
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state (void );
-
-static void yyensure_buffer_stack (void );
-static void yy_load_buffer_state (void );
-static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+void yyrestart ( FILE *input_file  );
+void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
+void yy_delete_buffer ( YY_BUFFER_STATE b  );
+void yy_flush_buffer ( YY_BUFFER_STATE b  );
+void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state ( void );
 
-#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+static void yyensure_buffer_stack ( void );
+static void yy_load_buffer_state ( void );
+static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
+#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
 
-YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
+YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
 
-void *yyalloc (yy_size_t  );
-void *yyrealloc (void *,yy_size_t  );
-void yyfree (void *  );
+void *yyalloc ( yy_size_t  );
+void *yyrealloc ( void *, yy_size_t  );
+void yyfree ( void *  );
 
 #define yy_new_buffer yy_create_buffer
-
 #define yy_set_interactive(is_interactive) \
 	{ \
 	if ( ! YY_CURRENT_BUFFER ){ \
         yyensure_buffer_stack (); \
 		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
 	} \
 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
-
 #define yy_set_bol(at_bol) \
 	{ \
 	if ( ! YY_CURRENT_BUFFER ){\
         yyensure_buffer_stack (); \
 		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
 	} \
 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
-
 #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
 
 #define yywrap() (/*CONSTCOND*/1)
 #define YY_SKIP_YYWRAP
+typedef flex_uint8_t YY_CHAR;
 
-typedef unsigned char YY_CHAR;
-
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+FILE *yyin = NULL, *yyout = NULL;
 
 typedef int yy_state_type;
 
 extern int yylineno;
-
 int yylineno = 1;
 
 extern char *yytext;
@@ -378,24 +358,20 @@ extern char *yytext;
 #endif
 #define yytext_ptr yytext
 
-static yy_state_type yy_get_previous_state (void );
-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
-static int yy_get_next_buffer (void );
-#if defined(__GNUC__) && __GNUC__ >= 3
-__attribute__((__noreturn__))
-#endif
-static void yy_fatal_error (yyconst char msg[]  );
+static yy_state_type yy_get_previous_state ( void );
+static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
+static int yy_get_next_buffer ( void );
+static void yynoreturn yy_fatal_error ( const char* msg  );
 
 /* Done after the current pattern has been matched and before the
  * corresponding action - sets up yytext.
  */
 #define YY_DO_BEFORE_ACTION \
 	(yytext_ptr) = yy_bp; \
-	yyleng = (size_t) (yy_cp - yy_bp); \
+	yyleng = (int) (yy_cp - yy_bp); \
 	(yy_hold_char) = *yy_cp; \
 	*yy_cp = '\0'; \
 	(yy_c_buf_p) = yy_cp;
-
 #define YY_NUM_RULES 73
 #define YY_END_OF_BUFFER 74
 /* This struct is not used in this scanner,
@@ -405,7 +381,7 @@ struct yy_trans_info
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static yyconst flex_int16_t yy_accept[275] =
+static const flex_int16_t yy_accept[275] =
     {   0,
         0,    0,   74,   72,    1,    1,   64,   68,   66,   67,
        72,   70,   59,   63,   61,   69,   69,   69,   69,   69,
@@ -439,7 +415,7 @@ static yyconst flex_int16_t yy_accept[275] =
        69,   69,   41,    0
     } ;
 
-static yyconst YY_CHAR yy_ec[256] =
+static const YY_CHAR yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
@@ -471,7 +447,7 @@ static yyconst YY_CHAR yy_ec[256] =
         1,    1,    1,    1,    1
     } ;
 
-static yyconst YY_CHAR yy_meta[39] =
+static const YY_CHAR yy_meta[39] =
     {   0,
         1,    1,    2,    1,    1,    1,    1,    1,    3,    1,
         1,    1,    3,    3,    3,    3,    3,    3,    3,    3,
@@ -479,7 +455,7 @@ static yyconst YY_CHAR yy_meta[39] =
         3,    3,    3,    3,    3,    3,    3,    3
     } ;
 
-static yyconst flex_uint16_t yy_base[277] =
+static const flex_int16_t yy_base[277] =
     {   0,
         0,    0,  285,  286,   37,   39,  273,  286,  286,  286,
       275,  273,  270,  286,  269,    0,   18,   17,  251,   32,
@@ -513,7 +489,7 @@ static yyconst flex_uint16_t yy_base[277] =
        64,   66,    0,  286,   57,  103
     } ;
 
-static yyconst flex_int16_t yy_def[277] =
+static const flex_int16_t yy_def[277] =
     {   0,
       274,    1,  274,  274,  274,  274,  274,  274,  274,  274,
       274,  274,  274,  274,  274,  275,  275,  275,  275,  275,
@@ -547,7 +523,7 @@ static yyconst flex_int16_t yy_def[277] =
       275,  275,  275,    0,  274,  274
     } ;
 
-static yyconst flex_uint16_t yy_nxt[325] =
+static const flex_int16_t yy_nxt[325] =
     {   0,
         4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
        14,   15,   16,   16,   17,   18,   19,   20,   21,   22,
@@ -587,7 +563,7 @@ static yyconst flex_uint16_t yy_nxt[325] =
       274,  274,  274,  274
     } ;
 
-static yyconst flex_int16_t yy_chk[325] =
+static const flex_int16_t yy_chk[325] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -628,7 +604,7 @@ static yyconst flex_int16_t yy_chk[325] =
     } ;
 
 /* Table of booleans, true if rule could match eol. */
-static yyconst flex_int32_t yy_rule_can_match_eol[74] =
+static const flex_int32_t yy_rule_can_match_eol[74] =
     {   0,
 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
@@ -666,7 +642,8 @@ void BeginToken(char *t) ;
 void yyerror(char const *s) {
   fprintf (stderr, "%s\n", s);
 }
-#line 670 "/home/tuba/Documents/releases/PROMPT/lib/Prose/lexer.cpp"
+#line 646 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/lexer.cpp"
+#line 647 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/lexer.cpp"
 
 #define INITIAL 0
 
@@ -682,36 +659,36 @@ void yyerror(char const *s) {
 #define YY_EXTRA_TYPE void *
 #endif
 
-static int yy_init_globals (void );
+static int yy_init_globals ( void );
 
 /* Accessor methods to globals.
    These are made visible to non-reentrant scanners for convenience. */
 
-int yylex_destroy (void );
+int yylex_destroy ( void );
 
-int yyget_debug (void );
+int yyget_debug ( void );
 
-void yyset_debug (int debug_flag  );
+void yyset_debug ( int debug_flag  );
 
-YY_EXTRA_TYPE yyget_extra (void );
+YY_EXTRA_TYPE yyget_extra ( void );
 
-void yyset_extra (YY_EXTRA_TYPE user_defined  );
+void yyset_extra ( YY_EXTRA_TYPE user_defined  );
 
-FILE *yyget_in (void );
+FILE *yyget_in ( void );
 
-void yyset_in  (FILE * _in_str  );
+void yyset_in  ( FILE * _in_str  );
 
-FILE *yyget_out (void );
+FILE *yyget_out ( void );
 
-void yyset_out  (FILE * _out_str  );
+void yyset_out  ( FILE * _out_str  );
 
-yy_size_t yyget_leng (void );
+			int yyget_leng ( void );
 
-char *yyget_text (void );
+char *yyget_text ( void );
 
-int yyget_lineno (void );
+int yyget_lineno ( void );
 
-void yyset_lineno (int _line_number  );
+void yyset_lineno ( int _line_number  );
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -719,9 +696,9 @@ void yyset_lineno (int _line_number  );
 
 #ifndef YY_SKIP_YYWRAP
 #ifdef __cplusplus
-extern "C" int yywrap (void );
+extern "C" int yywrap ( void );
 #else
-extern int yywrap (void );
+extern int yywrap ( void );
 #endif
 #endif
 
@@ -730,19 +707,18 @@ extern int yywrap (void );
 #endif
 
 #ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int );
+static void yy_flex_strncpy ( char *, const char *, int );
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * );
+static int yy_flex_strlen ( const char * );
 #endif
 
 #ifndef YY_NO_INPUT
-
 #ifdef __cplusplus
-static int yyinput (void );
+static int yyinput ( void );
 #else
-static int input (void );
+static int input ( void );
 #endif
 
 #endif
@@ -762,7 +738,7 @@ static int input (void );
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -773,7 +749,7 @@ static int input (void );
 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
 		int c = '*'; \
-		size_t n; \
+		int n; \
 		for ( n = 0; n < max_size && \
 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
@@ -786,7 +762,7 @@ static int input (void );
 	else \
 		{ \
 		errno=0; \
-		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
 			{ \
 			if( errno != EINTR) \
 				{ \
@@ -875,17 +851,17 @@ YY_DECL
 		if ( ! YY_CURRENT_BUFFER ) {
 			yyensure_buffer_stack ();
 			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer(yyin,YY_BUF_SIZE );
+				yy_create_buffer( yyin, YY_BUF_SIZE );
 		}
 
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 		}
 
 	{
 #line 23 "Prose.l"
 
 
-#line 889 "/home/tuba/Documents/releases/PROMPT/lib/Prose/lexer.cpp"
+#line 865 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/lexer.cpp"
 
 	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
 		{
@@ -913,9 +889,9 @@ yy_match:
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
 				if ( yy_current_state >= 275 )
-					yy_c = yy_meta[(unsigned int) yy_c];
+					yy_c = yy_meta[yy_c];
 				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
 			++yy_cp;
 			}
 		while ( yy_base[yy_current_state] != 286 );
@@ -933,10 +909,10 @@ yy_find_action:
 
 		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
 			{
-			yy_size_t yyl;
+			int yyl;
 			for ( yyl = 0; yyl < yyleng; ++yyl )
 				if ( yytext[yyl] == '\n' )
-					   
+					
     yylineno++;
 ;
 			}
@@ -1347,7 +1323,7 @@ YY_RULE_SETUP
 #line 126 "Prose.l"
 ECHO;
 	YY_BREAK
-#line 1351 "/home/tuba/Documents/releases/PROMPT/lib/Prose/lexer.cpp"
+#line 1327 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/lexer.cpp"
 case YY_STATE_EOF(INITIAL):
 	yyterminate();
 
@@ -1425,7 +1401,7 @@ case YY_STATE_EOF(INITIAL):
 				{
 				(yy_did_buffer_switch_on_eof) = 0;
 
-				if ( yywrap( ) )
+				if ( yywrap(  ) )
 					{
 					/* Note: because we've taken care in
 					 * yy_get_next_buffer() to have set up
@@ -1492,7 +1468,7 @@ static int yy_get_next_buffer (void)
 {
     	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
 	char *source = (yytext_ptr);
-	yy_size_t number_to_move, i;
+	int number_to_move, i;
 	int ret_val;
 
 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
@@ -1521,7 +1497,7 @@ static int yy_get_next_buffer (void)
 	/* Try to read more data. */
 
 	/* First move last chars to start of buffer. */
-	number_to_move = (yy_size_t) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
 
 	for ( i = 0; i < number_to_move; ++i )
 		*(dest++) = *(source++);
@@ -1534,7 +1510,7 @@ static int yy_get_next_buffer (void)
 
 	else
 		{
-			yy_size_t num_to_read =
+			int num_to_read =
 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
@@ -1548,7 +1524,7 @@ static int yy_get_next_buffer (void)
 
 			if ( b->yy_is_our_buffer )
 				{
-				yy_size_t new_size = b->yy_buf_size * 2;
+				int new_size = b->yy_buf_size * 2;
 
 				if ( new_size <= 0 )
 					b->yy_buf_size += b->yy_buf_size / 8;
@@ -1557,11 +1533,12 @@ static int yy_get_next_buffer (void)
 
 				b->yy_ch_buf = (char *)
 					/* Include room in for 2 EOB chars. */
-					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+					yyrealloc( (void *) b->yy_ch_buf,
+							 (yy_size_t) (b->yy_buf_size + 2)  );
 				}
 			else
 				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
+				b->yy_ch_buf = NULL;
 
 			if ( ! b->yy_ch_buf )
 				YY_FATAL_ERROR(
@@ -1589,7 +1566,7 @@ static int yy_get_next_buffer (void)
 		if ( number_to_move == YY_MORE_ADJ )
 			{
 			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart(yyin  );
+			yyrestart( yyin  );
 			}
 
 		else
@@ -1603,12 +1580,15 @@ static int yy_get_next_buffer (void)
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
-	if ((int) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
 		/* Extend the array by 50%, plus the number we really need. */
 		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
+			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+		/* "- 2" to take care of EOB's */
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
 	}
 
 	(yy_n_chars) += number_to_move;
@@ -1641,9 +1621,9 @@ static int yy_get_next_buffer (void)
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
 			if ( yy_current_state >= 275 )
-				yy_c = yy_meta[(unsigned int) yy_c];
+				yy_c = yy_meta[yy_c];
 			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
 		}
 
 	return yy_current_state;
@@ -1669,9 +1649,9 @@ static int yy_get_next_buffer (void)
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
 		if ( yy_current_state >= 275 )
-			yy_c = yy_meta[(unsigned int) yy_c];
+			yy_c = yy_meta[yy_c];
 		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
 	yy_is_jam = (yy_current_state == 274);
 
 		return yy_is_jam ? 0 : yy_current_state;
@@ -1705,7 +1685,7 @@ static int yy_get_next_buffer (void)
 
 		else
 			{ /* need more input */
-			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
+			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
 			++(yy_c_buf_p);
 
 			switch ( yy_get_next_buffer(  ) )
@@ -1722,14 +1702,14 @@ static int yy_get_next_buffer (void)
 					 */
 
 					/* Reset buffer status. */
-					yyrestart(yyin );
+					yyrestart( yyin );
 
 					/*FALLTHROUGH*/
 
 				case EOB_ACT_END_OF_FILE:
 					{
-					if ( yywrap( ) )
-						return EOF;
+					if ( yywrap(  ) )
+						return 0;
 
 					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
@@ -1752,7 +1732,7 @@ static int yy_get_next_buffer (void)
 	(yy_hold_char) = *++(yy_c_buf_p);
 
 	if ( c == '\n' )
-		   
+		
     yylineno++;
 ;
 
@@ -1771,11 +1751,11 @@ static int yy_get_next_buffer (void)
 	if ( ! YY_CURRENT_BUFFER ){
         yyensure_buffer_stack ();
 		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer(yyin,YY_BUF_SIZE );
+            yy_create_buffer( yyin, YY_BUF_SIZE );
 	}
 
-	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
-	yy_load_buffer_state( );
+	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
+	yy_load_buffer_state(  );
 }
 
 /** Switch to a different input buffer.
@@ -1803,7 +1783,7 @@ static int yy_get_next_buffer (void)
 		}
 
 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( );
+	yy_load_buffer_state(  );
 
 	/* We don't actually know whether we did this switch during
 	 * EOF (yywrap()) processing, but the only time this flag
@@ -1831,22 +1811,22 @@ static void yy_load_buffer_state  (void)
 {
 	YY_BUFFER_STATE b;
     
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
-	b->yy_buf_size = (yy_size_t)size;
+	b->yy_buf_size = size;
 
 	/* yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
 	 */
-	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
 	if ( ! b->yy_ch_buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
 	b->yy_is_our_buffer = 1;
 
-	yy_init_buffer(b,file );
+	yy_init_buffer( b, file );
 
 	return b;
 }
@@ -1865,9 +1845,9 @@ static void yy_load_buffer_state  (void)
 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
 
 	if ( b->yy_is_our_buffer )
-		yyfree((void *) b->yy_ch_buf  );
+		yyfree( (void *) b->yy_ch_buf  );
 
-	yyfree((void *) b  );
+	yyfree( (void *) b  );
 }
 
 /* Initializes or reinitializes a buffer.
@@ -1879,7 +1859,7 @@ static void yy_load_buffer_state  (void)
 {
 	int oerrno = errno;
     
-	yy_flush_buffer(b );
+	yy_flush_buffer( b );
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
@@ -1922,7 +1902,7 @@ static void yy_load_buffer_state  (void)
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
 	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 }
 
 /** Pushes the new state onto the stack. The new state becomes
@@ -1953,7 +1933,7 @@ void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
 
 	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( );
+	yy_load_buffer_state(  );
 	(yy_did_buffer_switch_on_eof) = 1;
 }
 
@@ -1972,7 +1952,7 @@ void yypop_buffer_state (void)
 		--(yy_buffer_stack_top);
 
 	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 		(yy_did_buffer_switch_on_eof) = 1;
 	}
 }
@@ -1990,15 +1970,15 @@ static void yyensure_buffer_stack (void)
 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 		 * immediate realloc on the next call.
          */
-		num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
 								(num_to_alloc * sizeof(struct yy_buffer_state*)
 								);
 		if ( ! (yy_buffer_stack) )
 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-								  
+
 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
+
 		(yy_buffer_stack_max) = num_to_alloc;
 		(yy_buffer_stack_top) = 0;
 		return;
@@ -2027,7 +2007,7 @@ static void yyensure_buffer_stack (void)
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
  * 
- * @return the newly allocated buffer state object. 
+ * @return the newly allocated buffer state object.
  */
 YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
 {
@@ -2037,23 +2017,23 @@ YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
 		/* They forgot to leave room for the EOB's. */
-		return 0;
+		return NULL;
 
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
 
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
 	b->yy_buf_pos = b->yy_ch_buf = base;
 	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
+	b->yy_input_file = NULL;
 	b->yy_n_chars = b->yy_buf_size;
 	b->yy_is_interactive = 0;
 	b->yy_at_bol = 1;
 	b->yy_fill_buffer = 0;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	yy_switch_to_buffer(b  );
+	yy_switch_to_buffer( b  );
 
 	return b;
 }
@@ -2066,10 +2046,10 @@ YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
  * @note If you want to scan bytes that may contain NUL values, then use
  *       yy_scan_bytes() instead.
  */
-YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+YY_BUFFER_STATE yy_scan_string (const char * yystr )
 {
     
-	return yy_scan_bytes(yystr,strlen(yystr) );
+	return yy_scan_bytes( yystr, (int) strlen(yystr) );
 }
 
 /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
@@ -2079,16 +2059,16 @@ YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
  * 
  * @return the newly allocated buffer state object.
  */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
+YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
 {
 	YY_BUFFER_STATE b;
 	char *buf;
 	yy_size_t n;
-	yy_size_t i;
+	int i;
     
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = _yybytes_len + 2;
-	buf = (char *) yyalloc(n  );
+	n = (yy_size_t) (_yybytes_len + 2);
+	buf = (char *) yyalloc( n  );
 	if ( ! buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
 
@@ -2097,7 +2077,7 @@ YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len
 
 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
 
-	b = yy_scan_buffer(buf,n );
+	b = yy_scan_buffer( buf, n );
 	if ( ! b )
 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
 
@@ -2113,9 +2093,9 @@ YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len
 #define YY_EXIT_FAILURE 2
 #endif
 
-static void yy_fatal_error (yyconst char* msg )
+static void yynoreturn yy_fatal_error (const char* msg )
 {
-			(void) fprintf( stderr, "%s\n", msg );
+			fprintf( stderr, "%s\n", msg );
 	exit( YY_EXIT_FAILURE );
 }
 
@@ -2143,7 +2123,7 @@ static void yy_fatal_error (yyconst char* msg )
  */
 int yyget_lineno  (void)
 {
-        
+    
     return yylineno;
 }
 
@@ -2166,7 +2146,7 @@ FILE *yyget_out  (void)
 /** Get the length of the current token.
  * 
  */
-yy_size_t yyget_leng  (void)
+int yyget_leng  (void)
 {
         return yyleng;
 }
@@ -2225,10 +2205,10 @@ static int yy_init_globals (void)
     /* We do not touch yylineno unless the option is enabled. */
     yylineno =  1;
     
-    (yy_buffer_stack) = 0;
+    (yy_buffer_stack) = NULL;
     (yy_buffer_stack_top) = 0;
     (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = (char *) 0;
+    (yy_c_buf_p) = NULL;
     (yy_init) = 0;
     (yy_start) = 0;
 
@@ -2237,8 +2217,8 @@ static int yy_init_globals (void)
     yyin = stdin;
     yyout = stdout;
 #else
-    yyin = (FILE *) 0;
-    yyout = (FILE *) 0;
+    yyin = NULL;
+    yyout = NULL;
 #endif
 
     /* For future reference: Set errno on error, since we are called by
@@ -2253,7 +2233,7 @@ int yylex_destroy  (void)
     
     /* Pop the buffer stack, destroying each element. */
 	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		yy_delete_buffer( YY_CURRENT_BUFFER  );
 		YY_CURRENT_BUFFER_LVALUE = NULL;
 		yypop_buffer_state();
 	}
@@ -2274,7 +2254,7 @@ int yylex_destroy  (void)
  */
 
 #ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+static void yy_flex_strncpy (char* s1, const char * s2, int n )
 {
 		
 	int i;
@@ -2284,7 +2264,7 @@ static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * s )
+static int yy_flex_strlen (const char * s )
 {
 	int n;
 	for ( n = 0; s[n]; ++n )
@@ -2296,7 +2276,7 @@ static int yy_flex_strlen (yyconst char * s )
 
 void *yyalloc (yy_size_t  size )
 {
-			return (void *) malloc( size );
+			return malloc(size);
 }
 
 void *yyrealloc  (void * ptr, yy_size_t  size )
@@ -2309,7 +2289,7 @@ void *yyrealloc  (void * ptr, yy_size_t  size )
 	 * any pointer type to void*, and deal with argument conversions
 	 * as though doing an assignment.
 	 */
-	return (void *) realloc( (char *) ptr, size );
+	return realloc(ptr, size);
 }
 
 void yyfree (void * ptr )
diff --git a/lib/Prose/parser.cpp b/lib/Prose/parser.cpp
index e4d76da..891ed0d 100644
--- a/lib/Prose/parser.cpp
+++ b/lib/Prose/parser.cpp
@@ -1,8 +1,9 @@
-/* A Bison parser, made by GNU Bison 3.0.4.  */
+/* A Bison parser, made by GNU Bison 3.5.1.  */
 
 /* Bison implementation for Yacc-like parsers in C
 
-   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
+   Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -40,11 +41,14 @@
    define necessary library symbols; they are noted "INFRINGES ON
    USER NAME SPACE" below.  */
 
+/* Undocumented macros, especially those whose name start with YY_,
+   are private implementation details.  Do not rely on them.  */
+
 /* Identify Bison output.  */
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "3.0.4"
+#define YYBISON_VERSION "3.5.1"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -61,8 +65,8 @@
 
 
 
-/* Copy the first part of user declarations.  */
-#line 3 "Prose.y" /* yacc.c:339  */
+/* First part of user prologue.  */
+#line 3 "Prose.y"
 
 
 #include <stdbool.h>
@@ -105,13 +109,26 @@ extern std::set<std::string> lazyInitSingles;
 extern std::map<std::string, std::vector<std::string> > inferenceClue;
 
 
-#line 109 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:339  */
+#line 113 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
 
+# ifndef YY_CAST
+#  ifdef __cplusplus
+#   define YY_CAST(Type, Val) static_cast<Type> (Val)
+#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
+#  else
+#   define YY_CAST(Type, Val) ((Type) (Val))
+#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
+#  endif
+# endif
 # ifndef YY_NULLPTR
-#  if defined __cplusplus && 201103L <= __cplusplus
-#   define YY_NULLPTR nullptr
+#  if defined __cplusplus
+#   if 201103L <= __cplusplus
+#    define YY_NULLPTR nullptr
+#   else
+#    define YY_NULLPTR 0
+#   endif
 #  else
-#   define YY_NULLPTR 0
+#   define YY_NULLPTR ((void*)0)
 #  endif
 # endif
 
@@ -123,10 +140,10 @@ extern std::map<std::string, std::vector<std::string> > inferenceClue;
 # define YYERROR_VERBOSE 1
 #endif
 
-/* In a future release of Bison, this section will be replaced
-   by #include "parser.h".  */
-#ifndef YY_YY_HOME_TUBA_DOCUMENTS_RELEASES_PROMPT_LIB_PROSE_PARSER_H_INCLUDED
-# define YY_YY_HOME_TUBA_DOCUMENTS_RELEASES_PROMPT_LIB_PROSE_PARSER_H_INCLUDED
+/* Use api.header.include to #include this header
+   instead of duplicating it here.  */
+#ifndef YY_YY_HOME_MUQI_PROMPT_EXTERNAL_FUNCTION_PROMPT_LIB_PROSE_PARSER_H_INCLUDED
+# define YY_YY_HOME_MUQI_PROMPT_EXTERNAL_FUNCTION_PROMPT_LIB_PROSE_PARSER_H_INCLUDED
 /* Debug traces.  */
 #ifndef YYDEBUG
 # define YYDEBUG 0
@@ -215,10 +232,9 @@ extern int yydebug;
 
 /* Value type.  */
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-
 union YYSTYPE
 {
-#line 124 "Prose.y" /* yacc.c:355  */
+#line 124 "Prose.y"
 
 	bool y_bool;
 	int y_int;
@@ -235,9 +251,9 @@ union YYSTYPE
 	char *y_ident;
         Op op;
 
-#line 239 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:355  */
-};
+#line 255 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
 
+};
 typedef union YYSTYPE YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
 # define YYSTYPE_IS_DECLARED 1
@@ -262,38 +278,83 @@ extern YYSTYPE yylval;
 extern YYLTYPE yylloc;
 int yyparse (void);
 
-#endif /* !YY_YY_HOME_TUBA_DOCUMENTS_RELEASES_PROMPT_LIB_PROSE_PARSER_H_INCLUDED  */
+#endif /* !YY_YY_HOME_MUQI_PROMPT_EXTERNAL_FUNCTION_PROMPT_LIB_PROSE_PARSER_H_INCLUDED  */
 
-/* Copy the second part of user declarations.  */
 
-#line 270 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:358  */
 
 #ifdef short
 # undef short
 #endif
 
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
+/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
+   <limits.h> and (if available) <stdint.h> are included
+   so that the code can choose integer types of a good width.  */
+
+#ifndef __PTRDIFF_MAX__
+# include <limits.h> /* INFRINGES ON USER NAME SPACE */
+# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
+#  define YY_STDINT_H
+# endif
 #endif
 
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
+/* Narrow types that promote to a signed type and that can represent a
+   signed or unsigned integer of at least N bits.  In tables they can
+   save space and decrease cache pressure.  Promoting to a signed type
+   helps avoid bugs in integer arithmetic.  */
+
+#ifdef __INT_LEAST8_MAX__
+typedef __INT_LEAST8_TYPE__ yytype_int8;
+#elif defined YY_STDINT_H
+typedef int_least8_t yytype_int8;
 #else
 typedef signed char yytype_int8;
 #endif
 
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
+#ifdef __INT_LEAST16_MAX__
+typedef __INT_LEAST16_TYPE__ yytype_int16;
+#elif defined YY_STDINT_H
+typedef int_least16_t yytype_int16;
 #else
-typedef unsigned short int yytype_uint16;
+typedef short yytype_int16;
 #endif
 
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
+#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST8_TYPE__ yytype_uint8;
+#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST8_MAX <= INT_MAX)
+typedef uint_least8_t yytype_uint8;
+#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
+typedef unsigned char yytype_uint8;
+#else
+typedef short yytype_uint8;
+#endif
+
+#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST16_TYPE__ yytype_uint16;
+#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST16_MAX <= INT_MAX)
+typedef uint_least16_t yytype_uint16;
+#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
+typedef unsigned short yytype_uint16;
 #else
-typedef short int yytype_int16;
+typedef int yytype_uint16;
+#endif
+
+#ifndef YYPTRDIFF_T
+# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
+#  define YYPTRDIFF_T __PTRDIFF_TYPE__
+#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
+# elif defined PTRDIFF_MAX
+#  ifndef ptrdiff_t
+#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  endif
+#  define YYPTRDIFF_T ptrdiff_t
+#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
+# else
+#  define YYPTRDIFF_T long
+#  define YYPTRDIFF_MAXIMUM LONG_MAX
+# endif
 #endif
 
 #ifndef YYSIZE_T
@@ -301,15 +362,27 @@ typedef short int yytype_int16;
 #  define YYSIZE_T __SIZE_TYPE__
 # elif defined size_t
 #  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T
+# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
 #  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
 #  define YYSIZE_T size_t
 # else
-#  define YYSIZE_T unsigned int
+#  define YYSIZE_T unsigned
 # endif
 #endif
 
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+#define YYSIZE_MAXIMUM                                  \
+  YY_CAST (YYPTRDIFF_T,                                 \
+           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
+            ? YYPTRDIFF_MAXIMUM                         \
+            : YY_CAST (YYSIZE_T, -1)))
+
+#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
+
+/* Stored state numbers (used for stacks). */
+typedef yytype_uint8 yy_state_t;
+
+/* State numbers in computations.  */
+typedef int yy_state_fast_t;
 
 #ifndef YY_
 # if defined YYENABLE_NLS && YYENABLE_NLS
@@ -323,30 +396,19 @@ typedef short int yytype_int16;
 # endif
 #endif
 
-#ifndef YY_ATTRIBUTE
-# if (defined __GNUC__                                               \
-      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
-     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
-#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+#ifndef YY_ATTRIBUTE_PURE
+# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
 # else
-#  define YY_ATTRIBUTE(Spec) /* empty */
+#  define YY_ATTRIBUTE_PURE
 # endif
 #endif
 
-#ifndef YY_ATTRIBUTE_PURE
-# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
-#endif
-
 #ifndef YY_ATTRIBUTE_UNUSED
-# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
-#endif
-
-#if !defined _Noreturn \
-     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
-# if defined _MSC_VER && 1200 <= _MSC_VER
-#  define _Noreturn __declspec (noreturn)
+# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
 # else
-#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+#  define YY_ATTRIBUTE_UNUSED
 # endif
 #endif
 
@@ -357,13 +419,13 @@ typedef short int yytype_int16;
 # define YYUSE(E) /* empty */
 #endif
 
-#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
 /* Suppress an incorrect diagnostic about yylval being uninitialized.  */
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
-    _Pragma ("GCC diagnostic push") \
-    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                            \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
     _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
     _Pragma ("GCC diagnostic pop")
 #else
 # define YY_INITIAL_VALUE(Value) Value
@@ -376,6 +438,20 @@ typedef short int yytype_int16;
 # define YY_INITIAL_VALUE(Value) /* Nothing. */
 #endif
 
+#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
+# define YY_IGNORE_USELESS_CAST_BEGIN                          \
+    _Pragma ("GCC diagnostic push")                            \
+    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
+# define YY_IGNORE_USELESS_CAST_END            \
+    _Pragma ("GCC diagnostic pop")
+#endif
+#ifndef YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_END
+#endif
+
+
+#define YY_ASSERT(E) ((void) (0 && (E)))
 
 #if ! defined yyoverflow || YYERROR_VERBOSE
 
@@ -453,18 +529,19 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  yytype_int16 yyss_alloc;
+  yy_state_t yyss_alloc;
   YYSTYPE yyvs_alloc;
   YYLTYPE yyls_alloc;
 };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
 
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE) + sizeof (YYLTYPE)) \
+     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE) \
+             + YYSIZEOF (YYLTYPE)) \
       + 2 * YYSTACK_GAP_MAXIMUM)
 
 # define YYCOPY_NEEDED 1
@@ -477,11 +554,11 @@ union yyalloc
 # define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
     do                                                                  \
       {                                                                 \
-        YYSIZE_T yynewbytes;                                            \
+        YYPTRDIFF_T yynewbytes;                                         \
         YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
         Stack = &yyptr->Stack_alloc;                                    \
-        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-        yyptr += yynewbytes / sizeof (*yyptr);                          \
+        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
       }                                                                 \
     while (0)
 
@@ -493,12 +570,12 @@ union yyalloc
 # ifndef YYCOPY
 #  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(Dst, Src, Count) \
-      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
 #  else
 #   define YYCOPY(Dst, Src, Count)              \
       do                                        \
         {                                       \
-          YYSIZE_T yyi;                         \
+          YYPTRDIFF_T yyi;                      \
           for (yyi = 0; yyi < (Count); yyi++)   \
             (Dst)[yyi] = (Src)[yyi];            \
         }                                       \
@@ -521,17 +598,18 @@ union yyalloc
 /* YYNSTATES -- Number of states.  */
 #define YYNSTATES  177
 
-/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
-   by yylex, with out-of-bounds checking.  */
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   327
 
+
+/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, with out-of-bounds checking.  */
 #define YYTRANSLATE(YYX)                                                \
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+  (0 <= (YYX) && (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
-   as returned by yylex, without out-of-bounds checking.  */
-static const yytype_uint8 yytranslate[] =
+   as returned by yylex.  */
+static const yytype_int8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -570,7 +648,7 @@ static const yytype_uint8 yytranslate[] =
 
 #if YYDEBUG
   /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
-static const yytype_uint16 yyrline[] =
+static const yytype_int16 yyrline[] =
 {
        0,   156,   156,   164,   165,   169,   170,   171,   172,   173,
      174,   188,   201,   202,   206,   207,   210,   212,   218,   219,
@@ -610,7 +688,7 @@ static const char *const yytname[] =
 # ifdef YYPRINT
 /* YYTOKNUM[NUM] -- (External) token number corresponding to the
    (internal) symbol number NUM (which must be that of a token).  */
-static const yytype_uint16 yytoknum[] =
+static const yytype_int16 yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
@@ -623,14 +701,14 @@ static const yytype_uint16 yytoknum[] =
 };
 # endif
 
-#define YYPACT_NINF -125
+#define YYPACT_NINF (-125)
 
-#define yypact_value_is_default(Yystate) \
-  (!!((Yystate) == (-125)))
+#define yypact_value_is_default(Yyn) \
+  ((Yyn) == YYPACT_NINF)
 
-#define YYTABLE_NINF -43
+#define YYTABLE_NINF (-43)
 
-#define yytable_value_is_error(Yytable_value) \
+#define yytable_value_is_error(Yyn) \
   0
 
   /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
@@ -660,7 +738,7 @@ static const yytype_int16 yypact[] =
   /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
      Performed when YYTABLE does not specify something else to do.  Zero
      means the default is an error.  */
-static const yytype_uint8 yydefact[] =
+static const yytype_int8 yydefact[] =
 {
        0,     0,     0,     0,     1,     3,     0,     0,     0,     0,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
@@ -751,7 +829,7 @@ static const yytype_int16 yycheck[] =
 
   /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
      symbol of state STATE-NUM.  */
-static const yytype_uint8 yystos[] =
+static const yytype_int8 yystos[] =
 {
        0,    24,    81,    58,     0,    73,    82,     7,    13,    29,
       34,    37,    40,    64,    65,    83,    61,    38,    21,     9,
@@ -774,7 +852,7 @@ static const yytype_uint8 yystos[] =
 };
 
   /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint8 yyr1[] =
+static const yytype_int8 yyr1[] =
 {
        0,    80,    81,    82,    82,    83,    83,    83,    83,    83,
       83,    83,    83,    83,    84,    84,    85,    85,    86,    86,
@@ -787,7 +865,7 @@ static const yytype_uint8 yyr1[] =
 };
 
   /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
+static const yytype_int8 yyr2[] =
 {
        0,     2,    16,     0,     3,     3,     3,     5,     3,     5,
        7,     9,     4,     4,     1,     1,     1,     3,     0,     3,
@@ -812,22 +890,22 @@ static const yytype_uint8 yyr2[] =
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
-#define YYBACKUP(Token, Value)                                  \
-do                                                              \
-  if (yychar == YYEMPTY)                                        \
-    {                                                           \
-      yychar = (Token);                                         \
-      yylval = (Value);                                         \
-      YYPOPSTACK (yylen);                                       \
-      yystate = *yyssp;                                         \
-      goto yybackup;                                            \
-    }                                                           \
-  else                                                          \
-    {                                                           \
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;                                                  \
-    }                                                           \
-while (0)
+#define YYBACKUP(Token, Value)                                    \
+  do                                                              \
+    if (yychar == YYEMPTY)                                        \
+      {                                                           \
+        yychar = (Token);                                         \
+        yylval = (Value);                                         \
+        YYPOPSTACK (yylen);                                       \
+        yystate = *yyssp;                                         \
+        goto yybackup;                                            \
+      }                                                           \
+    else                                                          \
+      {                                                           \
+        yyerror (YY_("syntax error: cannot back up")); \
+        YYERROR;                                                  \
+      }                                                           \
+  while (0)
 
 /* Error token number */
 #define YYTERROR        1
@@ -886,10 +964,10 @@ do {                                            \
 /* Print *YYLOCP on YYO.  Private, do not rely on its existence. */
 
 YY_ATTRIBUTE_UNUSED
-static unsigned
+static int
 yy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)
 {
-  unsigned res = 0;
+  int res = 0;
   int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;
   if (0 <= yylocp->first_line)
     {
@@ -932,40 +1010,42 @@ do {                                                                      \
 } while (0)
 
 
-/*----------------------------------------.
-| Print this symbol's value on YYOUTPUT.  |
-`----------------------------------------*/
+/*-----------------------------------.
+| Print this symbol's value on YYO.  |
+`-----------------------------------*/
 
 static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp)
+yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp)
 {
-  FILE *yyo = yyoutput;
-  YYUSE (yyo);
+  FILE *yyoutput = yyo;
+  YYUSE (yyoutput);
   YYUSE (yylocationp);
   if (!yyvaluep)
     return;
 # ifdef YYPRINT
   if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
 # endif
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+/*---------------------------.
+| Print this symbol on YYO.  |
+`---------------------------*/
 
 static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp)
+yy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp)
 {
-  YYFPRINTF (yyoutput, "%s %s (",
+  YYFPRINTF (yyo, "%s %s (",
              yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
 
-  YY_LOCATION_PRINT (yyoutput, *yylocationp);
-  YYFPRINTF (yyoutput, ": ");
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yylocationp);
-  YYFPRINTF (yyoutput, ")");
+  YY_LOCATION_PRINT (yyo, *yylocationp);
+  YYFPRINTF (yyo, ": ");
+  yy_symbol_value_print (yyo, yytype, yyvaluep, yylocationp);
+  YYFPRINTF (yyo, ")");
 }
 
 /*------------------------------------------------------------------.
@@ -974,7 +1054,7 @@ yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYL
 `------------------------------------------------------------------*/
 
 static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
 {
   YYFPRINTF (stderr, "Stack now");
   for (; yybottom <= yytop; yybottom++)
@@ -997,20 +1077,20 @@ do {                                                            \
 `------------------------------------------------*/
 
 static void
-yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule)
+yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule)
 {
-  unsigned long int yylno = yyrline[yyrule];
+  int yylno = yyrline[yyrule];
   int yynrhs = yyr2[yyrule];
   int yyi;
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
              yyrule - 1, yylno);
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
       YYFPRINTF (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr,
-                       yystos[yyssp[yyi + 1 - yynrhs]],
-                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                       yystos[+yyssp[yyi + 1 - yynrhs]],
+                       &yyvsp[(yyi + 1) - (yynrhs)]
                        , &(yylsp[(yyi + 1) - (yynrhs)])                       );
       YYFPRINTF (stderr, "\n");
     }
@@ -1054,13 +1134,13 @@ int yydebug;
 
 # ifndef yystrlen
 #  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
+#   define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
 #  else
 /* Return the length of YYSTR.  */
-static YYSIZE_T
+static YYPTRDIFF_T
 yystrlen (const char *yystr)
 {
-  YYSIZE_T yylen;
+  YYPTRDIFF_T yylen;
   for (yylen = 0; yystr[yylen]; yylen++)
     continue;
   return yylen;
@@ -1096,12 +1176,12 @@ yystpcpy (char *yydest, const char *yysrc)
    backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
    null, do not copy; instead, return the length of what the result
    would have been.  */
-static YYSIZE_T
+static YYPTRDIFF_T
 yytnamerr (char *yyres, const char *yystr)
 {
   if (*yystr == '"')
     {
-      YYSIZE_T yyn = 0;
+      YYPTRDIFF_T yyn = 0;
       char const *yyp = yystr;
 
       for (;;)
@@ -1114,7 +1194,10 @@ yytnamerr (char *yyres, const char *yystr)
           case '\\':
             if (*++yyp != '\\')
               goto do_not_strip_quotes;
-            /* Fall through.  */
+            else
+              goto append;
+
+          append:
           default:
             if (yyres)
               yyres[yyn] = *yyp;
@@ -1129,10 +1212,10 @@ yytnamerr (char *yyres, const char *yystr)
     do_not_strip_quotes: ;
     }
 
-  if (! yyres)
+  if (yyres)
+    return yystpcpy (yyres, yystr) - yyres;
+  else
     return yystrlen (yystr);
-
-  return yystpcpy (yyres, yystr) - yyres;
 }
 # endif
 
@@ -1145,19 +1228,19 @@ yytnamerr (char *yyres, const char *yystr)
    *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
    required number of bytes is too large to store.  */
 static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
+yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
+                yy_state_t *yyssp, int yytoken)
 {
-  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
   enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
   /* Internationalized format string. */
   const char *yyformat = YY_NULLPTR;
-  /* Arguments of yyformat. */
+  /* Arguments of yyformat: reported tokens (one for the "unexpected",
+     one per "expected"). */
   char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
+  /* Actual size of YYARG. */
   int yycount = 0;
+  /* Cumulated lengths of YYARG.  */
+  YYPTRDIFF_T yysize = 0;
 
   /* There are many possibilities here to consider:
      - If this state is a consistent state with a default action, then
@@ -1184,7 +1267,9 @@ yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
   */
   if (yytoken != YYEMPTY)
     {
-      int yyn = yypact[*yyssp];
+      int yyn = yypact[+*yyssp];
+      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+      yysize = yysize0;
       yyarg[yycount++] = yytname[yytoken];
       if (!yypact_value_is_default (yyn))
         {
@@ -1209,11 +1294,12 @@ yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
                   }
                 yyarg[yycount++] = yytname[yyx];
                 {
-                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
-                  if (! (yysize <= yysize1
-                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                  YYPTRDIFF_T yysize1
+                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
+                    yysize = yysize1;
+                  else
                     return 2;
-                  yysize = yysize1;
                 }
               }
         }
@@ -1225,6 +1311,7 @@ yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
       case N:                               \
         yyformat = S;                       \
       break
+    default: /* Avoid compiler warnings. */
       YYCASE_(0, YY_("syntax error"));
       YYCASE_(1, YY_("syntax error, unexpected %s"));
       YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
@@ -1235,10 +1322,13 @@ yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
     }
 
   {
-    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
-    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+    /* Don't count the "%s"s in the final size, but reserve room for
+       the terminator.  */
+    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;
+    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
+      yysize = yysize1;
+    else
       return 2;
-    yysize = yysize1;
   }
 
   if (*yymsg_alloc < yysize)
@@ -1264,8 +1354,8 @@ yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
         }
       else
         {
-          yyp++;
-          yyformat++;
+          ++yyp;
+          ++yyformat;
         }
   }
   return 0;
@@ -1315,7 +1405,7 @@ int yynerrs;
 int
 yyparse (void)
 {
-    int yystate;
+    yy_state_fast_t yystate;
     /* Number of tokens to shift before error messages enabled.  */
     int yyerrstatus;
 
@@ -1328,9 +1418,9 @@ yyparse (void)
        to reallocate them elsewhere.  */
 
     /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
+    yy_state_t yyssa[YYINITDEPTH];
+    yy_state_t *yyss;
+    yy_state_t *yyssp;
 
     /* The semantic value stack.  */
     YYSTYPE yyvsa[YYINITDEPTH];
@@ -1345,7 +1435,7 @@ yyparse (void)
     /* The locations where the error started and ended.  */
     YYLTYPE yyerror_range[3];
 
-    YYSIZE_T yystacksize;
+    YYPTRDIFF_T yystacksize;
 
   int yyn;
   int yyresult;
@@ -1360,7 +1450,7 @@ yyparse (void)
   /* Buffer for error messages, and its allocated size.  */
   char yymsgbuf[128];
   char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;
 #endif
 
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))
@@ -1383,29 +1473,41 @@ yyparse (void)
   yylsp[0] = yylloc;
   goto yysetstate;
 
+
 /*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
+| yynewstate -- push a new state, which is found in yystate.  |
 `------------------------------------------------------------*/
- yynewstate:
+yynewstate:
   /* In all cases, when you get here, the value and location stacks
      have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
- yysetstate:
-  *yyssp = yystate;
+
+/*--------------------------------------------------------------------.
+| yysetstate -- set current state (the top of the stack) to yystate.  |
+`--------------------------------------------------------------------*/
+yysetstate:
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
+  YY_IGNORE_USELESS_CAST_BEGIN
+  *yyssp = YY_CAST (yy_state_t, yystate);
+  YY_IGNORE_USELESS_CAST_END
 
   if (yyss + yystacksize - 1 <= yyssp)
+#if !defined yyoverflow && !defined YYSTACK_RELOCATE
+    goto yyexhaustedlab;
+#else
     {
       /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
+      YYPTRDIFF_T yysize = yyssp - yyss + 1;
 
-#ifdef yyoverflow
+# if defined yyoverflow
       {
         /* Give user a chance to reallocate the stack.  Use copies of
            these so that the &'s don't force the real ones into
            memory.  */
+        yy_state_t *yyss1 = yyss;
         YYSTYPE *yyvs1 = yyvs;
-        yytype_int16 *yyss1 = yyss;
         YYLTYPE *yyls1 = yyls;
 
         /* Each stack pointer address is followed by the size of the
@@ -1413,19 +1515,15 @@ yyparse (void)
            conditional around just the two extra args, but that might
            be undefined if yyoverflow is a macro.  */
         yyoverflow (YY_("memory exhausted"),
-                    &yyss1, yysize * sizeof (*yyssp),
-                    &yyvs1, yysize * sizeof (*yyvsp),
-                    &yyls1, yysize * sizeof (*yylsp),
+                    &yyss1, yysize * YYSIZEOF (*yyssp),
+                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
+                    &yyls1, yysize * YYSIZEOF (*yylsp),
                     &yystacksize);
-
-        yyls = yyls1;
         yyss = yyss1;
         yyvs = yyvs1;
+        yyls = yyls1;
       }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
+# else /* defined YYSTACK_RELOCATE */
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
         goto yyexhaustedlab;
@@ -1434,44 +1532,45 @@ yyparse (void)
         yystacksize = YYMAXDEPTH;
 
       {
-        yytype_int16 *yyss1 = yyss;
+        yy_state_t *yyss1 = yyss;
         union yyalloc *yyptr =
-          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+          YY_CAST (union yyalloc *,
+                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
         if (! yyptr)
           goto yyexhaustedlab;
         YYSTACK_RELOCATE (yyss_alloc, yyss);
         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
         YYSTACK_RELOCATE (yyls_alloc, yyls);
-#  undef YYSTACK_RELOCATE
+# undef YYSTACK_RELOCATE
         if (yyss1 != yyssa)
           YYSTACK_FREE (yyss1);
       }
 # endif
-#endif /* no yyoverflow */
 
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
       yylsp = yyls + yysize - 1;
 
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-                  (unsigned long int) yystacksize));
+      YY_IGNORE_USELESS_CAST_BEGIN
+      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
+                  YY_CAST (long, yystacksize)));
+      YY_IGNORE_USELESS_CAST_END
 
       if (yyss + yystacksize - 1 <= yyssp)
         YYABORT;
     }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
 
   if (yystate == YYFINAL)
     YYACCEPT;
 
   goto yybackup;
 
+
 /*-----------.
 | yybackup.  |
 `-----------*/
 yybackup:
-
   /* Do appropriate processing given the current state.  Read a
      lookahead token if we need one and don't already have one.  */
 
@@ -1521,15 +1620,14 @@ yybackup:
 
   /* Shift the lookahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
-
   yystate = yyn;
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
   YY_IGNORE_MAYBE_UNINITIALIZED_END
   *++yylsp = yylloc;
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
   goto yynewstate;
 
 
@@ -1544,7 +1642,7 @@ yydefault:
 
 
 /*-----------------------------.
-| yyreduce -- Do a reduction.  |
+| yyreduce -- do a reduction.  |
 `-----------------------------*/
 yyreduce:
   /* yyn is the number of a rule to reduce with.  */
@@ -1560,52 +1658,53 @@ yyreduce:
      GCC warning that YYVAL may be used uninitialized.  */
   yyval = yyvsp[1-yylen];
 
-  /* Default location.  */
+  /* Default location. */
   YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
+  yyerror_range[1] = yyloc;
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
-        case 2:
-#line 159 "Prose.y" /* yacc.c:1646  */
-    {
+  case 2:
+#line 159 "Prose.y"
+                                               {
                 //ExecutionState::setLifeCycleModel($4);
            }
-#line 1574 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1673 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 5:
-#line 169 "Prose.y" /* yacc.c:1646  */
-    { primArraySize = (yyvsp[0].y_int); }
-#line 1580 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 169 "Prose.y"
+                           { primArraySize = (yyvsp[0].y_int); }
+#line 1679 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 6:
-#line 170 "Prose.y" /* yacc.c:1646  */
-    { nullReturnValue = (yyvsp[0].y_bool); }
-#line 1586 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 170 "Prose.y"
+                                   { nullReturnValue = (yyvsp[0].y_bool); }
+#line 1685 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 7:
-#line 171 "Prose.y" /* yacc.c:1646  */
-    { InitFuncPtrs = (yyvsp[0].y_bool); }
-#line 1592 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 171 "Prose.y"
+                                             { InitFuncPtrs = (yyvsp[0].y_bool); }
+#line 1691 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 8:
-#line 172 "Prose.y" /* yacc.c:1646  */
-    { loopBound = (yyvsp[0].y_int); }
-#line 1598 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 172 "Prose.y"
+                             { loopBound = (yyvsp[0].y_int); }
+#line 1697 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 9:
-#line 173 "Prose.y" /* yacc.c:1646  */
-    { ModelFuncWithInlineASM = (yyvsp[0].y_bool); }
-#line 1604 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 173 "Prose.y"
+                                      { ModelFuncWithInlineASM = (yyvsp[0].y_bool); }
+#line 1703 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 10:
-#line 175 "Prose.y" /* yacc.c:1646  */
-    { 
+#line 175 "Prose.y"
+        { 
           std::string pattern((yyvsp[0].y_ident));
           /*if (pattern[0] == '*' && pattern[pattern.size()-1] == '*') 
              pattern = pattern.substr(1,pattern.size()-2);
@@ -1618,12 +1717,12 @@ yyreduce:
           std::set<std::string> excp;
           enforceOrigPatternWExceptions[pattern] = excp;
         }
-#line 1622 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1721 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 11:
-#line 189 "Prose.y" /* yacc.c:1646  */
-    { 
+#line 189 "Prose.y"
+        { 
           std::string pattern((yyvsp[-2].y_ident));
           /*if (pattern[0] == '*' && pattern[pattern.size()-1] == '*') 
              pattern = pattern.substr(1,pattern.size()-2);
@@ -1635,66 +1734,66 @@ yyreduce:
              assert(0 && "Pattern defined twice for exceptional cases of inline assembly!\n");
           enforceOrigPatternWExceptions[pattern] = *(yyvsp[0].y_exception_set);
         }
-#line 1639 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1738 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 12:
-#line 201 "Prose.y" /* yacc.c:1646  */
-    { symbolizeInlineAssembly = (yyvsp[0].y_bool); }
-#line 1645 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 201 "Prose.y"
+                                      { symbolizeInlineAssembly = (yyvsp[0].y_bool); }
+#line 1744 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 13:
-#line 202 "Prose.y" /* yacc.c:1646  */
-    { SkipSingletonHavocing = (yyvsp[0].y_bool); }
-#line 1651 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 202 "Prose.y"
+                                          { SkipSingletonHavocing = (yyvsp[0].y_bool); }
+#line 1750 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 14:
-#line 206 "Prose.y" /* yacc.c:1646  */
-    { (yyval.y_bool) = true; }
-#line 1657 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 206 "Prose.y"
+           { (yyval.y_bool) = true; }
+#line 1756 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 15:
-#line 207 "Prose.y" /* yacc.c:1646  */
-    { (yyval.y_bool) = false; }
-#line 1663 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 207 "Prose.y"
+              { (yyval.y_bool) = false; }
+#line 1762 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 16:
-#line 211 "Prose.y" /* yacc.c:1646  */
-    { std::string es { (yyvsp[0].y_ident) }; (yyval.y_exception_set) = new std::set<std::string>(); (yyval.y_exception_set)->insert(es); }
-#line 1669 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 211 "Prose.y"
+        { std::string es { (yyvsp[0].y_ident) }; (yyval.y_exception_set) = new std::set<std::string>(); (yyval.y_exception_set)->insert(es); }
+#line 1768 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 17:
-#line 213 "Prose.y" /* yacc.c:1646  */
-    { std::string es { (yyvsp[0].y_ident) }; (yyval.y_exception_set)->insert(es); }
-#line 1675 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 213 "Prose.y"
+        { std::string es { (yyvsp[0].y_ident) }; (yyval.y_exception_set)->insert(es); }
+#line 1774 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 20:
-#line 223 "Prose.y" /* yacc.c:1646  */
-    {}
-#line 1681 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 223 "Prose.y"
+                          {}
+#line 1780 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 21:
-#line 224 "Prose.y" /* yacc.c:1646  */
-    { }
-#line 1687 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 224 "Prose.y"
+                         { }
+#line 1786 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 22:
-#line 225 "Prose.y" /* yacc.c:1646  */
-    { std::string s((yyvsp[0].y_ident)); lazyInitSingles.insert(s); }
-#line 1693 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 225 "Prose.y"
+                            { std::string s((yyvsp[0].y_ident)); lazyInitSingles.insert(s); }
+#line 1792 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 23:
-#line 228 "Prose.y" /* yacc.c:1646  */
-    {
+#line 228 "Prose.y"
+                                                 {
 	std::vector<std::string> inf;
         std::string embedding((yyvsp[-3].y_ident)), embedded((yyvsp[0].y_ident));
         embedding = "%struct." + embedding;
@@ -1704,33 +1803,33 @@ yyreduce:
         inf.push_back(embedding);
         inferenceClue[embedded] = inf;
 }
-#line 1708 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1807 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 26:
-#line 244 "Prose.y" /* yacc.c:1646  */
-    { functionModeledBy[(yyvsp[-3].y_ident)] = (yyvsp[0].y_ident); }
-#line 1714 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 244 "Prose.y"
+                                   { functionModeledBy[(yyvsp[-3].y_ident)] = (yyvsp[0].y_ident); }
+#line 1813 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 27:
-#line 245 "Prose.y" /* yacc.c:1646  */
-    { APIHandler::addIgnoreHandler((yyvsp[0].y_ident)); }
-#line 1720 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 245 "Prose.y"
+                             { APIHandler::addIgnoreHandler((yyvsp[0].y_ident)); }
+#line 1819 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 28:
-#line 246 "Prose.y" /* yacc.c:1646  */
-    { 
+#line 246 "Prose.y"
+                                           { 
             std::string f((yyvsp[0].y_ident)); 
             havocArgs[f] = *(yyvsp[-2].y_number_list); 
         }
-#line 1729 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1828 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 29:
-#line 252 "Prose.y" /* yacc.c:1646  */
-    {
+#line 252 "Prose.y"
+        {
           std::vector<std::string> par;
           par.push_back((yyvsp[-6].y_ident));
           par.push_back(std::to_string((yyvsp[-4].y_int)));
@@ -1744,12 +1843,12 @@ yyreduce:
           APIAction *a = new APIAction("alloc",par,new AllocAPIHandler()); 
           APIHandler::addAction((yyvsp[-6].y_ident),a);
         }
-#line 1748 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1847 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 30:
-#line 268 "Prose.y" /* yacc.c:1646  */
-    {
+#line 268 "Prose.y"
+        {
           std::vector<std::string> par;
           par.push_back((yyvsp[-8].y_ident));
           par.push_back("-1");
@@ -1767,104 +1866,104 @@ yyreduce:
           APIHandler::addAction((yyvsp[-8].y_ident),a);
           
         }
-#line 1771 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1870 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 31:
-#line 286 "Prose.y" /* yacc.c:1646  */
-    { 
+#line 286 "Prose.y"
+                                      { 
           std::vector<std::string> par;
           par.push_back((yyvsp[-2].y_ident));
           par.push_back(std::to_string((yyvsp[0].y_int)));
           APIAction *a = new APIAction("free", par, new FreeAPIHandler());
           APIHandler::addAction((yyvsp[-2].y_ident),a);
         }
-#line 1783 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1882 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 32:
-#line 293 "Prose.y" /* yacc.c:1646  */
-    { }
-#line 1789 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 293 "Prose.y"
+                           { }
+#line 1888 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 33:
-#line 297 "Prose.y" /* yacc.c:1646  */
-    { 
+#line 297 "Prose.y"
+                { 
 		(yyval.y_number_list) = new std::set<unsigned>(); 
 		assert((yyvsp[0].y_int) >= 0 && "Negative argument no!\n"); 
 		(yyval.y_number_list)->insert((yyvsp[0].y_int)); 
 	}
-#line 1799 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1898 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 34:
-#line 302 "Prose.y" /* yacc.c:1646  */
-    { 
+#line 302 "Prose.y"
+                                 { 
 		assert((yyvsp[0].y_int) >= 0 && "Negative argument no!\n");
 		(yyvsp[-2].y_number_list)->insert((yyvsp[0].y_int)); 
 	}
-#line 1808 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1907 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 35:
-#line 308 "Prose.y" /* yacc.c:1646  */
-    {
+#line 308 "Prose.y"
+                 {
            (yyval.y_bool) = true;
          }
-#line 1816 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1915 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 36:
-#line 312 "Prose.y" /* yacc.c:1646  */
-    {
+#line 312 "Prose.y"
+                  {
            (yyval.y_bool) = false;
         }
-#line 1824 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1923 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 37:
-#line 318 "Prose.y" /* yacc.c:1646  */
-    { 
+#line 318 "Prose.y"
+                                    { 
             (yyval.y_sequential) = new Sequential();
             for(unsigned i=0; i<(yyvsp[0].y_id_list)->size(); i++)
                (yyval.y_sequential)->addStep((*(yyvsp[0].y_id_list))[i]);           
             ExecutionState::setLifeCycleModel((yyval.y_sequential)); 
         }
-#line 1835 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1934 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 38:
-#line 324 "Prose.y" /* yacc.c:1646  */
-    { std::string ep { (yyvsp[0].y_ident) }; EntryPoint = ep; }
-#line 1841 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 324 "Prose.y"
+                              { std::string ep { (yyvsp[0].y_ident) }; EntryPoint = ep; }
+#line 1940 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 39:
-#line 325 "Prose.y" /* yacc.c:1646  */
-    { std::string ep { (yyvsp[0].y_ident) }; EntryPoint = ep; }
-#line 1847 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 325 "Prose.y"
+                   { std::string ep { (yyvsp[0].y_ident) }; EntryPoint = ep; }
+#line 1946 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 40:
-#line 329 "Prose.y" /* yacc.c:1646  */
-    { 
+#line 329 "Prose.y"
+                                    { 
            (yyval.y_id_list) = new std::vector<Identifier*>(); 
            (yyval.y_id_list)->push_back((yyvsp[0].y_id));
            EntryPoint = (yyvsp[0].y_id)->getValue(); 
         }
-#line 1857 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1956 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 41:
-#line 334 "Prose.y" /* yacc.c:1646  */
-    { (yyvsp[-2].y_id_list)->push_back((yyvsp[0].y_id)); (yyval.y_id_list) = (yyvsp[-2].y_id_list); }
-#line 1863 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 334 "Prose.y"
+                                                 { (yyvsp[-2].y_id_list)->push_back((yyvsp[0].y_id)); (yyval.y_id_list) = (yyvsp[-2].y_id_list); }
+#line 1962 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 42:
-#line 338 "Prose.y" /* yacc.c:1646  */
-    {
+#line 338 "Prose.y"
+                {
           std::string fname { (yyvsp[0].y_ident) };
           (yyval.y_id) = new Identifier(fname);
           ASTNode * n = new ConstantNode(1);
@@ -1878,32 +1977,32 @@ yyreduce:
           bast->bindings[fname] = b; 
 	  (yyval.y_id)->setSuccessConstraint(bast);
 	}
-#line 1882 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1981 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 43:
-#line 352 "Prose.y" /* yacc.c:1646  */
-    {
+#line 352 "Prose.y"
+                                  {
           std::string fname { (yyvsp[-3].y_ident) };
           (yyval.y_id) = new Identifier(fname);
           (yyval.y_id)->setSuccessReturnValue((yyvsp[-1].y_int));
         }
-#line 1892 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 1991 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 44:
-#line 357 "Prose.y" /* yacc.c:1646  */
-    {
+#line 357 "Prose.y"
+                                               {
           std::string fname { (yyvsp[-3].y_ident) };
           (yyval.y_id) = new Identifier(fname);
           (yyval.y_id)->setSuccessConstraint((yyvsp[0].y_bound));
         }
-#line 1902 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2001 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 45:
-#line 365 "Prose.y" /* yacc.c:1646  */
-    {
+#line 365 "Prose.y"
+                                          {
 		auto bindings = *(yyvsp[0].y_bind_map);
 		delete (yyvsp[0].y_bind_map);
 		(yyval.y_bound) = new BoundAST { (yyvsp[-3].y_ast), bindings };
@@ -1972,174 +2071,174 @@ yyreduce:
                 //$$->ast->print();	
                 //std::cerr << "=============\n";
 	}
-#line 1976 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2075 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 46:
-#line 437 "Prose.y" /* yacc.c:1646  */
-    { (yyval.y_ast) = new ConstantNode((yyvsp[0].y_int)); }
-#line 1982 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 437 "Prose.y"
+                 { (yyval.y_ast) = new ConstantNode((yyvsp[0].y_int)); }
+#line 2081 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 47:
-#line 438 "Prose.y" /* yacc.c:1646  */
-    { (yyval.y_ast) = new ConstantNode(1); }
-#line 1988 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 438 "Prose.y"
+                  { (yyval.y_ast) = new ConstantNode(1); }
+#line 2087 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 48:
-#line 439 "Prose.y" /* yacc.c:1646  */
-    { (yyval.y_ast) = new ConstantNode(0); }
-#line 1994 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 439 "Prose.y"
+                   { (yyval.y_ast) = new ConstantNode(0); }
+#line 2093 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 49:
-#line 440 "Prose.y" /* yacc.c:1646  */
-    { 
+#line 440 "Prose.y"
+                  { 
              std::string id((yyvsp[0].y_ident)); 
              std::cerr << "identifier: " << id << "\n"; 
              (yyval.y_ast) = new IdentifierNode(id); 
         }
-#line 2004 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2103 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 50:
-#line 445 "Prose.y" /* yacc.c:1646  */
-    { 
+#line 445 "Prose.y"
+                          { 
           (yyval.y_ast) = new ASTNode(NEG); 
           (yyval.y_ast)->addChild((yyvsp[0].y_ast));
         }
-#line 2013 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2112 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 51:
-#line 449 "Prose.y" /* yacc.c:1646  */
-    { 
+#line 449 "Prose.y"
+                            { 
            (yyval.y_ast) = new ASTNode(MINUS);
            (yyval.y_ast)->addChild((yyvsp[0].y_ast));
         }
-#line 2022 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2121 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 52:
-#line 453 "Prose.y" /* yacc.c:1646  */
-    {
+#line 453 "Prose.y"
+                                      {
           (yyval.y_ast) = new ASTNode(PLUS);
           (yyval.y_ast)->addChild((yyvsp[-2].y_ast));
           (yyval.y_ast)->addChild((yyvsp[0].y_ast));
 	}
-#line 2032 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2131 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 53:
-#line 458 "Prose.y" /* yacc.c:1646  */
-    {
+#line 458 "Prose.y"
+                                       {
           (yyval.y_ast) = new ASTNode(MINUS);
           (yyval.y_ast)->addChild((yyvsp[-2].y_ast));
           (yyval.y_ast)->addChild((yyvsp[0].y_ast)); 
 	}
-#line 2042 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2141 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 54:
-#line 463 "Prose.y" /* yacc.c:1646  */
-    {
+#line 463 "Prose.y"
+                                       {
           (yyval.y_ast) = new ASTNode(TIMES);
           (yyval.y_ast)->addChild((yyvsp[-2].y_ast));
           (yyval.y_ast)->addChild((yyvsp[0].y_ast));
 	}
-#line 2052 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2151 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 55:
-#line 468 "Prose.y" /* yacc.c:1646  */
-    {
+#line 468 "Prose.y"
+                                    {
           (yyval.y_ast) = new ASTNode(LT);
           (yyval.y_ast)->addChild((yyvsp[-2].y_ast));
           (yyval.y_ast)->addChild((yyvsp[0].y_ast));
 	}
-#line 2062 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2161 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 56:
-#line 473 "Prose.y" /* yacc.c:1646  */
-    {
+#line 473 "Prose.y"
+                                     {
           (yyval.y_ast) = new ASTNode(LTE);
           (yyval.y_ast)->addChild((yyvsp[-2].y_ast));
           (yyval.y_ast)->addChild((yyvsp[0].y_ast));
 	}
-#line 2072 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2171 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 57:
-#line 478 "Prose.y" /* yacc.c:1646  */
-    {
+#line 478 "Prose.y"
+                                    {
           (yyval.y_ast) = new ASTNode(GT);
           (yyval.y_ast)->addChild((yyvsp[-2].y_ast));
           (yyval.y_ast)->addChild((yyvsp[0].y_ast));
           std::cerr << "> exp\n";
 	}
-#line 2083 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2182 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 58:
-#line 484 "Prose.y" /* yacc.c:1646  */
-    {
+#line 484 "Prose.y"
+                                     {
           (yyval.y_ast) = new ASTNode(GTE);
           (yyval.y_ast)->addChild((yyvsp[-2].y_ast));
           (yyval.y_ast)->addChild((yyvsp[0].y_ast));
 	}
-#line 2093 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2192 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 59:
-#line 489 "Prose.y" /* yacc.c:1646  */
-    {
+#line 489 "Prose.y"
+                                    {
           (yyval.y_ast) = new ASTNode(EQ);
           (yyval.y_ast)->addChild((yyvsp[-2].y_ast));
           (yyval.y_ast)->addChild((yyvsp[0].y_ast));
 	}
-#line 2103 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2202 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 60:
-#line 494 "Prose.y" /* yacc.c:1646  */
-    {
+#line 494 "Prose.y"
+                                     {
           (yyval.y_ast) = new ASTNode(NEQ);
           (yyval.y_ast)->addChild((yyvsp[-2].y_ast));
           (yyval.y_ast)->addChild((yyvsp[0].y_ast));
 	}
-#line 2113 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2212 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 61:
-#line 499 "Prose.y" /* yacc.c:1646  */
-    { (yyval.y_ast) = (yyvsp[-1].y_ast); }
-#line 2119 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 499 "Prose.y"
+                             { (yyval.y_ast) = (yyvsp[-1].y_ast); }
+#line 2218 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 62:
-#line 505 "Prose.y" /* yacc.c:1646  */
-    {
+#line 505 "Prose.y"
+                {
 		(yyval.y_bind_map) = new std::map<std::string, Binding> { *(yyvsp[0].y_bind_pair) };
 		delete (yyvsp[0].y_bind_pair);
 	}
-#line 2128 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2227 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 63:
-#line 509 "Prose.y" /* yacc.c:1646  */
-    {
+#line 509 "Prose.y"
+                               {
 		(yyval.y_bind_map) = (yyvsp[-2].y_bind_map);
 		(yyval.y_bind_map)->insert(*(yyvsp[0].y_bind_pair));
 		delete (yyvsp[0].y_bind_pair);
 	}
-#line 2138 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2237 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 64:
-#line 516 "Prose.y" /* yacc.c:1646  */
-    {
+#line 516 "Prose.y"
+                          {
                 if ((yyvsp[0].y_bind)->type == "type" && (yyvsp[0].y_bind)->comptype == "funcname") {
                     std::string f((yyvsp[-2].y_ident));
                     (yyvsp[0].y_bind)->entity = f;
@@ -2148,63 +2247,64 @@ yyreduce:
 		(yyval.y_bind_pair) = new std::pair<std::string, Binding> { (yyvsp[-2].y_ident), *(yyvsp[0].y_bind) };
 		delete (yyvsp[0].y_bind);
 	}
-#line 2152 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2251 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 65:
-#line 528 "Prose.y" /* yacc.c:1646  */
-    {
+#line 528 "Prose.y"
+                              {
 		// fieldConstraintMap
 		(yyval.y_bind) = new Binding { "type", "none", (yyvsp[-2].y_ident), (unsigned int)(yyvsp[0].y_int) };
 	}
-#line 2161 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2260 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 66:
-#line 532 "Prose.y" /* yacc.c:1646  */
-    {
+#line 532 "Prose.y"
+                                        {
 		// funcArgConstraintMap
 		// entity: either a type or function name
 		(yyval.y_bind) = new Binding { "type", "sizeof", (yyvsp[-2].y_ident), (unsigned int)(yyvsp[0].y_int) };
 	}
-#line 2171 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2270 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 67:
-#line 537 "Prose.y" /* yacc.c:1646  */
-    {
+#line 537 "Prose.y"
+                   {
                (yyval.y_bind) = new Binding { "type", "funcname", "", (unsigned int)0 };
         }
-#line 2179 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2278 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 68:
-#line 540 "Prose.y" /* yacc.c:1646  */
-    {
+#line 540 "Prose.y"
+                              {
 		(yyval.y_bind) = new Binding { "func", "none", (yyvsp[-2].y_ident), (unsigned int)(yyvsp[0].y_int) };
 	}
-#line 2187 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2286 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 69:
-#line 543 "Prose.y" /* yacc.c:1646  */
-    {
+#line 543 "Prose.y"
+                            {
                 std::string s((yyvsp[0].y_ident));
 		(yyval.y_bind) = new Binding { "func", "return", s, 0 };
 	}
-#line 2196 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2295 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
   case 70:
-#line 547 "Prose.y" /* yacc.c:1646  */
-    {
+#line 547 "Prose.y"
+                                      {
       		(yyval.y_bind) = new Binding { "func", "argsize", (yyvsp[-2].y_ident), (unsigned int)(yyvsp[0].y_int) };
         }
-#line 2204 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2303 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
     break;
 
 
-#line 2208 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.cpp" /* yacc.c:1646  */
+#line 2307 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.cpp"
+
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
@@ -2230,14 +2330,13 @@ yyreduce:
   /* Now 'shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
+  {
+    const int yylhs = yyr1[yyn] - YYNTOKENS;
+    const int yyi = yypgoto[yylhs] + *yyssp;
+    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
+               ? yytable[yyi]
+               : yydefgoto[yylhs]);
+  }
 
   goto yynewstate;
 
@@ -2269,7 +2368,7 @@ yyerrlab:
           {
             if (yymsg != yymsgbuf)
               YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
             if (!yymsg)
               {
                 yymsg = yymsgbuf;
@@ -2320,14 +2419,11 @@ yyerrlab:
 | yyerrorlab -- error raised explicitly by YYERROR.  |
 `---------------------------------------------------*/
 yyerrorlab:
+  /* Pacify compilers when the user code never invokes YYERROR and the
+     label yyerrorlab therefore never appears in user code.  */
+  if (0)
+    YYERROR;
 
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (/*CONSTCOND*/ 0)
-     goto yyerrorlab;
-
-  yyerror_range[1] = yylsp[1-yylen];
   /* Do not reclaim the symbols of the rule whose action triggered
      this YYERROR.  */
   YYPOPSTACK (yylen);
@@ -2393,6 +2489,7 @@ yyacceptlab:
   yyresult = 0;
   goto yyreturn;
 
+
 /*-----------------------------------.
 | yyabortlab -- YYABORT comes here.  |
 `-----------------------------------*/
@@ -2400,6 +2497,7 @@ yyabortlab:
   yyresult = 1;
   goto yyreturn;
 
+
 #if !defined yyoverflow || YYERROR_VERBOSE
 /*-------------------------------------------------.
 | yyexhaustedlab -- memory exhaustion comes here.  |
@@ -2410,6 +2508,10 @@ yyexhaustedlab:
   /* Fall through.  */
 #endif
 
+
+/*-----------------------------------------------------.
+| yyreturn -- parsing is finished, return the result.  |
+`-----------------------------------------------------*/
 yyreturn:
   if (yychar != YYEMPTY)
     {
@@ -2426,7 +2528,7 @@ yyreturn:
   while (yyssp != yyss)
     {
       yydestruct ("Cleanup: popping",
-                  yystos[*yyssp], yyvsp, yylsp);
+                  yystos[+*yyssp], yyvsp, yylsp);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
@@ -2439,5 +2541,5 @@ yyreturn:
 #endif
   return yyresult;
 }
-#line 551 "Prose.y" /* yacc.c:1906  */
+#line 551 "Prose.y"
 
diff --git a/lib/Prose/parser.h b/lib/Prose/parser.h
index 3a1f717..6d9ae4e 100644
--- a/lib/Prose/parser.h
+++ b/lib/Prose/parser.h
@@ -1,8 +1,9 @@
-/* A Bison parser, made by GNU Bison 3.0.4.  */
+/* A Bison parser, made by GNU Bison 3.5.1.  */
 
 /* Bison interface for Yacc-like parsers in C
 
-   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
+   Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -30,8 +31,11 @@
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
-#ifndef YY_YY_HOME_TUBA_DOCUMENTS_RELEASES_PROMPT_LIB_PROSE_PARSER_H_INCLUDED
-# define YY_YY_HOME_TUBA_DOCUMENTS_RELEASES_PROMPT_LIB_PROSE_PARSER_H_INCLUDED
+/* Undocumented macros, especially those whose name start with YY_,
+   are private implementation details.  Do not rely on them.  */
+
+#ifndef YY_YY_HOME_MUQI_PROMPT_EXTERNAL_FUNCTION_PROMPT_LIB_PROSE_PARSER_H_INCLUDED
+# define YY_YY_HOME_MUQI_PROMPT_EXTERNAL_FUNCTION_PROMPT_LIB_PROSE_PARSER_H_INCLUDED
 /* Debug traces.  */
 #ifndef YYDEBUG
 # define YYDEBUG 0
@@ -120,10 +124,9 @@ extern int yydebug;
 
 /* Value type.  */
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-
 union YYSTYPE
 {
-#line 124 "Prose.y" /* yacc.c:1909  */
+#line 124 "Prose.y"
 
 	bool y_bool;
 	int y_int;
@@ -140,9 +143,9 @@ union YYSTYPE
 	char *y_ident;
         Op op;
 
-#line 144 "/home/tuba/Documents/releases/PROMPT/lib/Prose/parser.h" /* yacc.c:1909  */
-};
+#line 147 "/home/muqi/PROMPT_external_function/PROMPT/lib/Prose/parser.h"
 
+};
 typedef union YYSTYPE YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
 # define YYSTYPE_IS_DECLARED 1
@@ -167,4 +170,4 @@ extern YYSTYPE yylval;
 extern YYLTYPE yylloc;
 int yyparse (void);
 
-#endif /* !YY_YY_HOME_TUBA_DOCUMENTS_RELEASES_PROMPT_LIB_PROSE_PARSER_H_INCLUDED  */
+#endif /* !YY_YY_HOME_MUQI_PROMPT_EXTERNAL_FUNCTION_PROMPT_LIB_PROSE_PARSER_H_INCLUDED  */
diff --git a/lib/Solver/Z3Builder.cpp b/lib/Solver/Z3Builder.cpp
index d03c4c8..79196cb 100755
--- a/lib/Solver/Z3Builder.cpp
+++ b/lib/Solver/Z3Builder.cpp
@@ -21,6 +21,11 @@
 
 using namespace klee;
 
+//muqi
+using namespace llvm::sys;
+#include "klee/Expr.h"
+
+
 namespace {
 llvm::cl::opt<bool> UseConstructHashZ3(
     "use-construct-hash-z3",
@@ -33,14 +38,44 @@ bool Z3InterationLogOpen = false;
 
 namespace klee {
 
+//muqi
+#define Muqi_DEBUG;
+
 // Declared here rather than `Z3Builder.h` so they can be called in gdb.
 template <> void Z3NodeHandle<Z3_sort>::dump() {
+  #if defined(Muqi_DEBUG)
+
   llvm::errs() << "Z3SortHandle:\n" << ::Z3_sort_to_string(context, node)
                << "\n";
+  
+  std::string Path = klee_muqi_compare_file_path;
+  std::error_code EC;
+  fs::OpenFlags Flags = (fs::OpenFlags)2;
+  llvm::raw_fd_ostream *example_ostream = new llvm::raw_fd_ostream(Path, EC, Flags);
+  if(EC)
+    llvm::errs() << "Error opening " << Path << "\n";
+  (*example_ostream)  << "\n----dump z3 start----\n" ;  
+  (*example_ostream)  << "Z3SortHandle:\n" << ::Z3_sort_to_string(context, node);
+  (*example_ostream)  << "\n----dump z3 end----\n" ;
+  delete example_ostream;
+  #endif
 }
 template <> void Z3NodeHandle<Z3_ast>::dump() {
+  #if defined(Muqi_DEBUG)
   llvm::errs() << "Z3ASTHandle:\n" << ::Z3_ast_to_string(context, as_ast())
                << "\n";
+
+  std::string Path = klee_muqi_compare_file_path;
+  std::error_code EC;
+  fs::OpenFlags Flags = (fs::OpenFlags)2;
+  llvm::raw_fd_ostream *example_ostream = new llvm::raw_fd_ostream(Path, EC, Flags);
+  if(EC)
+    llvm::errs() << "Error opening " << Path << "\n";
+  (*example_ostream)  << "\n----dump z3 start----\n" ;
+  (*example_ostream)  << "Z3ASTHandle:\n" << ::Z3_ast_to_string(context, as_ast()); 
+  (*example_ostream)  << "\n----dump z3 end----\n" ;
+  delete example_ostream;
+  #endif
 }
 
 void custom_z3_error_handler(Z3_context ctx, Z3_error_code ec) {
@@ -50,7 +85,10 @@ void custom_z3_error_handler(Z3_context ctx, Z3_error_code ec) {
       Z3_get_error_msg(ctx, ec);
 #else
       // Z3 4.4.1
-      Z3_get_error_msg(ec);
+      //muqi
+      //my z3 version is Z3 version 4.8.9 - 64 bit and it looks like klee cannot identify the latest version
+      //change Z3_get_error_msg(ec); --> Z3_get_error_msg(ctx,ec);
+      Z3_get_error_msg(ctx,ec);
 #endif
   // FIXME: This is kind of a hack. The value comes from the enum
   // Z3_CANCELED_MSG but this isn't currently exposed by Z3's C API
@@ -92,7 +130,8 @@ Z3Builder::Z3Builder(bool autoClearConstructCache, const char* z3LogInteractionF
   // Make sure we handle any errors reported by Z3.
   Z3_set_error_handler(ctx, custom_z3_error_handler);
   // When emitting Z3 expressions make them SMT-LIBv2 compliant
-  Z3_set_ast_print_mode(ctx, Z3_PRINT_SMTLIB2_COMPLIANT);
+  //Z3_set_ast_print_mode(ctx, Z3_PRINT_SMTLIB2_COMPLIANT);
+  Z3_set_ast_print_mode(ctx, Z3_PRINT_SMTLIB_FULL);
   Z3_del_config(cfg);
 }
 
@@ -396,7 +435,10 @@ Z3ASTHandle Z3Builder::getInitialArray(const Array *root) {
     unsigned const space = (root->name.length() > 32 - uid_length)
                                ? (32 - uid_length)
                                : root->name.length();
-    std::string unique_name = root->name.substr(0, space) + unique_id;
+
+    //muqi! no more unique_id for array, they should be the same as input in our cases
+    //std::string unique_name = root->name.substr(0, space) + unique_id;
+    std::string unique_name = root->name.substr(0, space) ;
 
     array_expr = buildArray(unique_name.c_str(), root->getDomain(),
                             root->getRange());
@@ -454,8 +496,10 @@ Z3ASTHandle Z3Builder::construct(ref<Expr> e, int *width_out) {
   // TODO: We could potentially use Z3_simplify() here
   // to store simpler expressions.
   if (!UseConstructHashZ3 || isa<ConstantExpr>(e)) {
+    llvm::errs()<<"Inside isa constantexpr Z3Builder::construct\n";
     return constructActual(e, width_out);
   } else {
+    llvm::errs()<<"Inside not isa constantexpr \n";
     ExprHashMap<std::pair<Z3ASTHandle, unsigned> >::iterator it =
         constructed.find(e);
     if (it != constructed.end()) {
@@ -473,13 +517,42 @@ Z3ASTHandle Z3Builder::construct(ref<Expr> e, int *width_out) {
   }
 }
 
+/** if *width_out!=1 then result is a bitvector,
+    otherwise it is a bool */
+Z3ASTHandle Z3Builder::construct_muqi_solver(ref<Expr> e, int *width_out) {
+  // TODO: We could potentially use Z3_simplify() here
+  // to store simpler expressions.
+  if (!UseConstructHashZ3 || isa<ConstantExpr>(e)) {
+    llvm::errs()<<"Inside isa constantexpr Z3Builder::construct_muqi_solver\n";
+    return constructActual_muqi(e, width_out);
+  } else {
+    llvm::errs()<<"Inside not isa constantexpr,Z3Builder::construct_muqi_solver \n";
+    ExprHashMap<std::pair<Z3ASTHandle, unsigned> >::iterator it =
+        constructed.find(e);
+    if (it != constructed.end()) {
+      if (width_out)
+        *width_out = it->second.second;
+      return it->second.first;
+    } else {
+      int width;
+      if (!width_out)
+        width_out = &width;
+      Z3ASTHandle res = constructActual_muqi(e, width_out);
+      constructed.insert(std::make_pair(e, std::make_pair(res, *width_out)));
+      return res;
+    }
+  }
+}
+
 /** if *width_out!=1 then result is a bitvector,
     otherwise it is a bool */
 Z3ASTHandle Z3Builder::constructActual(ref<Expr> e, int *width_out) {
   int width;
+  //llvm::errs()<<"Inside constructActual, *width_out is:" << *width_out<<"\n";
   if (!width_out)
     width_out = &width;
-
+  //llvm::errs()<<"Inside constructActual, *width_out is:" << *width_out<<"\n";
+  llvm::errs()<<"e->getKind() is: "<<e->getKind()<<"\n";
   ++stats::queryConstructs;
 
   switch (e->getKind()) {
@@ -857,5 +930,400 @@ Z3ASTHandle Z3Builder::constructActual(ref<Expr> e, int *width_out) {
     return getTrue();
   }
 }
+
+
+
+/** if *width_out!=1 then result is a bitvector,
+    otherwise it is a bool */
+Z3ASTHandle Z3Builder::constructActual_muqi(ref<Expr> e, int *width_out) {
+  int width;
+  //llvm::errs()<<"Inside constructActual_muqi, *width_out is:" << *width_out<<"\n";
+  if (!width_out)
+    width_out = &width;
+  llvm::errs()<<"Inside constructActual_muqi, *width_out is:" << *width_out<<"\n";
+  llvm::errs()<<"e->getKind() is: "<<e->getKind()<<"\n";
+  ++stats::queryConstructs;
+
+  switch (e->getKind()) {
+  case Expr::Constant: {
+    ConstantExpr *CE = cast<ConstantExpr>(e);
+    *width_out = CE->getWidth();
+    llvm::errs()<<"Inside constructActual_muqi constant condition, *width_out is:" << *width_out<<"\n";
+    // Coerce to bool if necessary.
+    
+    if (*width_out == 1)
+      return CE->isTrue() ? getTrue() : getFalse();
+
+    // Fast path.
+    if (*width_out <= 32)
+      return bvConst32(*width_out, CE->getZExtValue(32));
+    
+    if (*width_out <= 64)
+      return bvConst64(*width_out, CE->getZExtValue());
+
+    ref<ConstantExpr> Tmp = CE;
+    Z3ASTHandle Res = bvConst64(64, Tmp->Extract(0, 64)->getZExtValue());
+    while (Tmp->getWidth() > 64) {
+      Tmp = Tmp->Extract(64, Tmp->getWidth() - 64);
+      unsigned Width = std::min(64U, Tmp->getWidth());
+      Res = Z3ASTHandle(
+          Z3_mk_concat(ctx,
+                       bvConst64(Width, Tmp->Extract(0, Width)->getZExtValue()),
+                       Res),
+          ctx);
+    }
+    return Res;
+  }
+
+  // Special
+  case Expr::NotOptimized: {
+    NotOptimizedExpr *noe = cast<NotOptimizedExpr>(e);
+    return construct_muqi_solver(noe->src, width_out);
+  }
+
+  case Expr::Read: {
+    ReadExpr *re = cast<ReadExpr>(e);
+    assert(re && re->updates.root);
+    *width_out = re->updates.root->getRange();
+    //*width_out = 64;
+    llvm::errs()<<"Inside constructActual_muqi Read condition, *width_out is:" << *width_out<<"\n";
+    //do some concat 0 extend to 64 bits here
+    return readExpr(getArrayForUpdate(re->updates.root, re->updates.head),
+                    construct_muqi_solver(re->index, 0));
+  }
+
+  case Expr::Select: {
+    SelectExpr *se = cast<SelectExpr>(e);
+    Z3ASTHandle cond = construct_muqi_solver(se->cond, 0);
+    Z3ASTHandle tExpr = construct_muqi_solver(se->trueExpr, width_out);
+    Z3ASTHandle fExpr = construct_muqi_solver(se->falseExpr, width_out);
+    return iteExpr(cond, tExpr, fExpr);
+  }
+
+  case Expr::Concat: {
+    ConcatExpr *ce = cast<ConcatExpr>(e);
+    unsigned numKids = ce->getNumKids();
+    Z3ASTHandle res = construct_muqi_solver(ce->getKid(numKids - 1), 0);
+    for (int i = numKids - 2; i >= 0; i--) {
+      res =
+          Z3ASTHandle(Z3_mk_concat(ctx, construct_muqi_solver(ce->getKid(i), 0), res), ctx);
+    }
+    *width_out = ce->getWidth();
+    return res;
+  }
+
+  case Expr::Extract: {
+    ExtractExpr *ee = cast<ExtractExpr>(e);
+    Z3ASTHandle src = construct_muqi_solver(ee->expr, width_out);
+    *width_out = ee->getWidth();
+    if (*width_out == 1) {
+      return bvBoolExtract(src, ee->offset);
+    } else {
+      return bvExtract(src, ee->offset + *width_out - 1, ee->offset);
+    }
+  }
+
+  // Casting
+
+  case Expr::ZExt: {
+    int srcWidth;
+    CastExpr *ce = cast<CastExpr>(e);
+    Z3ASTHandle src = construct_muqi_solver(ce->src, &srcWidth);
+    *width_out = ce->getWidth();
+    if (srcWidth == 1) {
+      return iteExpr(src, bvOne(*width_out), bvZero(*width_out));
+    } else {
+      assert(*width_out > srcWidth && "Invalid width_out");
+      return Z3ASTHandle(Z3_mk_concat(ctx, bvZero(*width_out - srcWidth), src),
+                         ctx);
+    }
+  }
+
+  case Expr::SExt: {
+    int srcWidth;
+    CastExpr *ce = cast<CastExpr>(e);
+    Z3ASTHandle src = construct_muqi_solver(ce->src, &srcWidth);
+    *width_out = ce->getWidth();
+    if (srcWidth == 1) {
+      return iteExpr(src, bvMinusOne(*width_out), bvZero(*width_out));
+    } else {
+      return bvSignExtend(src, *width_out);
+    }
+  }
+
+  // Arithmetic
+  case Expr::Add: {
+    AddExpr *ae = cast<AddExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(ae->left, width_out);
+    Z3ASTHandle right = construct_muqi_solver(ae->right, width_out);
+    assert(*width_out != 1 && "uncanonicalized add");
+    Z3ASTHandle result = Z3ASTHandle(Z3_mk_bvadd(ctx, left, right), ctx);
+    assert(getBVLength(result) == static_cast<unsigned>(*width_out) &&
+           "width mismatch");
+    return result;
+  }
+
+  case Expr::Sub: {
+    SubExpr *se = cast<SubExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(se->left, width_out);
+    Z3ASTHandle right = construct_muqi_solver(se->right, width_out);
+    assert(*width_out != 1 && "uncanonicalized sub");
+    Z3ASTHandle result = Z3ASTHandle(Z3_mk_bvsub(ctx, left, right), ctx);
+    assert(getBVLength(result) == static_cast<unsigned>(*width_out) &&
+           "width mismatch");
+    return result;
+  }
+
+  case Expr::Mul: {
+    MulExpr *me = cast<MulExpr>(e);
+    Z3ASTHandle right = construct_muqi_solver(me->right, width_out);
+    assert(*width_out != 1 && "uncanonicalized mul");
+    Z3ASTHandle left = construct_muqi_solver(me->left, width_out);
+    Z3ASTHandle result = Z3ASTHandle(Z3_mk_bvmul(ctx, left, right), ctx);
+    assert(getBVLength(result) == static_cast<unsigned>(*width_out) &&
+           "width mismatch");
+    return result;
+  }
+
+  case Expr::UDiv: {
+    UDivExpr *de = cast<UDivExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(de->left, width_out);
+    assert(*width_out != 1 && "uncanonicalized udiv");
+
+    if (ConstantExpr *CE = dyn_cast<ConstantExpr>(de->right)) {
+      if (CE->getWidth() <= 64) {
+        uint64_t divisor = CE->getZExtValue();
+        if (bits64::isPowerOfTwo(divisor))
+          return bvRightShift(left, bits64::indexOfSingleBit(divisor));
+      }
+    }
+
+    Z3ASTHandle right = construct_muqi_solver(de->right, width_out);
+    Z3ASTHandle result = Z3ASTHandle(Z3_mk_bvudiv(ctx, left, right), ctx);
+    assert(getBVLength(result) == static_cast<unsigned>(*width_out) &&
+           "width mismatch");
+    return result;
+  }
+
+  case Expr::SDiv: {
+    SDivExpr *de = cast<SDivExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(de->left, width_out);
+    assert(*width_out != 1 && "uncanonicalized sdiv");
+    Z3ASTHandle right = construct_muqi_solver(de->right, width_out);
+    Z3ASTHandle result = Z3ASTHandle(Z3_mk_bvsdiv(ctx, left, right), ctx);
+    assert(getBVLength(result) == static_cast<unsigned>(*width_out) &&
+           "width mismatch");
+    return result;
+  }
+
+  case Expr::URem: {
+    URemExpr *de = cast<URemExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(de->left, width_out);
+    assert(*width_out != 1 && "uncanonicalized urem");
+
+    if (ConstantExpr *CE = dyn_cast<ConstantExpr>(de->right)) {
+      if (CE->getWidth() <= 64) {
+        uint64_t divisor = CE->getZExtValue();
+
+        if (bits64::isPowerOfTwo(divisor)) {
+          // FIXME: This should be unsigned but currently needs to be signed to
+          // avoid signed-unsigned comparison in assert.
+          int bits = bits64::indexOfSingleBit(divisor);
+
+          // special case for modding by 1 or else we bvExtract -1:0
+          if (bits == 0) {
+            return bvZero(*width_out);
+          } else {
+            assert(*width_out > bits && "invalid width_out");
+            return Z3ASTHandle(Z3_mk_concat(ctx, bvZero(*width_out - bits),
+                                            bvExtract(left, bits - 1, 0)),
+                               ctx);
+          }
+        }
+      }
+    }
+
+    Z3ASTHandle right = construct_muqi_solver(de->right, width_out);
+    Z3ASTHandle result = Z3ASTHandle(Z3_mk_bvurem(ctx, left, right), ctx);
+    assert(getBVLength(result) == static_cast<unsigned>(*width_out) &&
+           "width mismatch");
+    return result;
+  }
+
+  case Expr::SRem: {
+    SRemExpr *de = cast<SRemExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(de->left, width_out);
+    Z3ASTHandle right = construct_muqi_solver(de->right, width_out);
+    assert(*width_out != 1 && "uncanonicalized srem");
+    // LLVM's srem instruction says that the sign follows the dividend
+    // (``left``).
+    // Z3's C API says ``Z3_mk_bvsrem()`` does this so these seem to match.
+    Z3ASTHandle result = Z3ASTHandle(Z3_mk_bvsrem(ctx, left, right), ctx);
+    assert(getBVLength(result) == static_cast<unsigned>(*width_out) &&
+           "width mismatch");
+    return result;
+  }
+
+  // Bitwise
+  case Expr::Not: {
+    NotExpr *ne = cast<NotExpr>(e);
+    Z3ASTHandle expr = construct_muqi_solver(ne->expr, width_out);
+    if (*width_out == 1) {
+      return notExpr(expr);
+    } else {
+      return bvNotExpr(expr);
+    }
+  }
+
+  case Expr::And: {
+    AndExpr *ae = cast<AndExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(ae->left, width_out);
+    Z3ASTHandle right = construct_muqi_solver(ae->right, width_out);
+    if (*width_out == 1) {
+      return andExpr(left, right);
+    } else {
+      return bvAndExpr(left, right);
+    }
+  }
+
+  case Expr::Or: {
+    OrExpr *oe = cast<OrExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(oe->left, width_out);
+    Z3ASTHandle right = construct_muqi_solver(oe->right, width_out);
+    if (*width_out == 1) {
+      return orExpr(left, right);
+    } else {
+      return bvOrExpr(left, right);
+    }
+  }
+
+  case Expr::Xor: {
+    XorExpr *xe = cast<XorExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(xe->left, width_out);
+    Z3ASTHandle right = construct_muqi_solver(xe->right, width_out);
+
+    if (*width_out == 1) {
+      // XXX check for most efficient?
+      return iteExpr(left, Z3ASTHandle(notExpr(right)), right);
+    } else {
+      return bvXorExpr(left, right);
+    }
+  }
+
+  case Expr::Shl: {
+    ShlExpr *se = cast<ShlExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(se->left, width_out);
+    assert(*width_out != 1 && "uncanonicalized shl");
+
+    if (ConstantExpr *CE = dyn_cast<ConstantExpr>(se->right)) {
+      return bvLeftShift(left, (unsigned)CE->getLimitedValue());
+    } else {
+      int shiftWidth;
+      Z3ASTHandle amount = construct_muqi_solver(se->right, &shiftWidth);
+      return bvVarLeftShift(left, amount);
+    }
+  }
+
+  case Expr::LShr: {
+    LShrExpr *lse = cast<LShrExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(lse->left, width_out);
+    assert(*width_out != 1 && "uncanonicalized lshr");
+
+    if (ConstantExpr *CE = dyn_cast<ConstantExpr>(lse->right)) {
+      return bvRightShift(left, (unsigned)CE->getLimitedValue());
+    } else {
+      int shiftWidth;
+      Z3ASTHandle amount = construct_muqi_solver(lse->right, &shiftWidth);
+      return bvVarRightShift(left, amount);
+    }
+  }
+
+  case Expr::AShr: {
+    AShrExpr *ase = cast<AShrExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(ase->left, width_out);
+    assert(*width_out != 1 && "uncanonicalized ashr");
+
+    if (ConstantExpr *CE = dyn_cast<ConstantExpr>(ase->right)) {
+      unsigned shift = (unsigned)CE->getLimitedValue();
+      Z3ASTHandle signedBool = bvBoolExtract(left, *width_out - 1);
+      return constructAShrByConstant(left, shift, signedBool);
+    } else {
+      int shiftWidth;
+      Z3ASTHandle amount = construct_muqi_solver(ase->right, &shiftWidth);
+      return bvVarArithRightShift(left, amount);
+    }
+  }
+
+  // Comparison
+
+  case Expr::Eq: {
+    EqExpr *ee = cast<EqExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(ee->left, width_out);
+    Z3ASTHandle right = construct_muqi_solver(ee->right, width_out);
+    if (*width_out == 1) {
+      if (ConstantExpr *CE = dyn_cast<ConstantExpr>(ee->left)) {
+        if (CE->isTrue())
+          return right;
+        return notExpr(right);
+      } else {
+        return iffExpr(left, right);
+      }
+    } else {
+      *width_out = 1;
+      return eqExpr(left, right);
+    }
+  }
+
+  case Expr::Ult: {
+    UltExpr *ue = cast<UltExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(ue->left, width_out);
+    Z3ASTHandle right = construct_muqi_solver(ue->right, width_out);
+    assert(*width_out != 1 && "uncanonicalized ult");
+    *width_out = 1;
+    return bvLtExpr(left, right);
+  }
+
+  case Expr::Ule: {
+    UleExpr *ue = cast<UleExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(ue->left, width_out);
+    Z3ASTHandle right = construct_muqi_solver(ue->right, width_out);
+    assert(*width_out != 1 && "uncanonicalized ule");
+    *width_out = 1;
+    return bvLeExpr(left, right);
+  }
+
+  case Expr::Slt: {
+    SltExpr *se = cast<SltExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(se->left, width_out);
+    Z3ASTHandle right = construct_muqi_solver(se->right, width_out);
+    assert(*width_out != 1 && "uncanonicalized slt");
+    *width_out = 1;
+    return sbvLtExpr(left, right);
+  }
+
+  case Expr::Sle: {
+    SleExpr *se = cast<SleExpr>(e);
+    Z3ASTHandle left = construct_muqi_solver(se->left, width_out);
+    Z3ASTHandle right = construct_muqi_solver(se->right, width_out);
+    assert(*width_out != 1 && "uncanonicalized sle");
+    *width_out = 1;
+    return sbvLeExpr(left, right);
+  }
+
+// unused due to canonicalization
+#if 0
+  case Expr::Ne:
+  case Expr::Ugt:
+  case Expr::Uge:
+  case Expr::Sgt:
+  case Expr::Sge:
+#endif
+
+  default:
+    assert(0 && "unhandled Expr type");
+    return getTrue();
+  }
+}
+
 }
 #endif // ENABLE_Z3
diff --git a/lib/Solver/Z3Builder.h b/lib/Solver/Z3Builder.h
index 7cdb2b5..5af56e0 100755
--- a/lib/Solver/Z3Builder.h
+++ b/lib/Solver/Z3Builder.h
@@ -158,7 +158,9 @@ private:
   Z3ASTHandle getArrayForUpdate(const Array *root, const UpdateNode *un);
 
   Z3ASTHandle constructActual(ref<Expr> e, int *width_out);
+  Z3ASTHandle constructActual_muqi(ref<Expr> e, int *width_out);
   Z3ASTHandle construct(ref<Expr> e, int *width_out);
+  Z3ASTHandle construct_muqi_solver(ref<Expr> e, int *width_out);
 
   Z3ASTHandle buildArray(const char *name, unsigned indexWidth,
                          unsigned valueWidth);
diff --git a/lib/Solver/Z3Solver.cpp b/lib/Solver/Z3Solver.cpp
index e89c946..77b6bc7 100755
--- a/lib/Solver/Z3Solver.cpp
+++ b/lib/Solver/Z3Solver.cpp
@@ -354,7 +354,7 @@ SolverImpl::SolverRunStatus Z3SolverImpl::handleSolverResponse(
 
         bool successfulEval =
             Z3_model_eval(builder->ctx, theModel, initial_read,
-                          /*model_completion=*/Z3_TRUE, &arrayElementExpr);
+                          /*model_completion=*/Z3_L_TRUE, &arrayElementExpr);
         assert(successfulEval && "Failed to evaluate model");
         Z3_inc_ref(builder->ctx, arrayElementExpr);
         assert(Z3_get_ast_kind(builder->ctx, arrayElementExpr) ==
@@ -419,7 +419,7 @@ bool Z3SolverImpl::validateZ3Model(::Z3_solver &theSolver, ::Z3_model &theModel)
     ::Z3_ast rawEvaluatedExpr;
     bool successfulEval =
         Z3_model_eval(builder->ctx, theModel, constraint,
-                      /*model_completion=*/Z3_TRUE, &rawEvaluatedExpr);
+                      /*model_completion=*/Z3_L_TRUE, &rawEvaluatedExpr);
     assert(successfulEval && "Failed to evaluate model");
 
     // Use handle to do ref-counting.
diff --git a/lib/Support/ErrorHandling.cpp b/lib/Support/ErrorHandling.cpp
index 0064770..a87f7f6 100755
--- a/lib/Support/ErrorHandling.cpp
+++ b/lib/Support/ErrorHandling.cpp
@@ -12,6 +12,21 @@
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Support/CommandLine.h"
 
+//muqi
+#include "llvm/IR/Instruction.h"
+#include "llvm/IR/Function.h"
+
+#include "klee/Internal/ADT/RNG.h"
+#include "klee/Config/Version.h"
+#include "klee/Interpreter.h"
+
+#include "klee/util/Assignment.h"
+#include "klee/Expr.h"
+#include "klee/util/ExprPPrinter.h"
+#include "klee/util/ExprSMTLIBPrinter.h"
+#include "klee/util/ExprUtil.h"
+
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <stdarg.h>
@@ -26,6 +41,11 @@ using namespace llvm;
 FILE *klee::klee_warning_file = NULL;
 FILE *klee::klee_message_file = NULL;
 
+//muqi
+FILE *klee::klee_muqi_file = NULL;
+FILE *klee::klee_muqi_compare_file = NULL;
+FILE *klee::klee_muqi_compare_file_test = NULL;
+
 static const char *warningPrefix = "WARNING";
 static const char *warningOncePrefix = "WARNING ONCE";
 static const char *errorPrefix = "ERROR";
@@ -102,6 +122,62 @@ static void klee_vfmessage(FILE *fp, const char *pfx, const char *msg,
   fdos.flush();
 }
 
+static void klee_vfmessage_compare(FILE *fp, const char *pfx, const char *msg,
+                           va_list ap) {
+  if (!fp)
+    return;
+
+  llvm::raw_fd_ostream fdos(fileno(fp), /*shouldClose=*/false,
+                            /*unbuffered=*/true);
+  bool modifyConsoleColor = fdos.is_displayed() && (fp == stderr);
+
+  if (modifyConsoleColor) {
+
+    // Warnings
+    if (shouldSetColor(pfx, msg, warningPrefix))
+      fdos.changeColor(llvm::raw_ostream::MAGENTA,
+                       /*bold=*/false,
+                       /*bg=*/false);
+
+    // Once warning
+    if (shouldSetColor(pfx, msg, warningOncePrefix))
+      fdos.changeColor(llvm::raw_ostream::MAGENTA,
+                       /*bold=*/true,
+                       /*bg=*/false);
+
+    // Errors
+    if (shouldSetColor(pfx, msg, errorPrefix))
+      fdos.changeColor(llvm::raw_ostream::RED,
+                       /*bold=*/true,
+                       /*bg=*/false);
+
+    // Notes
+    if (shouldSetColor(pfx, msg, notePrefix))
+      fdos.changeColor(llvm::raw_ostream::WHITE,
+                       /*bold=*/true,
+                       /*bg=*/false);
+  }
+
+  //fdos << "KLEE: ";
+  //if (pfx)
+  //  fdos << pfx << ": ";
+
+  // FIXME: Can't use fdos here because we need to print
+  // a variable number of arguments and do substitution
+  vfprintf(fp, msg, ap);
+  fflush(fp);
+
+  //fdos << "\n";
+
+  if (modifyConsoleColor)
+    fdos.resetColor();
+
+  fdos.flush();
+}
+
+
+
+
 /* Prints a message/warning.
 
    If pfx is NULL, this is a regular message, and it's sent to
@@ -129,6 +205,74 @@ void klee::klee_message(const char *msg, ...) {
   va_end(ap);
 }
 
+
+//muqi
+
+static void klee_vmuqi(const char *pfx, bool onlyToFile, const char *msg,
+                          va_list ap) {
+  if (!onlyToFile) {
+    va_list ap2;
+    va_copy(ap2, ap);
+    klee_vfmessage(stderr, pfx, msg, ap2);
+    va_end(ap2);
+  }
+
+  klee_vfmessage(pfx ? klee_warning_file : klee_muqi_file, pfx, msg, ap);
+}
+#define Muqi_DEBUG;
+void klee::klee_muqi(const char *msg, ...) {
+  #if defined(Muqi_DEBUG)
+  va_list ap;
+  va_start(ap, msg);
+  klee_vmuqi(NULL, false, msg, ap);
+  va_end(ap);
+  #endif
+}
+#define Muqi_DEBUG_Compare
+static void klee_vmuqi_compare(const char *pfx, bool onlyToFile, const char *msg,
+                          va_list ap) {
+  #if defined(Muqi_DEBUG_Compare)
+  if (!onlyToFile) {
+    va_list ap2;
+    va_copy(ap2, ap);
+    klee_vfmessage_compare(stderr, pfx, msg, ap2);
+    va_end(ap2);
+  }
+
+  klee_vfmessage_compare(pfx ? klee_warning_file : klee_muqi_compare_file_test, pfx, msg, ap);
+  #endif
+}
+
+void klee::klee_muqi_compare_test(const char *function_name, const char *msg, ...) {
+   
+   if(function_name == NULL){
+     klee_muqi_compare("\nFunction start: unknown");
+   }else{
+     //llvm::Function *tempfunc = i->getFunction();
+    //->getFunction()->getName().str().c_str()
+     //klee_muqi_compare("\nFunction start: %s ", i->getFunction()->getName().data());
+     //  klee_muqi_compare("\nFunction start: %s ", i->getFunction()->getName().str().c_str());
+     klee_muqi_compare("\nFunction start: %s ", function_name);
+   }
+   va_list pArg;
+   va_start(pArg, msg);
+   klee_vmuqi_compare(NULL, false, msg, pArg);
+   va_end(pArg);
+   klee_muqi_compare("\nFunction end \n");
+
+
+}
+
+
+void klee::klee_muqi_compare(const char *msg, ...) {
+  va_list ap;
+  va_start(ap, msg);
+  klee_vmuqi_compare(NULL, false, msg, ap);
+  va_end(ap);
+}
+
+
+
 /* Message to be written only to file */
 void klee::klee_message_to_file(const char *msg, ...) {
   va_list ap;
diff --git a/runtime/POSIX/fd_64.c b/runtime/POSIX/fd_64.c
index 03fccc4..6a7bae2 100755
--- a/runtime/POSIX/fd_64.c
+++ b/runtime/POSIX/fd_64.c
@@ -107,7 +107,8 @@ int statfs(const char *path, struct statfs *buf) {
   return __fd_statfs(path, buf);
 }
 
-int getdents64(unsigned int fd, struct dirent *dirp, unsigned int count) {
+//int getdents64(unsigned int fd, struct dirent *dirp, unsigned int count) {
+__ssize_t getdents64 (int fd, void *dirp, size_t count){
   return __fd_getdents(fd, (struct dirent64*) dirp, count);
 }
 int __getdents64(unsigned int fd, struct dirent *dirp, unsigned int count)
diff --git a/tools/klee/main.cpp b/tools/klee/main.cpp
index a5dc7c2..a0ace4d 100755
--- a/tools/klee/main.cpp
+++ b/tools/klee/main.cpp
@@ -48,6 +48,9 @@
 #include "llvm/Support/TargetSelect.h"
 #include "llvm/Support/Signals.h"
 
+//muqi
+#include "klee/Expr.h"
+
 #if LLVM_VERSION_CODE < LLVM_VERSION(3, 5)
 #include "llvm/Support/system_error.h"
 #endif
@@ -64,7 +67,7 @@
 #include <iomanip>
 #include <iterator>
 #include <sstream>
-
+#include <regex>
 
 using namespace llvm;
 using namespace klee;
@@ -563,7 +566,7 @@ private:
   char **m_argv;
 
 public:
-  KleeHandler(int argc, char **argv);
+  KleeHandler(std::string programe_function_name,int argc, char **argv);
   ~KleeHandler();
 
   llvm::raw_ostream &getInfoStream() const { return *m_infoFile; }
@@ -593,7 +596,7 @@ public:
   static std::string getRunTimeLibraryPath(const char *argv0);
 };
 
-KleeHandler::KleeHandler(int argc, char **argv)
+KleeHandler::KleeHandler(std::string programe_function_name, int argc, char **argv)
     : m_interpreter(0), m_pathWriter(0), m_symPathWriter(0), m_infoFile(0),
       m_outputDirectory(), m_numTotalTests(0), m_numGeneratedTests(0),
       m_pathsExplored(0), m_argc(argc), m_argv(argv) {
@@ -667,6 +670,62 @@ KleeHandler::KleeHandler(int argc, char **argv)
   if ((klee_message_file = fopen(file_path.c_str(), "w")) == NULL)
     klee_error("cannot open file \"%s\": %s", file_path.c_str(), strerror(errno));
 
+/*
+  //muqi
+  //file_path = getOutputFilename("muqi.txt");
+  file_path = ("/tmp/klee.txt");
+  if ((klee_muqi_file = fopen(file_path.c_str(), "w")) == NULL)
+    klee_error("cannot open file \"%s\": %s", file_path.c_str(), strerror(errno));
+
+  //file_path = getOutputFilename("muqi_symbolic_executation.txt");
+  file_path = ("/tmp/klee_symbolic_executation.txt");
+  if ((klee_muqi_compare_file = fopen(file_path.c_str(), "w")) == NULL)
+    klee_error("cannot open file \"%s\": %s", file_path.c_str(), strerror(errno));
+  
+  //file_path = getOutputFilename("muqi_test.txt");
+  file_path = ("/tmp/klee_test.txt");
+  klee_muqi_compare_file_path = file_path;
+  if ((klee_muqi_compare_file_test = fopen(file_path.c_str(), "a")) == NULL)
+    klee_error("cannot open file \"%s\": %s", file_path.c_str(), strerror(errno));
+*/
+    std::smatch m;
+  std::regex rgx("generatedbc/(.+*?)\\.bc") ;
+  std::regex_search (programe_function_name,m,rgx);
+  programe_function_name = m.str(1);
+
+  file_path = ("/tmp/klee_");
+  file_path += programe_function_name;
+  file_path += ".txt";
+  if ((klee_muqi_file = fopen(file_path.c_str(), "w")) == NULL)
+    klee_error("cannot open file \"%s\": %s", file_path.c_str(), strerror(errno));
+
+  file_path = ("/tmp/klee_");
+  file_path += programe_function_name;
+  file_path += "_symbolic_executation.txt";
+  if ((klee_muqi_compare_file = fopen(file_path.c_str(), "w")) == NULL)
+    klee_error("cannot open file \"%s\": %s", file_path.c_str(), strerror(errno));
+
+  file_path = ("/tmp/klee_");
+  file_path += programe_function_name;
+  file_path += "_test.txt";
+  klee_muqi_compare_file_path = file_path;
+  if ((klee_muqi_compare_file_test = fopen(file_path.c_str(), "a")) == NULL)
+    klee_error("cannot open file \"%s\": %s", file_path.c_str(), strerror(errno));
+
+  file_path = ("/tmp/klee_");
+  file_path += programe_function_name;
+  file_path += "_external_function.txt";
+  klee_muqi_external_function_file_path = file_path;
+
+  file_path = ("/tmp/klee_");
+  file_path += programe_function_name;
+  file_path += "_external_input_bool.txt";
+  klee_muqi_external_bool_file_path = file_path;
+
+  
+  file_path = programe_function_name;
+  klee_muqi_angr_numargs = file_path;
+
   // open info
   m_infoFile = openOutputFile("info");
 }
@@ -677,6 +736,10 @@ KleeHandler::~KleeHandler() {
   fclose(klee_warning_file);
   fclose(klee_message_file);
   delete m_infoFile;
+  //muqi
+  fclose(klee_muqi_file);
+  fclose(klee_muqi_compare_file);
+  fclose(klee_muqi_compare_file_test);
 }
 
 void KleeHandler::setInterpreter(Interpreter *i) {
@@ -2310,7 +2373,7 @@ int main(int argc, char **argv, char **envp) {
 
   Interpreter::InterpreterOptions IOpts;
   IOpts.MakeConcreteSymbolic = MakeConcreteSymbolic;
-  KleeHandler *handler = new KleeHandler(pArgc, pArgv);
+  KleeHandler *handler = new KleeHandler(argv[argc-1],pArgc, pArgv);
   Interpreter *interpreter =
     theInterpreter = Interpreter::create(ctx, IOpts, handler);
   handler->setInterpreter(interpreter);
