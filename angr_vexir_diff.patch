diff --git a/angr/analyses/decompiler/block_simplifier.py b/angr/analyses/decompiler/block_simplifier.py
index 7a4c229af..1ec140a52 100644
--- a/angr/analyses/decompiler/block_simplifier.py
+++ b/angr/analyses/decompiler/block_simplifier.py
@@ -13,6 +13,7 @@ from ...errors import SimMemoryMissingError
 from .. import Analysis, register_analysis
 from .peephole_optimizations import STMT_OPTS, EXPR_OPTS, PeepholeOptimizationStmtBase, PeepholeOptimizationExprBase
 from .ailblock_walker import AILBlockWalker
+from ... import muqi
 
 if TYPE_CHECKING:
     from angr.storage.memory_mixins.paged_memory.pages.multi_values import MultiValues
@@ -264,6 +265,13 @@ class BlockSimplifier(Analysis):
             v = False
 
         def _handle_expr(expr_idx: int, expr: Expression, stmt_idx: int, stmt: Statement, block) -> Optional[Expression]:
+            
+            temp_rules = [ ]
+            try:
+                with open(muqi.decompiler_read_txt,'r') as muqi_file:
+                    temp_rules = muqi_file.readlines()
+            except:
+                pass
 
             old_expr = expr
 
@@ -271,6 +279,15 @@ class BlockSimplifier(Analysis):
             while redo:
                 redo = False
                 for expr_opt in expr_opts:
+                    #muqi block rules
+                    muqi_set = False
+                    for i in range(len(temp_rules)) :  
+                        if expr_opt.NAME in temp_rules[i]:
+                            #print(expr_opt.NAME)
+                            muqi_set = True
+                    if muqi_set:
+                        continue
+
                     if isinstance(expr, expr_opt.expr_classes):
                         r = expr_opt.optimize(expr)
                         if r is not None and r is not expr:
@@ -296,6 +313,13 @@ class BlockSimplifier(Analysis):
     @staticmethod
     def _peephole_optimize_stmts(block, stmt_opts):
 
+        temp_rules = [ ]
+        try:
+            with open(muqi.decompiler_read_txt,'r') as muqi_file:
+                temp_rules = muqi_file.readlines()
+        except:
+            pass
+
         any_update = False
         statements = [ ]
 
@@ -306,6 +330,15 @@ class BlockSimplifier(Analysis):
             while redo:
                 redo = False
                 for opt in stmt_opts:
+                    #muqi block rules
+                    muqi_set = False
+                    for i in range(len(temp_rules)) :  
+                        if opt.NAME in temp_rules[i]:
+                            #print(opt.NAME)
+                            muqi_set = True
+                    if muqi_set:
+                        continue
+
                     if isinstance(stmt, opt.stmt_classes):
                         r = opt.optimize(stmt)
                         if r is not None and r is not stmt:
diff --git a/angr/analyses/decompiler/decompilation_options.py b/angr/analyses/decompiler/decompilation_options.py
index b6ae4d6fc..57c3c0fe1 100644
--- a/angr/analyses/decompiler/decompilation_options.py
+++ b/angr/analyses/decompiler/decompilation_options.py
@@ -103,7 +103,20 @@ options = [
         clears_cache=False,
     ),
 ]
-
+options_muqi = [(
+    O(
+        "Aggressively remove dead memdefs",
+        "Allow the decompiler to aggressively remove memory definitions (such as stack variables) that are deemed dead."
+        " Generally, enabling this option will generate cleaner pseudocode; However, due to limitations of static "
+        "analysis, angr may miss certain uses to a memory definition, which may cause the removal of a memory "
+        "definition that is actually in use, and consequently lead to incorrect decompilation output.",
+        bool,
+        "clinic",
+        "remove_dead_memdefs",
+        category="Data flows",
+        default_value=False,
+    ), False)
+]
 # NOTE: if you add a codegen option here, please add it to reapply_options
 
 options_by_category = defaultdict(list)
diff --git a/angr/analyses/decompiler/decompiler.py b/angr/analyses/decompiler/decompiler.py
index 315f7e306..9d5de234f 100644
--- a/angr/analyses/decompiler/decompiler.py
+++ b/angr/analyses/decompiler/decompiler.py
@@ -16,6 +16,8 @@ from .ailgraph_walker import AILGraphWalker
 from .condition_processor import ConditionProcessor
 from .decompilation_options import DecompilationOption
 from .decompilation_cache import DecompilationCache
+from .decompilation_options import options_muqi
+from ... import muqi
 
 if TYPE_CHECKING:
     from .peephole_optimizations import PeepholeOptimizationStmtBase, PeepholeOptimizationExprBase
@@ -42,10 +44,16 @@ class Decompiler(Analysis):
                  ite_exprs=None,
                  decompile=True,
                  regen_clinic=True,
+                 rules_txt=None
                  ):
+        muqi.decompiler_read_txt = rules_txt
         self.func = func
         self._cfg = cfg
-        self._options = options
+        if options is None:
+            self._options = options_muqi
+        else:
+            self._options = options
+        
         if optimization_passes is None:
             self._optimization_passes = get_default_optimization_passes(self.project.arch, self.project.simos.name)
             l.debug("Get %d optimization passes for the current binary.", len(self._optimization_passes))
@@ -293,8 +301,24 @@ class Decompiler(Analysis):
         """
 
         d = { }
+        #muqi block rules
+        temp_rules = [ ]
+        try:
+            with open(muqi.decompiler_read_txt,'r') as muqi_file:
+                temp_rules = muqi_file.readlines()
+        except:
+            pass
+
         for option, value in options:
             d[option.param] = value
+            #muqi block rules
+            muqi_set = False
+            for i in range(len(temp_rules)) :  
+                if option.NAME in temp_rules[i]:
+                    muqi_set = True
+            if muqi_set:
+                d[option.param] = not value
+
         return d
 
 
diff --git a/angr/analyses/decompiler/structured_codegen/c.py b/angr/analyses/decompiler/structured_codegen/c.py
index aaf653e0c..b5da592d1 100644
--- a/angr/analyses/decompiler/structured_codegen/c.py
+++ b/angr/analyses/decompiler/structured_codegen/c.py
@@ -17,6 +17,9 @@ from ..region_identifier import MultiNode
 from ..structurer import (SequenceNode, CodeNode, ConditionNode, ConditionalBreakNode, LoopNode, BreakNode,
                          SwitchCaseNode, ContinueNode, CascadingConditionNode)
 from .base import BaseStructuredCodeGenerator, InstructionMapping, PositionMapping, PositionMappingElement
+from .... import muqi
+retval_last_muqi =  None
+muqi_dict_name_type ={}
 
 if TYPE_CHECKING:
     from angr.knowledge_plugins.variables.variable_manager import VariableManagerInternal
@@ -260,6 +263,8 @@ class CFunction(CConstruct):  # pylint:disable=abstract-method
                     yield type_pre_spaces, None
                 yield name, cvariable
                 yield type_post, var_type
+                global muqi_dict_name_type
+                muqi_dict_name_type[name] = type_pre + type_post
             else:
                 # multiple types...
                 for i, var_type in enumerate(set(typ for _, typ in cvar_and_vartypes)):
@@ -328,10 +333,84 @@ class CFunction(CConstruct):  # pylint:disable=abstract-method
             yield '\n', None
 
         yield indent_str, None
+        #muqi block rules
+        temp_rules = [ ]
+        try:
+            with open(muqi.decompiler_read_txt,'r') as muqi_file:
+                temp_rules = muqi_file.readlines()
+        except:
+            pass
+
+        global muqi_dict_name_type
+        muqi_set = False
+        for i in range(len(temp_rules)) :
+            if "muqi add rule" in temp_rules[i]:
+                muqi_set = True
+        #print(temp_rules)
+        if muqi_set:
+        #added by muqi by determine return type
+            yield "\n/*\n", None
+            for i, (arg_type, arg) in enumerate(zip(self.functy.args, self.arg_list)):
+                if i:
+                    yield ", ", None
+
+                if isinstance(arg, CVariable):
+                    variable = arg.unified_variable if arg.unified_variable is not None else arg.variable
+                    variable_name = variable.name
+                else:
+                    variable_name = arg.c_repr()
+                raw_type_str: str = arg_type.c_repr(name=variable_name)
+                # FIXME: Add a .c_repr_chunks() to SimType so that we no longer need to parse the string output
+                assert variable_name in raw_type_str
+                varname_pos = raw_type_str.rfind(variable_name)
+                type_pre, type_post = raw_type_str[:varname_pos], raw_type_str[varname_pos + len(variable_name):]
+                if type_pre.endswith(" "):
+                    type_pre_spaces = " " * (len(type_pre) - len(type_pre.rstrip(" ")))
+                    type_pre = type_pre.rstrip(" ")
+                else:
+                    type_pre_spaces = ""
+
+                yield type_pre, arg_type
+                if type_pre_spaces:
+                    yield type_pre_spaces, None
+                yield variable_name, arg
+                yield type_post, arg_type
+                '''
+                print(type_pre)
+                print(arg_type)
+                print(type_post)
+                print(type(type_pre))
+                print(type(arg_type))
+                print(type(type_post))
+                print(variable_name)
+                print(arg)
+                print(type(variable_name))
+                print(type(arg))
+                #global muqi_dict_name_type
+                '''
+                muqi_dict_name_type[variable_name] = type_pre + type_post
+
+            yield from self.variable_list_repr_chunks(indent=indent + INDENT_DELTA)
+            if self.statements is not None:
+                yield from self.statements.c_repr_chunks(indent=indent + INDENT_DELTA)
+            yield "\n*/\n", None
+            if retval_last_muqi :
+                yield retval_last_muqi, None
+                yield " ", None
+            else:
+                # return type
+                yield self.functy.returnty.c_repr(name="").strip(" "), None
+                yield " ", None
+        else:
+            yield self.functy.returnty.c_repr(name="").strip(" "), None
+            yield " ", None
+        '''
+        #this is original return type
         # return type
         yield self.functy.returnty.c_repr(name="").strip(" "), None
         yield " ", None
         # function name
+        '''
         if self.demangled_name:
             normalized_name = get_cpp_function_name(self.demangled_name, specialized=False, qualified=False)
         else:
@@ -958,7 +1037,26 @@ class CReturn(CStatement):
             yield "return ", self
             yield from self.retval.c_repr_chunks()
             yield ";\n", self
-
+            '''
+            print(self.retval)
+            print(self.retval.type)
+            print(self.retval.variable)
+            print(self.retval.variable.name)
+            print(type(self.retval.variable.name))
+            print(muqi_dict_name_type)
+            '''
+            global retval_last_muqi
+            if (isinstance( self.retval,CTypeCast)):
+                try:
+                    retval_last_muqi = self.retval.type
+                except:
+                    pass
+            else:
+                try:
+                    retval_last_muqi = muqi_dict_name_type[self.retval.variable.name]
+                except:
+                    retval_last_muqi = self.retval.type
+            #print(retval_last_muqi)  
 
 class CGoto(CStatement):
 
diff --git a/angr/analyses/identifier/custom_callable.py b/angr/analyses/identifier/custom_callable.py
index 24ac2ed5d..1a1e72b27 100644
--- a/angr/analyses/identifier/custom_callable.py
+++ b/angr/analyses/identifier/custom_callable.py
@@ -67,7 +67,7 @@ class IdentifierCallable(object):
     def get_base_state(self, *args):
         prototype = self._cc.guess_prototype(args)
         self._base_state.ip = self._addr
-        state = self._project.factory.call_state(self._addr, *args,
+        state = self._project.factory.call_state("/tmp/angr_Unknown.txt",self._addr, *args,
                     prototype=prototype,
                     cc=self._cc,
                     base_state=self._base_state,
@@ -79,7 +79,7 @@ class IdentifierCallable(object):
         if prototype is None:
             prototype = self._cc.guess_prototype(args)
         self._base_state.ip = self._addr
-        state = self._project.factory.call_state(self._addr, *args,
+        state = self._project.factory.call_state("/tmp/angr_Unknown.txt",self._addr, *args,
                     cc=self._cc,
                     prototype=prototype,
                     base_state=self._base_state,
diff --git a/angr/callable.py b/angr/callable.py
index 8205944a8..9dd1e8338 100644
--- a/angr/callable.py
+++ b/angr/callable.py
@@ -62,7 +62,7 @@ class Callable(object):
 
     def perform_call(self, *args, prototype=None):
         prototype = SimCC.guess_prototype(args, prototype or self._func_ty).with_arch(self._project.arch)
-        state = self._project.factory.call_state(self._addr, *args,
+        state = self._project.factory.call_state("/tmp/angr_Unknown.txt",self._addr, *args,
                     prototype=prototype,
                     cc=self._cc,
                     base_state=self._base_state,
diff --git a/angr/engines/engine.py b/angr/engines/engine.py
index 87ac525a9..c4ba08e68 100644
--- a/angr/engines/engine.py
+++ b/angr/engines/engine.py
@@ -5,6 +5,8 @@ import threading
 from typing import Optional
 import angr
 
+from .. import muqi
+
 from archinfo.arch_soot import SootAddressDescriptor
 
 l = logging.getLogger(name=__name__)
@@ -123,6 +125,14 @@ class SuccessorsMixin(SimEngine):
         :param force_addr:  Force execution to pretend that we're working at this concrete address
         :returns:           A SimSuccessors object categorizing the execution's successor states
         """
+        #e00038 is the out side address
+        with open(muqi.programe_function_name_txt,'a') as muqi_file:
+        #with open(state.log_filepath_muqi,'a') as muqi_file:
+            if self.successors is None :
+                old_address = 0xe00038
+            else:
+                old_address = self.successors.addr
+
         inline = kwargs.pop('inline', False)
         force_addr = kwargs.pop('force_addr', None)
 
@@ -150,10 +160,18 @@ class SuccessorsMixin(SimEngine):
             new_state.scratch.executed_pages_set = {addr & ~0xFFF}
 
         self.successors = SimSuccessors(addr, old_state)
-
+        
         new_state._inspect('engine_process', when=BP_BEFORE, sim_engine=self, sim_successors=self.successors,
                            address=addr)
         self.successors = new_state._inspect_getattr('sim_successors', self.successors)
+
+        with open(muqi.programe_function_name_txt,'a') as muqi_file:
+            if self.successors is None :
+                print('successors transfer:[',hex(old_address),'->','e00038', ']', file=muqi_file)
+            else:
+                print('successors transfer:[',hex(old_address),'->', hex(self.successors.addr) ,']',file=muqi_file)
+            print('parent state is:[', self.state.history.parent,']',file=muqi_file)
+
         try:
             self.process_successors(self.successors, **kwargs)
         except SimException:
diff --git a/angr/engines/successors.py b/angr/engines/successors.py
index b39681d8d..6859c852e 100644
--- a/angr/engines/successors.py
+++ b/angr/engines/successors.py
@@ -155,6 +155,7 @@ class SimSuccessors:
 
         # apply the guard constraint and new program counter to the state
         if add_guard:
+            print("add constraints of _preprocess_successor")
             state.add_constraints(state.scratch.guard)
         # trigger inspect breakpoints here since this statement technically shows up in the IRSB as the "next"
         state.regs.ip = state.scratch.target
@@ -249,15 +250,19 @@ class SimSuccessors:
             if o.VALIDATE_APPROXIMATIONS in state.options:
                 if state.satisfiable():
                     raise Exception('WTF')
+            print("unsat_successors.append(state) 1")
             self.unsat_successors.append(state)
         elif o.APPROXIMATE_SATISFIABILITY in state.options and not state.solver.satisfiable(exact=False):
             if o.VALIDATE_APPROXIMATIONS in state.options:
                 if state.solver.satisfiable():
                     raise Exception('WTF')
+            print("unsat_successors.append(state) 2")
             self.unsat_successors.append(state)
         elif not state.scratch.guard.symbolic and state.solver.is_false(state.scratch.guard):
+            print("unsat_successors.append(state) 3")
             self.unsat_successors.append(state)
         elif o.LAZY_SOLVES not in state.options and not state.satisfiable():
+            print("unsat_successors.append(state) 4")
             self.unsat_successors.append(state)
         elif o.NO_SYMBOLIC_JUMP_RESOLUTION in state.options and state.solver.symbolic(target):
             self.unconstrained_successors.append(state)
@@ -279,6 +284,7 @@ class SimSuccessors:
                 if concrete_syscall_nums is not None:
                     for i, n in enumerate(concrete_syscall_nums):
                         split_state = state if i == len(concrete_syscall_nums) - 1 else state.copy()
+                        print("add constraint of split_state.add_constraints")
                         split_state.add_constraints(symbolic_syscall_num == n)
                         if split_state.supports_inspect:
                             split_state.inspect.downsize()
@@ -292,6 +298,7 @@ class SimSuccessors:
                     self._fix_syscall_ip(state)
                     self.flat_successors.append(state)
             except (AngrUnsupportedSyscallError, AngrSyscallError):
+                print("unsat_successors.append(state) 5")
                 self.unsat_successors.append(state)
 
         else:
@@ -338,6 +345,7 @@ class SimSuccessors:
                         if o.KEEP_IP_SYMBOLIC in split_state.options:
                             split_state.regs.ip = target
                         else:
+                            print("add constraint of split_state.add_constraints")
                             split_state.add_constraints(cond, action=True)
                             split_state.regs.ip = a
                         if split_state.supports_inspect:
@@ -345,6 +353,7 @@ class SimSuccessors:
                         self.flat_successors.append(split_state)
                     self.successors.append(state)
             except SimSolverModeError:
+                print("unsat_successors.append(state) 6")
                 self.unsat_successors.append(state)
 
         return state
diff --git a/angr/engines/vex/heavy/heavy.py b/angr/engines/vex/heavy/heavy.py
index 52560f8ce..a79bfc80a 100644
--- a/angr/engines/vex/heavy/heavy.py
+++ b/angr/engines/vex/heavy/heavy.py
@@ -10,6 +10,7 @@ from ....utils.constants import DEFAULT_STATEMENT
 from .... import sim_options as o
 from .... import errors
 from . import dirty
+from .... import muqi
 
 l = logging.getLogger(__name__)
 
@@ -146,7 +147,44 @@ class HeavyVEXMixin(SuccessorsMixin, ClaripyDataMixin, SimStateStorageMixin, VEX
             successors.artifacts['irsb_default_jumpkind'] = irsb.jumpkind
             successors.artifacts['insn_addrs'] = []
 
-
+            final_statement = irsb.statements[-1]
+            irsb.pp()
+            '''
+            if final_statement.tag == 'Ist_Exit' :
+                exit_jumpkind = irsb.jumpkind if irsb.jumpkind else ""
+                if exit_jumpkind == "Ijk_Boring":
+            '''
+            loop_bound_cond = False
+            muqi_count = 0
+            muqi_count = self.state.br_instruction_set[hex(irsb.instruction_addresses[-1])] if hex(irsb.instruction_addresses[-1]) in self.state.br_instruction_set else 0
+            '''
+            print("muqi_count:"+str(muqi_count))
+            print(successors.all_successors)
+            print(successors.successors)
+            print(successors.flat_successors)
+            print(successors.unsat_successors)
+            print(successors.unconstrained_successors)
+            '''
+            #uncomment following to enable loop bound
+            #'''
+            if muqi_count >= 3:
+                loop_bound_cond = True
+            #'''
+            if loop_bound_cond == True :
+                with open(muqi.programe_function_name_txt,'a') as muqi_file:
+                    print("block range:[",hex(self.state.addr), "->", hex(self.state.addr+self.state.project.factory.block(self.state.addr).vex.size),"]",file=muqi_file)
+                    print('current state is:[', self.state,']',file=muqi_file)
+                    print('In fakeret',file=muqi_file)
+                    print('----dump z3 start----',file=muqi_file)
+                    print('(_ bv0 64)',file=muqi_file)
+                    print('----dump z3 end----',file=muqi_file)
+                
+                successors.all_successors=[]
+                successors.successors=[]
+                successors.flat_successors=[]
+                successors.unsat_successors=[]
+                successors.unconstrained_successors=[]
+                break
             try:
                 self.handle_vex_block(irsb)
             except errors.SimReliftException as e:
@@ -171,16 +209,100 @@ class HeavyVEXMixin(SuccessorsMixin, ClaripyDataMixin, SimStateStorageMixin, VEX
                 break
             else:
                 break
-
+        print("==============")
+        print("final_statement is :")
+        print(final_statement)
+        print(final_statement.tag)
+        print(irsb.next)
+        print(irsb.jumpkind)
+        print(type(irsb.jumpkind))
+        print(self.state.regs)
+        irsb.next.pp()
+        print(successors.all_successors)
+        print(successors.successors)
+        print(successors.flat_successors)
+        print(successors.unsat_successors)
+        print(successors.unconstrained_successors)
+        if final_statement.tag == 'Ist_Exit' :
+                exit_jumpkind = irsb.jumpkind if irsb.jumpkind else ""
+                if exit_jumpkind == "Ijk_Boring":
+                    if len(list(successors.all_successors)) == 2 and len(list(successors.unsat_successors)) == 0:
+                        with open(muqi.programe_function_name_txt,'a') as muqi_file:
+                            if irsb.next.con.value == irsb.addr+irsb.size:
+                                print('In cbranch',file=muqi_file)
+                                print('address added is:[',hex(final_statement.dst.value),']',file=muqi_file)
+                            else: 
+                                print('In cbranch_flip',file=muqi_file)
+                                print('address added is:[',hex(irsb.next.con.value),']',file=muqi_file)
+                            print('----dump z3 start----',file=muqi_file)
+                            print(claripy._backend_z3.z3_expr_to_smtmuqi(claripy._backend_z3.convert(claripy._backend_z3.simplify( self._analyze_vex_stmt_Exit_guard(final_statement.guard)[0]))),file=muqi_file)
+                            print('----dump z3 end----',file=muqi_file)
+                    elif len(list(successors.all_successors)) == 2 and len(list(successors.unsat_successors)) == 1:
+                        with open(muqi.programe_function_name_txt,'a') as muqi_file:
+                            
+                            print('In branch',file=muqi_file)
+                            print('current address is:[', hex(irsb.addr),']',file=muqi_file)
+                            try:
+                                print('address added is:[', hex((successors.successors)[0].addr),']',file=muqi_file)
+                            except:
+                                print('address added is:[ unknown ]',file=muqi_file)
+                            
+                    for state_succ in list(successors.all_successors):
+                        if hex(irsb.instruction_addresses[-1]) in state_succ.br_instruction_set:
+                            state_succ.br_instruction_set[hex(irsb.instruction_addresses[-1])] += 1
+                            
+                        else:
+                            state_succ.br_instruction_set[hex(irsb.instruction_addresses[-1])] = 1
+        
+        exit_jumpkind = irsb.jumpkind if irsb.jumpkind else ""            
+        #if final_statement.tag != 'Ist_AbiHint' and final_statement.tag != 'Ist_Exit' :
+        if exit_jumpkind == 'Ijk_Ret' :
+           with open(muqi.programe_function_name_txt,'a') as muqi_file:
+                print('In ret',file=muqi_file)
+                print('----dump z3 start----',file=muqi_file)
+                #print(claripy._backend_z3.z3_expr_to_smtmuqi(claripy._backend_z3.convert(claripy._backend_z3.simplify(self.state.regs.rax))),file=muqi_file)
+                print(claripy._backend_z3.z3_expr_to_smtmuqi(claripy._backend_z3.convert(claripy._backend_z3.simplify(self.state.registers.load(self.state.arch.ret_offset, 8)))),file=muqi_file)
+                
+                print('----dump z3 end----',file=muqi_file)
+
+        if exit_jumpkind != 'Ijk_Ret' and exit_jumpkind != 'Ijk_Call' and final_statement.tag != 'Ist_Exit' :
+            with open(muqi.programe_function_name_txt,'a') as muqi_file:
+                print('In branch',file=muqi_file)
+                print('current address is:[', hex(irsb.addr),']',file=muqi_file)
+                try:
+                    print('address added is:[', hex(irsb.next.con.value),']',file=muqi_file)
+                    #print(irsb.next)
+                    #print(type(irsb.next))
+                except:
+                    print('address added is:[ unknown ]',file=muqi_file)            
+            for state_succ in list(successors.all_successors):
+                if hex(irsb.instruction_addresses[-1]) in state_succ.br_instruction_set:
+                    #state_succ.br_instruction_set[final_statement] += 1
+                    state_succ.br_instruction_set[hex(irsb.instruction_addresses[-1])] += 1
+                    
+                else:
+                    #state_succ.br_instruction_set[final_statement] = 1
+                    state_succ.br_instruction_set[hex(irsb.instruction_addresses[-1])] = 1
         # do return emulation and calless stuff
         for exit_state in list(successors.all_successors):
             exit_jumpkind = exit_state.history.jumpkind if exit_state.history.jumpkind else ""
 
             if o.CALLLESS in self.state.options and exit_jumpkind == "Ijk_Call":
+                '''
                 exit_state.registers.store(
                     exit_state.arch.ret_offset,
                     exit_state.solver.Unconstrained('fake_ret_value', exit_state.arch.bits)
                 )
+                '''
+                exit_state.registers.store(
+                    exit_state.arch.ret_offset,
+                    #muqi_change here
+                    #make internal/external call return 0.
+                    claripy.BVV(0, exit_state.arch.bits),
+                   # exit_state.solver.Unconstrained(
+                   #     "fake_ret_value", exit_state.arch.bits
+                   # ),
+                )
                 exit_state.scratch.target = exit_state.solver.BVV(
                     successors.addr + irsb.size, exit_state.arch.bits
                 )
@@ -212,6 +334,8 @@ class HeavyVEXMixin(SuccessorsMixin, ClaripyDataMixin, SimStateStorageMixin, VEX
     # statements
 
     def _handle_vex_stmt(self, stmt):
+        print("In _handle_vex_stmt")
+        print(stmt)
         self.state.scratch.stmt_idx = self.stmt_idx
         super()._handle_vex_stmt(stmt)
 
@@ -242,39 +366,52 @@ class HeavyVEXMixin(SuccessorsMixin, ClaripyDataMixin, SimStateStorageMixin, VEX
         cont_state = None
         exit_state = None
         guard = guard != 0
+        print("In _perform_vex_stmt_Exit")
 
         if o.COPY_STATES not in self.state.options:
             # very special logic to try to minimize copies
             # first, check if this branch is impossible
             if guard.is_false():
+                print("guard.is_false()")
                 cont_state = self.state
             elif o.LAZY_SOLVES not in self.state.options and not self.state.solver.satisfiable(extra_constraints=(guard,)):
+                print("cont_state = self.state")
                 cont_state = self.state
 
             # then, check if it's impossible to continue from this branch
             elif guard.is_true():
+                print("guard is true")
                 exit_state = self.state
             elif o.LAZY_SOLVES not in self.state.options and not self.state.solver.satisfiable(extra_constraints=(claripy.Not(guard),)):
+                print("exit_state = self.state")
                 exit_state = self.state
             else:
+                print("final else")
                 exit_state = self.state.copy()
                 cont_state = self.state
         else:
+            print("Copy state in state options")
             exit_state = self.state.copy()
             cont_state = self.state
 
         if exit_state is not None:
+            print(" exit_state is not None:")
             self.successors.add_successor(exit_state, target, guard, jumpkind,
                                      exit_stmt_idx=self.stmt_idx, exit_ins_addr=self.state.scratch.ins_addr)
 
         if cont_state is None:
+            print("cont_state is None:")
             raise VEXEarlyExit
 
+        print("End of _perform_vex_stmt_Exit")
+        print("add constraint of _perform_vex_stmt_Exit")
         # Do our bookkeeping on the continuing self.state
         cont_condition = ~guard
         cont_state.add_constraints(cont_condition)
         cont_state.scratch.guard = claripy.And(cont_state.scratch.guard, cont_condition)
 
+        print((cont_state.scratch.guard))
+        print(claripy._backend_z3.z3_expr_to_smtmuqi(claripy._backend_z3.convert(claripy._backend_z3.simplify( cont_state.scratch.guard))))
     def _perform_vex_stmt_Dirty_call(self, func_name, ty, args, func=None):
         if func is None:
             try:
@@ -282,6 +419,7 @@ class HeavyVEXMixin(SuccessorsMixin, ClaripyDataMixin, SimStateStorageMixin, VEX
             except AttributeError as e:
                 raise errors.UnsupportedDirtyError(f"Unsupported dirty helper {func_name}") from e
         retval, retval_constraints = func(self.state, *args)
+        print("add constraint of _perform_vex_stmt_Dirty_call")
         self.state.add_constraints(*retval_constraints)
         return retval
 
@@ -294,12 +432,16 @@ class HeavyVEXMixin(SuccessorsMixin, ClaripyDataMixin, SimStateStorageMixin, VEX
 
         if self.state.solver.symbolic(result) and o.CONCRETIZE in self.state.options:
             concrete_value = self.state.solver.BVV(self.state.solver.eval(result), len(result))
+            print("add constraint of _instrument_vex_expr")
             self.state.add_constraints(result == concrete_value)
             result = concrete_value
 
         return super()._instrument_vex_expr(result)
 
     def _perform_vex_expr_Load(self, addr, ty, endness, **kwargs):
+        print("In _perform_vex_expr_Load")
+        print(addr)
+        print(ty)
         result = super()._perform_vex_expr_Load(addr, ty, endness, **kwargs)
         if o.UNINITIALIZED_ACCESS_AWARENESS in self.state.options:
             if getattr(addr._model_vsa, 'uninitialized', False):
diff --git a/angr/engines/vex/light/light.py b/angr/engines/vex/light/light.py
index a52265fc3..0698a93d1 100644
--- a/angr/engines/vex/light/light.py
+++ b/angr/engines/vex/light/light.py
@@ -6,6 +6,11 @@ import pyvex
 from ...engine import SimEngineBase
 from ....utils.constants import DEFAULT_STATEMENT
 
+from .... import muqi
+import claripy
+#from claripy import claripy.backends
+from claripy.ast.bv import BV
+
 l = logging.getLogger(name=__name__)
 
 #pylint:disable=arguments-differ,unused-argument,no-self-use
@@ -166,7 +171,20 @@ class VEXMixin(SimEngineBase):
         pass
 
     def _handle_vex_stmt_AbiHint(self, stmt):
-        pass
+        if self.irsb.jumpkind == "Ijk_Ret" :
+            #print("muqi test return")
+            #print(self.state.regs.rax)
+            pass
+            '''
+            with open(muqi.programe_function_name_txt,'a') as muqi_file:
+                print('In ret',file=muqi_file)
+                print('----dump z3 start----',file=muqi_file)
+                print(claripy._backend_z3.z3_expr_to_smtmuqi(claripy._backend_z3.convert(claripy._backend_z3.simplify(self.state.regs.rax))),file=muqi_file)
+                print('----dump z3 end----',file=muqi_file)
+            '''
+        elif self.irsb.jumpkind == "Ijk_Call" :
+            #print("muqi test call")
+            pass
 
     def _handle_vex_stmt_MBE(self, stmt):
         pass
@@ -203,6 +221,33 @@ class VEXMixin(SimEngineBase):
 
     def _analyze_vex_stmt_Exit_guard(self, *a, **kw): return self. _handle_vex_expr(*a, **kw)
     def _handle_vex_stmt_Exit(self, stmt: pyvex.stmt.Exit):
+        #print("In _handle_vex_stmt_Exit")
+        #print(stmt)
+        if self.irsb.jumpkind == "Ijk_Ret" :
+            pass
+        elif self.irsb.jumpkind == "Ijk_Boring" :
+            '''
+            with open(muqi.programe_function_name_txt,'a') as muqi_file:
+                
+                if self.irsb.next.con.value == self.irsb.addr+self.irsb.size:
+                    print('In cbranch',file=muqi_file)
+                    print('address added is:[',hex(stmt.dst.value),']',file=muqi_file)
+                else:
+                    print('In cbranch_flip',file=muqi_file)
+                    print('address added is:[',hex(self.irsb.next.con.value),']',file=muqi_file)
+                print('----dump z3 start----',file=muqi_file)
+                print(claripy._backend_z3.z3_expr_to_smtmuqi(claripy._backend_z3.convert(claripy._backend_z3.simplify( self._analyze_vex_stmt_Exit_guard(stmt.guard)[0]))),file=muqi_file)
+                print('----dump z3 end----',file=muqi_file)
+            '''
+            print("cbranch or cbranch_flip")
+            print((stmt.guard))
+            print(claripy._backend_z3.z3_expr_to_smtmuqi(claripy._backend_z3.convert(claripy._backend_z3.simplify( self._analyze_vex_stmt_Exit_guard(stmt.guard)[0]))))
+
+            pass
+        elif self.irsb.jumpkind == "Ijk_Call" :
+            pass
+        else :
+            pass
         self._perform_vex_stmt_Exit(
             self._analyze_vex_stmt_Exit_guard(stmt.guard),
             self._handle_vex_const(stmt.dst),
@@ -441,12 +486,28 @@ class VEXMixin(SimEngineBase):
         self.irsb = irsb
         self.tmps = [None]*self.irsb.tyenv.types_used
 
+        with open(muqi.programe_function_name_txt,'a') as muqi_file:
+            #with open(self.state.log_filepath_muqi,'a') as muqi_file:
+                print("block range:[",hex(irsb.addr), "->", hex(irsb.addr +irsb.size),"]",file=muqi_file)
+                print('current state is:[', self.state,']',file=muqi_file)
+        
+        final_statement = irsb.statements[-1]
+
         for stmt_idx, stmt in enumerate(irsb.statements):
             self.stmt_idx = stmt_idx
             self._handle_vex_stmt(stmt)
         self.stmt_idx = DEFAULT_STATEMENT
         self._handle_vex_defaultexit(irsb.next, irsb.jumpkind)
-
+        '''
+        if final_statement.tag != 'Ist_AbiHint' and final_statement.tag != 'Ist_Exit' :
+            with open(muqi.programe_function_name_txt,'a') as muqi_file:
+                print('In branch',file=muqi_file)
+                print('current address is:[', hex(irsb.addr),']',file=muqi_file)
+                try:
+                    print('address added is:[', hex(irsb.next.con.value),']',file=muqi_file)
+                except:
+                    print('address added is:[ unknown ]',file=muqi_file)
+        '''
     def _handle_vex_defaultexit(self, expr: Optional[pyvex.expr.IRExpr], jumpkind: str):
         self._perform_vex_defaultexit(
             self._analyze_vex_defaultexit(expr) if expr is not None else None,
diff --git a/angr/exploration_techniques/loop_seer.py b/angr/exploration_techniques/loop_seer.py
index db6e41be3..daf66e713 100644
--- a/angr/exploration_techniques/loop_seer.py
+++ b/angr/exploration_techniques/loop_seer.py
@@ -3,7 +3,7 @@ import logging
 from . import ExplorationTechnique
 from ..knowledge_base import KnowledgeBase
 from ..knowledge_plugins.functions import Function
-
+from ..import muqi
 
 l = logging.getLogger(name=__name__)
 
@@ -157,7 +157,21 @@ class LoopSeer(ExplorationTechnique):
                     else:
                         if succ_state.addr in succ_state.loop_data.back_edge_trip_counts:
                             counts = succ_state.loop_data.back_edge_trip_counts[succ_state.addr][-1]
-                    if counts > self.bound:
+                    
+                    muqi_count = 0
+                    muqi_count_hash = {}
+                    for addr in succ_state.history.bbl_addrs:
+                        if addr in muqi_count_hash:
+                            muqi_count_hash[addr] += 1
+                        else:
+                            muqi_count_hash[addr] = 1
+                    if succ_state.addr in muqi_count_hash:
+                        muqi_count_hash[addr] += 1
+                    else:
+                        muqi_count_hash[addr] = 1
+                    muqi_count = max(muqi_count_hash.values())
+
+                    if counts > self.bound or muqi_count > self.bound:
                         if self.bound_reached is not None:
                             # We want to pass self to modify the LoopSeer state if needed
                             # Users can modify succ_state in the handler to implement their own logic
@@ -166,6 +180,21 @@ class LoopSeer(ExplorationTechnique):
                         else:
                             # Remove the state from the successors object
                             # This state is going to be filtered by the self.filter function
+                            with open(muqi.programe_function_name_txt,'a') as muqi_file:
+                                #muqi add fake return node here for branch
+                                print('successors transfer:[',hex(state.addr),'->', hex(succ_state.addr) ,']',file=muqi_file)
+                                print('parent state is:[', succ_state.history,']',file=muqi_file)
+                                print("block range:[",hex(succ_state.addr), "->", hex(succ_state.addr +succ_state.project.factory.block(succ_state.addr).vex.size),"]",file=muqi_file)
+                                print('current state is:[', succ_state,']',file=muqi_file)
+                                print('In fakeret',file=muqi_file)
+                                print('----dump z3 start----',file=muqi_file)
+                                print('; benchmark',file=muqi_file)
+                                print('(_ bv0 64)',file=muqi_file)
+                                print('----dump z3 end----',file=muqi_file)
+                                
+			                
+
+
                             self.cut_succs.append(succ_state)
 
                 l.debug("%s back edge based trip counts %s", state, state.loop_data.back_edge_trip_counts)
@@ -190,7 +219,13 @@ class LoopSeer(ExplorationTechnique):
                         succ_state.loop_data.back_edge_trip_counts[node.addr].append(0)
 
                 # save info about current active loop for the succ state
-                succ_state.loop_data.header_trip_counts[header].append(1)
+                #succ_state.loop_data.header_trip_counts[header].append(1)
+                #muqi we change here for the new header count method
+                if not succ_state.loop_data.header_trip_counts[header]:
+                    succ_state.loop_data.header_trip_counts[header].append(1)
+                else:
+                    succ_state.loop_data.header_trip_counts[header][-1]  += 1
+
                 succ_state.loop_data.current_loop.append((loop, exits))
         return succs
 
diff --git a/angr/factory.py b/angr/factory.py
index 0b933232d..d647381dd 100644
--- a/angr/factory.py
+++ b/angr/factory.py
@@ -9,6 +9,7 @@ from .callable import Callable
 from .errors import AngrAssemblyError
 from .engines import UberEngine, ProcedureEngine, SimEngineConcrete
 
+from . import muqi
 
 l = logging.getLogger(name=__name__)
 
@@ -108,7 +109,7 @@ class AngrObjectFactory:
         """
         return self.project.simos.state_full_init(**kwargs)
 
-    def call_state(self, addr, *args, **kwargs):
+    def call_state(self,  input_txt, addr, *args, **kwargs):
         """
         Returns a state object initialized to the start of a given function, as if it were called with given parameters.
 
@@ -150,6 +151,7 @@ class AngrObjectFactory:
         set alloc_base to point to somewhere other than the stack, set grow_like_stack to False so that sequencial
         allocations happen at increasing addresses.
         """
+        muqi.programe_function_name_txt = input_txt
         return self.project.simos.state_call(addr, *args, **kwargs)
 
     def simulation_manager(self, thing: Optional[Union[List[SimState], SimState]]=None, **kwargs) -> 'SimulationManager':
diff --git a/angr/sim_manager.py b/angr/sim_manager.py
index 2b8a67e9c..5802d83e7 100644
--- a/angr/sim_manager.py
+++ b/angr/sim_manager.py
@@ -15,7 +15,7 @@ from .sim_state import SimState
 from .state_hierarchy import StateHierarchy
 from .errors import AngrError, SimUnsatError, SimulationManagerError
 from .sim_options import LAZY_SOLVES
-
+from . import muqi
 l = logging.getLogger(name=__name__)
 
 
@@ -79,6 +79,9 @@ class SimulationManager:
             **kwargs):
         super().__init__()
 
+        self.jumpout_edge = []
+        self.abort_edge = []
+
         self._project = project
         self.completion_mode = completion_mode
         self._errored = []
@@ -415,12 +418,115 @@ class SimulationManager:
             return step_func(self)
         return self
 
+    #jumpout_edge = []
+    def input_jumpout_edge(self, input_jumpout_list):
+        self.jumpout_edge = input_jumpout_list
+    def input_abort_edge(self, input_abort_list):
+        self.abort_edge = input_abort_list
+
     def step_state(self, state, successor_func=None, **run_args):
         """
         Don't use this function manually - it is meant to interface with exploration techniques.
         """
         try:
             successors = self.successors(state, successor_func=successor_func, **run_args)
+            
+            for exit_state in list(successors.all_successors):
+                exit_jumpkind = exit_state.history.jumpkind
+
+                if exit_jumpkind is None:
+                    exit_jumpkind = ""
+
+                cond1 = exit_jumpkind == "Ijk_Boring" and exit_state.addr in self.jumpout_edge
+                #defaultly, we do not need to h
+                cond2 = False
+                if exit_state.scratch.irsb :
+                    try:
+                        call_address = exit_state.scratch.irsb.next.con.value
+                        cond2 = exit_state.scratch.irsb.jumpkind == "Ijk_Call" and call_address in self.abort_edge
+                    except:
+                        pass
+
+                if cond1==True or cond2 ==True :
+                    successors.all_successors.remove(exit_state)
+                
+                    with open(muqi.programe_function_name_txt,'a') as muqi_file:
+                        print('successors transfer:[',hex(state.addr),'->', hex(exit_state.addr) ,']',file=muqi_file)
+                        print('parent state is:[', exit_state.history,']',file=muqi_file)
+                        if cond1 == True:
+                            #muqi, since we use transition_graph in D-helix to identify the node's range, the jmp out address cannot be in this function's transition_graph
+                            #hence we give node size as 0
+                            print("block range:[",hex(exit_state.addr), "->", hex(exit_state.addr),"]",file=muqi_file)
+                        if cond2 == True:
+                            #hex(succ_state.addr +succ_state.project.factory.block(succ_state.addr).vex.size)
+                            print("block range:[",hex(exit_state.addr), "->", hex(exit_state.addr+exit_state.project.factory.block(exit_state.addr).vex.size),"]",file=muqi_file)
+                        print('current state is:[', exit_state,']',file=muqi_file)
+                        print('In fakeret',file=muqi_file)
+                        print('----dump z3 start----',file=muqi_file)
+                        print('(_ bv0 64)',file=muqi_file)
+                        print('----dump z3 end----',file=muqi_file)
+
+            for exit_state in list(successors.successors):
+                exit_jumpkind = exit_state.history.jumpkind
+                if exit_jumpkind is None:
+                    exit_jumpkind = ""
+                cond1 = exit_jumpkind == "Ijk_Boring" and exit_state.addr in self.jumpout_edge
+                cond2 = False
+                if exit_state.scratch.irsb :
+                    try:
+                        call_address = exit_state.scratch.irsb.next.con.value
+                        cond2 = exit_state.scratch.irsb.jumpkind == "Ijk_Call" and call_address in self.abort_edge
+                    except:
+                        pass
+                if cond1==True or cond2 ==True :
+                   successors.successors.remove(exit_state)
+
+            for exit_state in list(successors.flat_successors):
+                exit_jumpkind = exit_state.history.jumpkind
+                if exit_jumpkind is None:
+                    exit_jumpkind = ""
+                cond1 = exit_jumpkind == "Ijk_Boring" and exit_state.addr in self.jumpout_edge
+                cond2 = False
+                if exit_state.scratch.irsb :
+                    try:
+                        call_address = exit_state.scratch.irsb.next.con.value
+                        cond2 = exit_state.scratch.irsb.jumpkind == "Ijk_Call" and call_address in self.abort_edge
+                    except:
+                        pass
+                if cond1==True or cond2 ==True :
+                   successors.flat_successors.remove(exit_state)
+
+            for exit_state in list(successors.unsat_successors):
+                exit_jumpkind = exit_state.history.jumpkind
+                if exit_jumpkind is None:
+                    exit_jumpkind = ""
+                cond1 = exit_jumpkind == "Ijk_Boring" and exit_state.addr in self.jumpout_edge
+                cond2 = False
+                if exit_state.scratch.irsb :
+                    try:
+                        call_address = exit_state.scratch.irsb.next.con.value
+                        cond2 = exit_state.scratch.irsb.jumpkind == "Ijk_Call" and call_address in self.abort_edge
+                    except:
+                        pass
+                if cond1==True or cond2 ==True :
+                   successors.unsat_successors.remove(exit_state)
+        
+            for exit_state in list(successors.unconstrained_successors):
+                exit_jumpkind = exit_state.history.jumpkind
+                if exit_jumpkind is None:
+                    exit_jumpkind = ""
+                cond1 = exit_jumpkind == "Ijk_Boring" and exit_state.addr in self.jumpout_edge
+                cond2 = False
+                if exit_state.scratch.irsb :
+                    try:
+                        call_address = exit_state.scratch.irsb.next.con.value
+                        cond2 = exit_state.scratch.irsb.jumpkind == "Ijk_Call" and call_address in self.abort_edge
+                    except:
+                        pass
+                if cond1==True or cond2 ==True :
+                   successors.unconstrained_successors.remove(exit_state)
+
+
             stashes = {None: successors.flat_successors,
                        'unsat': successors.unsat_successors,
                        'unconstrained': successors.unconstrained_successors}
diff --git a/angr/sim_state.py b/angr/sim_state.py
index 6815b3c10..747c0faef 100644
--- a/angr/sim_state.py
+++ b/angr/sim_state.py
@@ -2,7 +2,7 @@ import functools
 import itertools
 import contextlib
 import weakref
-
+import traceback
 import logging
 
 from typing import Type, TypeVar, TYPE_CHECKING
@@ -102,6 +102,7 @@ class SimState(PluginHub):
         # Java & Java JNI
         self._is_java_project = self.project and self.project.is_java_project
         self._is_java_jni_project = self.project and self.project.is_java_jni_project
+        self.br_instruction_set = {}
 
         # Arch
         if self._is_java_jni_project:
@@ -473,6 +474,8 @@ class SimState(PluginHub):
 
         You may pass in any number of symbolic booleans as variadic positional arguments.
         """
+        #traceback.print_stack()
+        print("In sim_state add_constraints")
         if len(args) > 0 and isinstance(args[0], (list, tuple)):
             raise Exception("Tuple or list passed to add_constraints!")
 
@@ -560,14 +563,26 @@ class SimState(PluginHub):
         """
         Whether the state's constraints are satisfiable
         """
+        print("In sim_state satisfiable")
         if o.ABSTRACT_SOLVER in self.options or o.SYMBOLIC not in self.options:
             extra_constraints = kwargs.pop('extra_constraints', ())
             for e in extra_constraints:
                 if self.solver.is_false(e):
+                    '''
+                    print(e)
+                    print("e:False")
+                    '''
                     return False
-
+            '''
+            print("self._satisfiable")
+            print(self._satisfiable)
+            '''
             return self._satisfiable
         else:
+            print("self.solver.satisfiable(**kwargs)")
+            #print(**kwargs)
+            #print(self.solver.satisfiable(**kwargs))
+            #print(self.solver)
             return self.solver.satisfiable(**kwargs)
 
     def downsize(self):
@@ -619,7 +634,7 @@ class SimState(PluginHub):
         """
         Returns a copy of the state.
         """
-
+        print("state .copy started")
         if self._global_condition is not None:
             raise SimStateError("global condition was not cleared before state.copy().")
 
@@ -633,7 +648,9 @@ class SimState(PluginHub):
         state.uninitialized_access_handler = self.uninitialized_access_handler
         state._special_memory_filler = self._special_memory_filler
         state.ip_constraints = self.ip_constraints
+        state.br_instruction_set = self.br_instruction_set.copy()
 
+        print("state .copy finished")
         return state
 
     def merge(self, *others, **kwargs):
@@ -726,6 +743,7 @@ class SimState(PluginHub):
                 l.debug('Merging occurred in %s', p)
                 merging_occurred = True
 
+        print("merge add_constraints")
         merged.add_constraints(merged.solver.Or(*merge_conditions))
         return merged, merge_conditions, merging_occurred
 
@@ -826,6 +844,7 @@ class SimState(PluginHub):
             return self.solver.eval(expr)
 
         v = self.solver.eval(expr)
+        print("make concrete_int add_constraints")
         self.add_constraints(expr == v)
         return v
 
diff --git a/angr/state_plugins/solver.py b/angr/state_plugins/solver.py
index 4de19818d..7cb8cd2f6 100644
--- a/angr/state_plugins/solver.py
+++ b/angr/state_plugins/solver.py
@@ -2,6 +2,7 @@ import binascii
 import functools
 import time
 import logging
+import traceback
 from typing import Type, TypeVar, overload, Any, Optional
 
 from claripy import backend_manager
@@ -646,12 +647,18 @@ class SimSolver(SimStatePlugin):
 
         :return:                    True if sat, otherwise false
         """
+        print("In solver satisfiable")
+
         if exact is False and o.VALIDATE_APPROXIMATIONS in self.state.options:
             er = self._solver.satisfiable(extra_constraints=self._adjust_constraint_list(extra_constraints))
             ar = self._solver.satisfiable(extra_constraints=self._adjust_constraint_list(extra_constraints), exact=False)
             if er is True:
                 assert ar is True
             return ar
+        print("In solver satisfiablabefore return")
+        print(self._solver.satisfiable(extra_constraints=self._adjust_constraint_list(extra_constraints), exact=exact))
+        print(self._solver.constraints)
+        print(self._solver)
         return self._solver.satisfiable(extra_constraints=self._adjust_constraint_list(extra_constraints), exact=exact)
 
     @timed_function
@@ -664,6 +671,14 @@ class SimSolver(SimStatePlugin):
         :param constraints:     Pass any constraints that you want to add (ASTs) as varargs.
         """
         cc = self._adjust_constraint_list(constraints)
+        tb = "tb"
+        try:
+            raise ValueError
+        except ValueError:
+            tb = traceback.format_stack()
+        print(tb)
+        print("In add of solver")
+        print(cc)
         return self._solver.add(cc)
 
     #
diff --git a/pyproject.toml b/pyproject.toml
index 647e2d244..6510e4109 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,3 +1,3 @@
 [build-system]
-requires = ["setuptools>=59", "wheel", "pyvex==9.2.10.dev0", "unicorn==1.0.2rc4"]
+requires = ["setuptools>=59", "wheel",  "unicorn==1.0.2rc4"]
 build-backend = "setuptools.build_meta"
